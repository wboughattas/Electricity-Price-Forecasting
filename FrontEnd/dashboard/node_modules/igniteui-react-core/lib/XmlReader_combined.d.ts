import { Base, IDisposable, Type, Stream } from "./type";
import { XmlNameTable } from "./XmlNameTable";
import { XmlNodeType } from "./xml";
import { ReadState } from "./ReadState";
import { XmlSpace } from "./XmlSpace";
import { WriteState } from "./WriteState";
import { Formatting } from "./Formatting";
import { Encoding } from "./Encoding";
import { TextWriter } from "./TextWriter";
/**
 * @hidden
 */
export declare abstract class XmlReader extends Base implements IDisposable {
    static $t: Type;
    private at;
    constructor();
    abstract readonly w: number;
    abstract readonly z: string;
    protected get_a(): boolean;
    readonly a: boolean;
    protected get_b(): boolean;
    readonly b: boolean;
    protected get_c(): boolean;
    readonly c: boolean;
    abstract readonly x: number;
    abstract readonly d: boolean;
    protected get_e(): boolean;
    readonly e: boolean;
    abstract readonly f: boolean;
    abstract readonly i: boolean;
    abstract readonly h: boolean;
    abstract item(a: number): string;
    abstract item1(a: string): string;
    abstract item2(a: string, b: string): string;
    abstract readonly ag: string;
    abstract readonly ai: string;
    abstract readonly aj: string;
    abstract readonly a5: XmlNameTable;
    abstract readonly a7: XmlNodeType;
    abstract readonly ak: string;
    abstract readonly v: string;
    abstract readonly a3: ReadState;
    abstract readonly ar: string;
    abstract readonly as: string;
    abstract readonly a8: XmlSpace;
    abstract au(): void;
    abstract aa(a: number): string;
    abstract ab(a: string): string;
    abstract ac(a: string, b: string): string;
    static j(a: string): boolean;
    static k(a: string): boolean;
    l(): boolean;
    m(a: string): boolean;
    n(a: string, b: string): boolean;
    abstract ah(a: string): string;
    abstract aw(a: number): void;
    abstract o(a: string): boolean;
    abstract p(a: string, b: string): boolean;
    private g;
    a6(): XmlNodeType;
    abstract q(): boolean;
    abstract r(): boolean;
    abstract s(): boolean;
    abstract t(): boolean;
    abstract u(): boolean;
    al(): string;
    am(a: string): string;
    an(a: string, b: string): string;
    ax(): void;
    ao(): string;
    ap(): string;
    ay(): void;
    az(a: string): void;
    a0(a: string, b: string): void;
    aq(): string;
    y(a: string[], b: number, c: number): number;
    abstract a1(): void;
    a2(): void;
    private a4;
    dispose(): void;
    protected disposeCore(a: boolean): void;
}
/**
 * @hidden
 */
export declare abstract class XmlWriter extends Base implements IDisposable {
    static $t: Type;
    constructor();
    abstract readonly as: WriteState;
    abstract readonly b: string;
    abstract readonly at: XmlSpace;
    abstract c(): void;
    protected DisposeImpl(a: boolean): void;
    dispose(): void;
    abstract e(): void;
    abstract a(a: string): string;
    private f;
    g(a: XmlReader, b: boolean): void;
    h(a: string, b: string): void;
    i(a: string, b: string, c: string): void;
    j(a: string, b: string, c: string, d: string): void;
    abstract k(a: number[], b: number, c: number): void;
    abstract l(a: number[], b: number, c: number): void;
    abstract m(a: string): void;
    abstract n(a: string): void;
    abstract o(a: string[], b: number, c: number): void;
    abstract p(a: string): void;
    abstract q(a: string, b: string, c: string, d: string): void;
    r(a: string, b: string): void;
    s(a: string, b: string, c: string): void;
    abstract t(): void;
    abstract u(): void;
    abstract v(): void;
    abstract w(a: string): void;
    abstract x(): void;
    abstract y(a: string): void;
    abstract aa(a: string): void;
    abstract ae(a: string, b: string): void;
    z(a: string): void;
    ab(a: string): void;
    af(a: string, b: string): void;
    ac(a: XmlReader, b: boolean): void;
    abstract ad(a: string, b: string): void;
    abstract ah(a: string): void;
    abstract ag(a: string[], b: number, c: number): void;
    ai(a: string, b: string): void;
    abstract aj(a: string, b: string, c: string): void;
    abstract ak(): void;
    abstract al(a: boolean): void;
    am(a: string): void;
    an(a: string, b: string): void;
    abstract ao(a: string, b: string, c: string): void;
    abstract ap(a: string): void;
    abstract aq(a: string, b: string): void;
    abstract ar(a: string): void;
}
/**
 * @hidden
 */
export declare class XmlTextWriter extends XmlWriter {
    static $t: Type;
    private static readonly by;
    private static aw;
    private static av;
    private bm;
    private bp;
    private bq;
    private bo;
    private bv;
    private a4;
    private ax;
    private az;
    private a0;
    private a5;
    private cn;
    private ay;
    private cj;
    private a3;
    private ck;
    private cm;
    private cl;
    private bl;
    private au;
    private be;
    private bd;
    private ci;
    private a1;
    private bj;
    private a9;
    private bs;
    private bu;
    private a2;
    private bb;
    private a7;
    constructor(a: number, b: Stream, c: Encoding);
    constructor(a: number, b: TextWriter);
    constructor(a: number, ..._rest: any[]);
    private b3;
    ch: Formatting;
    bk: number;
    ba: string;
    bc: string;
    protected get_b(): string;
    readonly b: string;
    protected get_at(): XmlSpace;
    readonly at: XmlSpace;
    protected get_as(): WriteState;
    readonly as: WriteState;
    a(a: string): string;
    readonly bn: Stream;
    c(): void;
    e(): void;
    a6: boolean;
    ak(): void;
    al(a: boolean): void;
    private cg;
    u(): void;
    q(a: string, b: string, c: string, d: string): void;
    ao(a: string, b: string, c: string): void;
    private b1;
    private b2;
    v(): void;
    x(): void;
    private ca;
    aj(a: string, b: string, c: string): void;
    private br;
    private bt;
    t(): void;
    p(a: string): void;
    ad(a: string, b: string): void;
    ar(a: string): void;
    m(a: string): void;
    ap(a: string): void;
    ah(a: string): void;
    n(a: string): void;
    aq(a: string, b: string): void;
    private b7;
    w(a: string): void;
    y(a: string): void;
    aa(a: string): void;
    ae(a: string, b: string): void;
    private bz;
    k(a: number[], b: number, c: number): void;
    l(a: number[], b: number, c: number): void;
    o(a: string[], b: number, c: number): void;
    ag(a: string[], b: number, c: number): void;
    private cd;
    private cf;
    private ce;
    private a8;
    private b4;
    private b6;
    private b0;
    private b5;
    private cc;
    private b9;
    private b8;
    private cb;
    private bg;
    private bf;
    private bh;
    private bi;
}

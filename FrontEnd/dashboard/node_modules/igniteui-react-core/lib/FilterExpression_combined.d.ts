import { Base, Type } from "./type";
import { IFilterExpression } from "./IFilterExpression";
import { DataSourceSchemaPropertyType } from "./DataSourceSchemaPropertyType";
import { FilterExpressionOperatorType } from "./FilterExpressionOperatorType";
import { FilterExpressionFunctionType } from "./FilterExpressionFunctionType";
import { IDataSourceDataProvider } from "./IDataSourceDataProvider";
import { IDataSourceSchema } from "./IDataSourceSchema";
import { IOperationFilterExpression } from "./IOperationFilterExpression";
import { IFunctionFilterExpression } from "./IFunctionFilterExpression";
import { FilterExpressionCollection } from "./FilterExpressionCollection";
import { IPropertyReferenceFilterExpression } from "./IPropertyReferenceFilterExpression";
import { ILiteralFilterExpression } from "./ILiteralFilterExpression";
/**
 * @hidden
 */
export declare abstract class FilterExpression extends Base implements IFilterExpression {
    static $t: Type;
    private ay;
    abstract readonly precedence: number;
    private az;
    markAutoGenerated(): void;
    readonly isAutoGenerated: boolean;
    static isFilterExpression(a: any): boolean;
    static isSchemaType(a: any): boolean;
    static operation(a: IFilterExpression | string, b: FilterExpressionOperatorType, c: IFilterExpression | any): OperationFilterExpression;
    static func(a: FilterExpressionFunctionType, ...b: IFilterExpression[]): FunctionFilterExpression;
    protected a5(): void;
    protected abstract a3(): boolean;
    static property(a: string): PropertyReferenceFilterExpression;
    static nullLiteral(): LiteralFilterExpression;
    static literal(a: any): LiteralFilterExpression;
    static unquotedLiteral(a: string): LiteralFilterExpression;
    match(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): boolean;
    a4(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): boolean;
    private a0;
    abstract evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
    protected get_isPropertyReference(): boolean;
    readonly isPropertyReference: boolean;
    protected get_isOperation(): boolean;
    readonly isOperation: boolean;
    protected get_isFunction(): boolean;
    readonly isFunction: boolean;
    protected get_isLiteral(): boolean;
    readonly isLiteral: boolean;
    protected get_isNull(): boolean;
    readonly isNull: boolean;
    group(): FilterExpression;
    and(a: IFilterExpression): FilterExpression;
    or(a: IFilterExpression): FilterExpression;
    not(): FilterExpression;
    add(a: IFilterExpression | any): FilterExpression;
    plus(a: IFilterExpression | any): FilterExpression;
    divide(a: IFilterExpression | any): FilterExpression;
    divideBy(a: IFilterExpression | any): FilterExpression;
    isEqualTo(a: IFilterExpression | any): FilterExpression;
    isGreaterThan(a: IFilterExpression | any): FilterExpression;
    isGreaterThanOrEqualTo(a: IFilterExpression | any): FilterExpression;
    isLessThan(a: IFilterExpression | any): FilterExpression;
    isLessThanOrEqualTo(a: IFilterExpression | any): FilterExpression;
    modulo(a: IFilterExpression | any): FilterExpression;
    multiply(a: IFilterExpression | any): FilterExpression;
    times(a: IFilterExpression | any): FilterExpression;
    isNotEqualTo(a: IFilterExpression | any): FilterExpression;
    subtract(a: IFilterExpression | any): FilterExpression;
    minus(a: IFilterExpression | any): FilterExpression;
    ceiling(): FilterExpression;
    concat(a: IFilterExpression | string): FilterExpression;
    contains(a: IFilterExpression | string): FilterExpression;
    day(): FilterExpression;
    endsWith(a: IFilterExpression | string): FilterExpression;
    floor(): FilterExpression;
    hour(): FilterExpression;
    indexOf(a: IFilterExpression | string): FilterExpression;
    length(): FilterExpression;
    minute(): FilterExpression;
    month(): FilterExpression;
    replace(a: IFilterExpression | string, b: IFilterExpression | string): FilterExpression;
    round(): FilterExpression;
    second(): FilterExpression;
    startsWith(a: IFilterExpression | string): FilterExpression;
    substring(a: IFilterExpression | number, b?: IFilterExpression | number): FilterExpression;
    toLower(): FilterExpression;
    toUpper(): FilterExpression;
    trim(): FilterExpression;
    year(): FilterExpression;
    date(): FilterExpression;
    time(): FilterExpression;
    now(): FilterExpression;
    isOf(a: IFilterExpression | string): FilterExpression;
    cast(a: IFilterExpression | DataSourceSchemaPropertyType | string): FilterExpression;
}
/**
 * @hidden
 */
export declare class OperationFilterExpression extends FilterExpression implements IOperationFilterExpression {
    static $t: Type;
    constructor(a: any, b: FilterExpressionOperatorType, c: any);
    private a7;
    private a9;
    private a8;
    private ba;
    private a6;
    protected get_isOperation(): boolean;
    protected a3(): boolean;
    readonly isComparisonOperation: boolean;
    propertyName: string;
    readonly hasPropertyName: boolean;
    value: any;
    readonly hasValue: boolean;
    left: IFilterExpression;
    readonly hasLeft: boolean;
    right: IFilterExpression;
    readonly hasRight: boolean;
    operator: FilterExpressionOperatorType;
    readonly hasOperator: boolean;
    protected readonly bg: boolean;
    protected get_precedence(): number;
    readonly precedence: number;
    evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
    private bj;
    private bk;
    private bi;
}
/**
 * @hidden
 */
export declare class FunctionFilterExpression extends FilterExpression implements IFunctionFilterExpression {
    static $t: Type;
    constructor(a: FilterExpressionFunctionType, ...b: IFilterExpression[]);
    private a7;
    private a6;
    protected get_isFunction(): boolean;
    protected a3(): boolean;
    functionType: FilterExpressionFunctionType;
    protected readonly a8: boolean;
    readonly functionArguments: FilterExpressionCollection;
    readonly hasFunctionArguments: boolean;
    evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
    protected get_precedence(): number;
    readonly precedence: number;
    private a9;
    private bb;
    private ba;
}
/**
 * @hidden
 */
export declare class PropertyReferenceFilterExpression extends FilterExpression implements IPropertyReferenceFilterExpression {
    static $t: Type;
    constructor(a: string);
    protected get_isPropertyReference(): boolean;
    protected get_precedence(): number;
    readonly precedence: number;
    protected a3(): boolean;
    private a6;
    propertyReference: string;
    evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
}
/**
 * @hidden
 */
export declare class LiteralFilterExpression extends FilterExpression implements ILiteralFilterExpression {
    static $t: Type;
    constructor(a: any, b: boolean);
    protected get_precedence(): number;
    readonly precedence: number;
    private a7;
    private a6;
    protected get_isLiteral(): boolean;
    protected get_isNull(): boolean;
    literalValue: any;
    leaveUnquoted: boolean;
    protected a3(): boolean;
    evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
}

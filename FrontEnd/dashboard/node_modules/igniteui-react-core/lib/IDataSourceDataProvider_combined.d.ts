import { ISupportsDataChangeNotifications } from "./ISupportsDataChangeNotifications";
import { IDataSourceSupportsCount } from "./IDataSourceSupportsCount";
import { IDataSourceSchema } from "./IDataSourceSchema";
import { IDataSourceExecutionContext } from "./IDataSourceExecutionContext";
import { IDataSourceDataProviderUpdateNotifier } from "./IDataSourceDataProviderUpdateNotifier";
import { SortDescriptionCollection } from "./SortDescriptionCollection";
import { DataSourceSummaryScope } from "./DataSourceSummaryScope";
import { Base, Type, IList$1 } from "./type";
import { DataSourceDataProviderSchemaChangedEventArgs } from "./DataSourceDataProviderSchemaChangedEventArgs";
import { DataSourceSchemaPropertyType } from "./DataSourceSchemaPropertyType";
import { SyncableObservableCollection$1 } from "./SyncableObservableCollection$1";
import { NotifyCollectionChangedEventArgs } from "./NotifyCollectionChangedEventArgs";
import { IDataSourceSupportsIndexedAccess } from "./IDataSourceSupportsIndexedAccess";
import { IDataSourceUpdateNotifier } from "./IDataSourceUpdateNotifier";
import { DataSourceSectionHeaderDisplayMode } from "./DataSourceSectionHeaderDisplayMode";
import { DataSourceSchemaChangedEventArgs } from "./DataSourceSchemaChangedEventArgs";
import { DataSourceRowExpansionChangedEventArgs } from "./DataSourceRowExpansionChangedEventArgs";
import { DataSourceRowType } from "./DataSourceRowType";
import { ISummaryResult } from "./ISummaryResult";
import { SummaryOperand } from "./SummaryOperand";
/**
 * @hidden
 */
export interface IDataSourceDataProvider extends ISupportsDataChangeNotifications, IDataSourceSupportsCount {
    getItemValue(a: any, b: string): any;
    setItemValue(a: any, b: string, c: any): void;
    removeItem(a: any): void;
    addItem(a: any): void;
    schemaChanged: (sender: any, args: DataSourceDataProviderSchemaChangedEventArgs) => void;
    readonly actualSchema: IDataSourceSchema;
    executionContext: IDataSourceExecutionContext;
    updateNotifier: IDataSourceDataProviderUpdateNotifier;
    queueAutoRefresh(): void;
    deferAutoRefresh: boolean;
    flushAutoRefresh(): void;
    refresh(): void;
    readonly isSortingSupported: boolean;
    readonly isGroupingSupported: boolean;
    readonly sortDescriptions: SortDescriptionCollection;
    readonly groupDescriptions: SortDescriptionCollection;
    readonly summaryDescriptions: SummaryDescriptionCollection;
    summaryScope: DataSourceSummaryScope;
    readonly isFilteringSupported: boolean;
    readonly filterExpressions: FilterExpressionCollection;
    propertiesRequested: string[];
    readonly notifyUsingSourceIndexes: boolean;
    indexOfItem(a: any): number;
    indexOfKey(a: any[]): number;
    readonly isItemIndexLookupSupported: boolean;
    readonly isKeyIndexLookupSupported: boolean;
    resolveSchemaPropertyType(a: string): DataSourceSchemaPropertyType;
}
/**
 * @hidden
 */
export declare let IDataSourceDataProvider_$type: Type;
/**
 * @hidden
 */
export interface IFilterExpression {
    evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
    readonly isPropertyReference: boolean;
    readonly isOperation: boolean;
    readonly isFunction: boolean;
    readonly isLiteral: boolean;
    readonly isNull: boolean;
    match(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): boolean;
    readonly precedence: number;
    readonly isAutoGenerated: boolean;
    markAutoGenerated(): void;
}
/**
 * @hidden
 */
export declare let IFilterExpression_$type: Type;
/**
 * @hidden
 */
export declare class FilterExpressionCollection extends Base {
    static $t: Type;
    private a;
    syncTarget: FilterExpressionCollection;
    private f;
    constructor();
    add(a: IFilterExpression): boolean;
    insert(a: number, b: IFilterExpression): void;
    clear(): void;
    get(a: number): IFilterExpression;
    indexOf(a: IFilterExpression): number;
    remove(a: IFilterExpression): boolean;
    removeAt(a: number): IFilterExpression;
    set(a: number, b: IFilterExpression): IFilterExpression;
    size(): number;
    onChanged: () => void;
    m(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    p(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    readonly j: IList$1<IFilterExpression>;
}
/**
 * @hidden
 */
export interface IDataSource extends ISupportsDataChangeNotifications, IDataSourceSupportsIndexedAccess {
    schemaChanged: (sender: any, args: DataSourceSchemaChangedEventArgs) => void;
    rowExpansionChanged: (sender: any, args: DataSourceRowExpansionChangedEventArgs) => void;
    isPlaceholderItem(a: number): boolean;
    getItemPropertyAtIndex(a: number, b: string): any;
    getItemProperty(a: any, b: string): any;
    updateNotifier: IDataSourceUpdateNotifier;
    readonly executionContext: IDataSourceExecutionContext;
    readonly actualSchema: IDataSourceSchema;
    firstVisibleIndexRequested: number;
    lastVisibleIndexRequested: number;
    readonly isVirtual: boolean;
    readonly isSortingSupported: boolean;
    readonly sortDescriptions: SortDescriptionCollection;
    readonly groupDescriptions: SortDescriptionCollection;
    readonly summaryDescriptions: SummaryDescriptionCollection;
    summaryScope: DataSourceSummaryScope;
    readonly isFilteringSupported: boolean;
    readonly notifyUsingSourceIndexes: boolean;
    readonly filterExpressions: FilterExpressionCollection;
    queueAutoRefresh(): void;
    deferAutoRefresh: boolean;
    flushAutoRefresh(): void;
    refresh(): void;
    primaryKey: string[];
    readonly actualPrimaryKey: string[];
    propertiesRequested: string[];
    indexOfItem(a: any): number;
    indexOfKey(a: any[]): number;
    readonly isItemIndexLookupSupported: boolean;
    readonly isKeyIndexLookupSupported: boolean;
    readonly isGroupingSupported: boolean;
    sectionHeaderDisplayMode: DataSourceSectionHeaderDisplayMode;
    isSectionCollapsable: boolean;
    isSectionExpandedDefault: boolean;
    includeSummaryRowsInSection: boolean;
    isSectionSummaryRowsAtBottom: boolean;
    isSectionHeaderNormalRow: boolean;
    isSectionContentVisible: boolean;
    getRowType(a: number): DataSourceRowType;
    getMainValuePath(a: DataSourceRowType): string;
    getStickyRows(): number[];
    getStickyRowsInRange(a: number, b: number): number[];
    getStickyRowPriority(a: number): number;
    isExclusivelySticky(a: number): boolean;
    isRowSpanning(a: DataSourceRowType): boolean;
    pinRow(a: any[]): void;
    unpinRow(a: any[]): void;
    clearPinnedRows(): void;
    isRowPinned(a: number): boolean;
    shouldEmitSectionHeaders: boolean;
    shouldEmitSectionFooters: boolean;
    shouldEmitShiftedRows: boolean;
    resolveSchemaPropertyType(a: string): DataSourceSchemaPropertyType;
    setIsRowExpandedAtIndex(a: number, b: boolean): void;
    getIsRowExpandedAtIndex(a: number): boolean;
    getRowLevel(a: number): number;
    getRootSummaryRowCount(): number;
    getRootSummaryResults(): ISummaryResult[];
    getSectionSummaryResults(a: number): ISummaryResult[][];
    clone(): IDataSource;
}
/**
 * @hidden
 */
export declare let IDataSource_$type: Type;
/**
 * @hidden
 */
export declare abstract class SummaryCalculator extends Base {
    static $t: Type;
    private _propertyName;
    propertyName: string;
    private _propertyType;
    propertyType: DataSourceSchemaPropertyType;
    private _dataSource;
    dataSource: IDataSource;
    abstract readonly displayName: string;
    private _isSummaryDirty;
    isSummaryDirty: boolean;
    private f;
    protected get_operand(): SummaryOperand;
    readonly operand: SummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
    protected i(a: any): number;
    protected j(a: any): number;
    protected k(a: number): any;
}
/**
 * @hidden
 */
export declare class SumSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): SummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
}
/**
 * @hidden
 */
export declare class CountSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): SummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
}
/**
 * @hidden
 */
export declare class AverageSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    private q;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): SummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
}
/**
 * @hidden
 */
export declare class MaxSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): SummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
    private q;
}
/**
 * @hidden
 */
export declare class MinSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): SummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
    private q;
}
/**
 * @hidden
 */
export declare class SummaryDescription extends Base {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, b: string, c: SummaryOperand);
    constructor(a: number, ..._rest: any[]);
    private k;
    propertyName: string;
    private f;
    operand: SummaryOperand;
    private b;
    calculator: SummaryCalculator;
    equals(a: any): boolean;
    getHashCode(): number;
    m(): void;
    provideCalculator: (sender: any, args: ProvideCalculatorEventArgs) => void;
    private e;
    d(): SummaryCalculator;
}
/**
 * @hidden
 */
export declare class SummaryDescriptionCollection extends Base {
    static $t: Type;
    g(): SyncableObservableCollection$1<SummaryDescription>;
    private d;
    syncTarget: SummaryDescriptionCollection;
    private f;
    constructor();
    add(a: SummaryDescription): boolean;
    insert(a: number, b: SummaryDescription): void;
    clear(): void;
    get(a: number): SummaryDescription;
    indexOf(a: SummaryDescription): number;
    remove(a: SummaryDescription): boolean;
    removeAt(a: number): SummaryDescription;
    set(a: number, b: SummaryDescription): SummaryDescription;
    size(): number;
    n(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    q(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    onChanged: () => void;
    readonly k: IList$1<SummaryDescription>;
}
/**
 * @hidden
 */
export declare class ProvideCalculatorEventArgs extends Base {
    static $t: Type;
    a: SummaryCalculator;
}

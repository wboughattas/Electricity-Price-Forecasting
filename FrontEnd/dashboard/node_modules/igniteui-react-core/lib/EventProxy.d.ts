import { Base, Point, Type } from "./type";
import { Rect } from "./Rect";
import { ModifierKeys } from "./ModifierKeys";
import { NormalizedEvent, DomWrapper } from "./dom";
import { Key } from "./Key";
/**
 * @hidden
 */
export declare abstract class EventProxy extends Base {
    static $t: Type;
    onMouseWheel: (point: Point, delta: number) => boolean;
    onMouseWheelHorizontal: (point: Point, delta: number) => boolean;
    onPinchStarted: (point: Point, scale: number) => void;
    onPinchDelta: (point: Point, scale: number) => void;
    onGestureCompleted: (point: Point, scale: number) => void;
    onZoomStarted: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onZoomDelta: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onZoomCompleted: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onFlingStarted: (point: Point, velocityX: number, velocityY: number) => boolean;
    onContactStarted: (point: Point, isFinger: boolean) => void;
    onDragStarted: (point: Point) => void;
    onContactMoved: (point: Point, isFinger: boolean) => void;
    onDragDelta: (point: Point) => void;
    onContactCompleted: (point: Point, isFinger: boolean) => void;
    onDragCompleted: (point: Point) => void;
    onMouseLeave: (point: Point) => void;
    onMouseOver: (point: Point, onMouseMove: boolean, isFinger: boolean) => void;
    onMouseEnter: (point: Point) => void;
    onMouseDown: (point: Point) => void;
    onMouseUp: (point: Point) => void;
    onDoubleTap: (point: Point) => void;
    onHold: (point: Point) => void;
    onKeyDown: (key: Key) => boolean;
    onKeyUp: (key: Key) => boolean;
    abstract be(a: DomWrapper): Rect;
    bf: Rect;
    bc: ModifierKeys;
    ai: boolean;
    ak: (arg1: Point) => boolean;
    am: (arg1: Point, arg2: boolean, arg3: boolean) => boolean;
    protected ab(a: Point, b: boolean, c: boolean): boolean;
    an: (arg1: NormalizedEvent) => boolean;
    abstract d(): EventProxy;
    abstract aq(): void;
    protected get_aj(): boolean;
    readonly aj: boolean;
    ao: any;
    protected ag(a: Point, b: number): boolean;
    protected ah(a: Point, b: number): boolean;
    protected a7(a: Point, b: number): void;
    protected ba(a: Point, b: number, c: number, d: number): void;
    protected ad(a: Point, b: number, c: number): boolean;
    protected a6(a: Point, b: number): void;
    protected a9(a: Point, b: number, c: number, d: number): void;
    protected a8(a: Point, b: number, c: number, d: number): void;
    protected az(a: Point, b: number): void;
    protected au(a: Point, b: boolean): void;
    protected ay(a: Point): void;
    protected at(a: Point, b: boolean): void;
    protected ax(a: Point): void;
    protected as(a: Point, b: boolean): void;
    protected aw(a: Point): void;
    protected a3(a: Point): void;
    protected a4(a: Point, b: boolean, c: boolean): void;
    protected a2(a: Point): void;
    protected a1(a: Point): void;
    protected a5(a: Point): void;
    protected ae(a: Key): boolean;
    protected af(a: Key): boolean;
    protected av(a: Point): void;
    protected a0(a: Point): void;
    abstract bd(): Point;
    private z;
    ac: boolean;
    aa: boolean;
    al: (arg1: Point) => boolean;
    protected ar(): void;
    abstract ap(a: any, b: string): void;
    abstract bb(a: any, b: string): void;
}

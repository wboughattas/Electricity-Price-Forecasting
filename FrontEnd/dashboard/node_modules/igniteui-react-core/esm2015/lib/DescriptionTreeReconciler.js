/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, String_$type, markType } from "./type";
import { DiffApplyInfo } from "./DiffApplyInfo";
import { DescriptionTreeNode } from "./DescriptionTreeNode";
import { List$1 } from "./List$1";
import { DescriptionTreeAction } from "./DescriptionTreeAction";
import { DescriptionPropertyValue } from "./DescriptionPropertyValue";
import { Dictionary$2 } from "./Dictionary$2";
import { DescriptionTreeReconciler_TreeModeData } from "./DescriptionTreeReconciler_TreeModeData";
/**
 * @hidden
 */
export let DescriptionTreeReconciler = /*@__PURE__*/ (() => {
    class DescriptionTreeReconciler extends Base {
        static a(a, b) {
            let c = new DiffApplyInfo();
            for (let d = 0; d < b.count; d++) {
                let e = b._inner[d];
                switch (e.a) {
                    case 0:
                        if (typeCast(DescriptionTreeNode.$, e.g) !== null) {
                            let f = e.g.f;
                            c.a.add_1(f);
                        }
                        e.b.l(e.i, e.f);
                        if (typeCast(DescriptionTreeNode.$, e.f) !== null) {
                            let g = e.f.f;
                            if (c.a.contains(g)) {
                                c.a.remove(g);
                            }
                            c.c.add(e);
                        }
                        break;
                    case 1:
                        if (typeCast(DescriptionTreeNode.$, e.g) !== null) {
                            let h = e.g.f;
                            c.a.add_1(h);
                        }
                        e.b.k(e.i);
                        break;
                    case 3:
                        {
                            let i = e.b.a(e.i).b;
                            let j = i[e.e];
                            if (typeCast(DescriptionTreeNode.$, j) !== null) {
                                let k = j.f;
                                c.a.add_1(k);
                            }
                            i[e.e] = e.f;
                            if (typeCast(DescriptionTreeNode.$, e.f) !== null) {
                                let l = e.f.f;
                                if (c.a.contains(l)) {
                                    c.a.remove(l);
                                }
                                c.b.add(e);
                            }
                        }
                        break;
                    case 4:
                        {
                            let m = e.b.a(e.i).b;
                            let n = m[e.e];
                            if (typeCast(DescriptionTreeNode.$, n) !== null) {
                                let o = n.f;
                                c.a.add_1(o);
                            }
                            let p = new Array(m.length - 1);
                            let q = 0;
                            for (let r = 0; r < m.length; r++) {
                                if (r != e.e) {
                                    p[q] = m[r];
                                    q++;
                                }
                            }
                            e.b.l(e.i, p);
                        }
                        break;
                    case 2:
                        {
                            let s = e.b.a(e.i).b;
                            let t = new Array(s.length + 1);
                            let u = 0;
                            for (let v = 0; v < t.length; v++) {
                                if (v == e.d) {
                                    t[v] = e.f;
                                }
                                else {
                                    t[v] = s[u];
                                    u++;
                                }
                            }
                            e.b.l(e.i, t);
                            if (typeCast(DescriptionTreeNode.$, e.f) !== null) {
                                let w = e.f.f;
                                if (c.a.contains(w)) {
                                    c.a.remove(w);
                                }
                                c.b.add(e);
                            }
                        }
                        break;
                    case 5:
                        {
                            let x = e.b.a(e.i).b;
                            for (let y = 0; y < x.length; y++) {
                                let z = x[y];
                                if (typeCast(DescriptionTreeNode.$, z) !== null) {
                                    let aa = z.f;
                                    c.a.add_1(aa);
                                }
                            }
                            e.b.l(e.i, []);
                        }
                        break;
                }
            }
            return c;
        }
        static c(a, b, c) {
            let d = new List$1(DescriptionTreeAction.$, 0);
            if (a == null && b == null) {
                return d;
            }
            if (a != null && b == null) {
                let e = new DescriptionTreeAction();
                e.a = 4;
                e.e = 0;
                e.g = a;
                e.c = null;
                e.i = null;
                d.add(e);
                return d;
            }
            if (a == null && b != null) {
                let f = new DescriptionTreeAction();
                f.a = 2;
                f.e = 0;
                f.f = b;
                f.c = null;
                f.i = null;
                d.add(f);
                return d;
            }
            if (b.h != a.h) {
                let g = new DescriptionTreeAction();
                g.a = 3;
                g.e = 0;
                g.g = a;
                g.f = b;
                g.c = null;
                g.i = null;
                d.add(g);
                return d;
            }
            DescriptionTreeReconciler.g(d, a, b, c);
            return d;
        }
        static g(a, b, c, d) {
            c.f = b.f;
            let e = DescriptionTreeReconciler.e(b);
            let f = DescriptionTreeReconciler.e(c);
            let g = new List$1(DescriptionPropertyValue.$, 0);
            let h = new List$1(DescriptionPropertyValue.$, 0);
            let i = new List$1(DescriptionPropertyValue.$, 0);
            for (let j = 0; j < e.count; j++) {
                let k = e._inner[j];
                if (c.b(k.c)) {
                    if (!Base.equalsStatic(k, c.a(k.c))) {
                        let l = c.a(k.c);
                        if (typeCast(DescriptionTreeNode.$, k.b) !== null && typeCast(DescriptionTreeNode.$, l.b) !== null) {
                            let m = k.b;
                            let n = l.b;
                            if (m.h == n.h) {
                                if ((!m.b("Name") && !n.b("Name")) || (m.b("Name") && n.b("Name") && (m.a("Name").b == n.a("Name").b))) {
                                    DescriptionTreeReconciler.g(a, m, n, d);
                                }
                                else {
                                    i.add(c.a(k.c));
                                }
                            }
                            else {
                                i.add(c.a(k.c));
                            }
                        }
                        else {
                            i.add(c.a(k.c));
                        }
                    }
                }
                else {
                    if (!d) {
                        g.add(k);
                    }
                }
            }
            for (let o = 0; o < f.count; o++) {
                let p = f._inner[o];
                if (!b.b(p.c)) {
                    h.add(p);
                }
            }
            for (let q = 0; q < g.count; q++) {
                let r = g._inner[q];
                let s = new DescriptionTreeAction();
                s.b = b;
                s.a = 1;
                s.i = r.c;
                s.c = r.a;
                s.g = r.b;
                a.add(s);
            }
            for (let t = 0; t < h.count; t++) {
                let u = h._inner[t];
                let v = new DescriptionTreeAction();
                v.b = b;
                v.a = 0;
                v.i = u.c;
                v.c = u.a;
                v.f = u.b;
                v.g = null;
                a.add(v);
            }
            for (let w = 0; w < i.count; w++) {
                let x = i._inner[w];
                let y = b.a(x.c).b;
                let z = x.b;
                if (!Base.equalsStatic(z, y)) {
                    let aa = new DescriptionTreeAction();
                    aa.b = b;
                    aa.a = 0;
                    aa.i = x.c;
                    aa.c = x.a;
                    aa.f = x.b;
                    aa.g = b.a(x.c).b;
                    a.add(aa);
                }
            }
            let ab = DescriptionTreeReconciler.d(b);
            let ac = DescriptionTreeReconciler.d(c);
            let ad = new List$1(DescriptionPropertyValue.$, 0);
            let ae = new List$1(DescriptionPropertyValue.$, 0);
            let af = new List$1(DescriptionPropertyValue.$, 0);
            for (let ag = 0; ag < ab.count; ag++) {
                let ah = ab._inner[ag];
                if (c.b(ah.c)) {
                    if (!DescriptionTreeReconciler.b(ah.b, c.a(ah.c).b)) {
                        af.add(c.a(ah.c));
                    }
                    else {
                        let ai = ah.b;
                        let aj = c.a(ah.c).b;
                        for (let ak = 0; ak < ai.length; ak++) {
                            let al = ai[ak];
                            let am = aj[ak];
                            if (typeCast(DescriptionTreeNode.$, al) !== null && typeCast(DescriptionTreeNode.$, am) !== null) {
                                let an = al;
                                let ao = am;
                                if (an.h == ao.h) {
                                    DescriptionTreeReconciler.g(a, an, ao, d);
                                }
                                else {
                                    let ap = new DescriptionTreeAction();
                                    ap.i = ah.c;
                                    ap.c = ah.a;
                                    ap.b = b;
                                    ap.a = 3;
                                    ap.e = ak;
                                    ap.d = ak;
                                    ap.g = an;
                                    ap.f = ao;
                                    a.add(ap);
                                }
                            }
                            else {
                                if (!Base.equalsStatic(al, am)) {
                                    let aq = new DescriptionTreeAction();
                                    aq.i = ah.c;
                                    aq.c = ah.a;
                                    aq.b = b;
                                    aq.a = 3;
                                    aq.e = ak;
                                    aq.d = ak;
                                    aq.g = al;
                                    aq.f = am;
                                    a.add(aq);
                                }
                            }
                        }
                    }
                }
                else {
                    if (!d) {
                        ad.add(ah);
                    }
                }
            }
            for (let ar = 0; ar < ac.count; ar++) {
                let as = ac._inner[ar];
                if (!b.b(as.c)) {
                    ae.add(as);
                }
            }
            for (let at = 0; at < ad.count; at++) {
                let au = ad._inner[at];
                let av = new DescriptionTreeAction();
                av.b = b;
                av.i = au.c;
                av.c = au.a;
                av.a = 5;
                av.g = au.b;
                a.add(av);
            }
            for (let aw = 0; aw < ae.count; aw++) {
                let ax = ae._inner[aw];
                let ay = new DescriptionTreeAction();
                ay.b = b;
                ay.i = ax.c;
                ay.c = ax.a;
                ay.a = 0;
                ay.g = null;
                ay.f = ax.b;
                a.add(ay);
            }
            for (let az = 0; az < af.count; az++) {
                DescriptionTreeReconciler.h(a, b, c, b.a(af._inner[az].c), af._inner[az], d);
            }
        }
        static f(a) {
            if (a == null) {
                return "UNKOWN";
            }
            if (!a.b("Type")) {
                return "UNKOWN";
            }
            return a.a("Type").b;
        }
        static h(a, b, c, d, e, f) {
            let g = false;
            let h = d.b;
            let i = e.b;
            if (h.length > 0) {
                if (typeCast(DescriptionTreeNode.$, h[0]) !== null) {
                    let j = h[0];
                    if (j.b("Name") && j.a("Name") != null) {
                        g = true;
                    }
                    if (j.b("RefType") && j.a("RefType").b == "uuid") {
                        g = true;
                    }
                }
            }
            if (i.length > 0) {
                if (typeCast(DescriptionTreeNode.$, i[0]) !== null) {
                    let k = i[0];
                    if (k.b("Name") && k.a("Name") != null) {
                        g = true;
                    }
                    if (k.b("RefType") && k.a("RefType").b == "uuid") {
                        g = true;
                    }
                }
            }
            if (g) {
                let l = new Dictionary$2(String_$type, DescriptionTreeReconciler_TreeModeData.$, 0);
                let m = new List$1(DescriptionTreeReconciler_TreeModeData.$, 0);
                let n = new Dictionary$2(String_$type, DescriptionTreeReconciler_TreeModeData.$, 0);
                let o = new List$1(DescriptionTreeReconciler_TreeModeData.$, 0);
                let p = 0;
                for (let q = 0; q < h.length; q++) {
                    let r = new DescriptionTreeReconciler_TreeModeData();
                    r.a = h[q];
                    r.d = q;
                    r.f = r.a.b("Name") ? r.a.a("Name").b : r.a.b("RefType") ? r.a.a("Value").b : null;
                    if (r.f == null) {
                        r.f = "BADKEY_" + p.toString();
                        p++;
                    }
                    m.add(r);
                    l.addItem(r.f, r);
                }
                for (let s = 0; s < i.length; s++) {
                    let t = new DescriptionTreeReconciler_TreeModeData();
                    t.a = i[s];
                    t.d = s;
                    t.f = t.a.b("Name") ? t.a.a("Name").b : t.a.b("RefType") ? t.a.a("Value").b : null;
                    if (t.f == null) {
                        t.f = "BADKEY_" + p.toString();
                        p++;
                    }
                    o.add(t);
                    n.addItem(t.f, t);
                }
                for (let u = 0; u < m.count; u++) {
                    let v = m._inner[u];
                    if (!n.containsKey(v.f) || (n.containsKey(v.f) && DescriptionTreeReconciler.f(v.a) != DescriptionTreeReconciler.f(n.item(v.f).a))) {
                        v.c = true;
                    }
                }
                for (let w = 0; w < o.count; w++) {
                    let x = o._inner[w];
                    if (!l.containsKey(x.f) || (l.containsKey(x.f) && DescriptionTreeReconciler.f(x.a) != DescriptionTreeReconciler.f(l.item(x.f).a))) {
                        x.b = true;
                    }
                    else {
                        l.item(x.f).e = w;
                    }
                }
                for (let y = 0; y < m.count; y++) {
                    let z = m._inner[y];
                    if (z.c) {
                        let aa = new DescriptionTreeAction();
                        aa.i = e.c;
                        aa.b = b;
                        aa.c = e.a;
                        aa.e = z.d;
                        aa.a = 4;
                        aa.g = z.a;
                        a.add(aa);
                        for (let ab = y + 1; ab < m.count; ab++) {
                            let ac = m._inner[ab];
                            ac.d--;
                        }
                    }
                }
                for (let ad = 0; ad < o.count; ad++) {
                    let ae = o._inner[ad];
                    if (ae.b) {
                        let af = new DescriptionTreeAction();
                        af.i = e.c;
                        af.b = b;
                        af.c = e.a;
                        af.d = ad;
                        af.a = 2;
                        af.f = i[ad];
                        a.add(af);
                        for (let ag = 0; ag < m.count; ag++) {
                            let ah = m._inner[ag];
                            if (!ah.c && ah.d >= ad) {
                                ah.d++;
                            }
                        }
                    }
                    else {
                        let ai = l.item(ae.f);
                        if (ai.d == ai.e) {
                            DescriptionTreeReconciler.g(a, ai.a, ae.a, f);
                            continue;
                        }
                        let aj = new DescriptionTreeAction();
                        aj.i = e.c;
                        aj.b = b;
                        aj.c = e.a;
                        aj.e = ai.d;
                        aj.a = 4;
                        aj.g = ai.a;
                        a.add(aj);
                        for (let ak = 0; ak < m.count; ak++) {
                            let al = m._inner[ak];
                            if (!al.c && al.a != ai.a && al.d >= ai.d) {
                                al.d--;
                            }
                        }
                        aj = new DescriptionTreeAction();
                        aj.i = e.c;
                        aj.b = b;
                        aj.c = e.a;
                        aj.d = ai.e;
                        aj.a = 2;
                        aj.f = ai.a;
                        a.add(aj);
                        ai.d = ai.e;
                        for (let am = 0; am < m.count; am++) {
                            let an = m._inner[am];
                            if (!an.c && an.a != ai.a && an.d >= ai.d) {
                                an.d++;
                            }
                        }
                        DescriptionTreeReconciler.g(a, ai.a, ae.a, f);
                    }
                }
            }
            else {
                let ao = Math.max(h.length, i.length);
                for (let ap = 0; ap < ao; ap++) {
                    if (ap >= h.length) {
                        let aq = new DescriptionTreeAction();
                        aq.i = e.c;
                        aq.b = b;
                        aq.c = e.a;
                        aq.d = ap;
                        aq.a = 2;
                        aq.f = i[ap];
                        a.add(aq);
                    }
                    else if (ap >= i.length) {
                        let ar = new DescriptionTreeAction();
                        ar.i = e.c;
                        ar.b = b;
                        ar.c = e.a;
                        ar.e = i.length;
                        ar.a = 4;
                        ar.g = h[ap];
                        a.add(ar);
                    }
                    else {
                        let as = h[ap];
                        let at = i[ap];
                        if (typeCast(DescriptionTreeNode.$, as) !== null && typeCast(DescriptionTreeNode.$, at) !== null) {
                            let au = as;
                            let av = at;
                            if (au.h == av.h) {
                                DescriptionTreeReconciler.g(a, au, av, f);
                            }
                            else {
                                let aw = new DescriptionTreeAction();
                                aw.i = e.c;
                                aw.b = b;
                                aw.c = e.a;
                                aw.e = ap;
                                aw.a = 3;
                                aw.g = h[ap];
                                aw.f = i[ap];
                                a.add(aw);
                            }
                        }
                        else {
                            if (!Base.equalsStatic(as, at)) {
                                let ax = new DescriptionTreeAction();
                                ax.i = e.c;
                                ax.b = b;
                                ax.c = e.a;
                                ax.e = ap;
                                ax.a = 3;
                                ax.g = h[ap];
                                ax.f = i[ap];
                                a.add(ax);
                            }
                        }
                    }
                }
            }
        }
        static b(a, b) {
            let c = a;
            let d = b;
            if (c.length != d.length) {
                return false;
            }
            for (let e = 0; e < c.length; e++) {
                let f = c[e];
                let g = d[e];
                if (typeCast(DescriptionTreeNode.$, f) !== null && !(typeCast(DescriptionTreeNode.$, g) !== null)) {
                    return false;
                }
                if (!(typeCast(DescriptionTreeNode.$, f) !== null) && typeCast(DescriptionTreeNode.$, g) !== null) {
                    return false;
                }
                if (typeCast(DescriptionTreeNode.$, f) !== null) {
                    let h = f;
                    let i = g;
                    if (h.h != i.h) {
                        return false;
                    }
                    let j = h.b("Name") ? h.a("Name").b : null;
                    let k = i.b("Name") ? i.a("Name").b : null;
                    if (!Base.equalsStatic(j, k)) {
                        return false;
                    }
                }
                else {
                    if (!Base.equalsStatic(f, g)) {
                        return false;
                    }
                }
            }
            return true;
        }
        static e(a) {
            let b = new List$1(DescriptionPropertyValue.$, 0);
            let c = a.e();
            for (let d = 0; d < c.count; d++) {
                let e = c._inner[d];
                if (e.a != null && e.a.knownType != 10 && e.a.knownType != 9) {
                    b.add(e);
                }
            }
            return b;
        }
        static d(a) {
            let b = new List$1(DescriptionPropertyValue.$, 0);
            let c = a.e();
            for (let d = 0; d < c.count; d++) {
                let e = c._inner[d];
                if (e.a != null && (e.a.knownType == 10 || e.a.knownType == 9)) {
                    b.add(e);
                }
            }
            return b;
        }
    }
    DescriptionTreeReconciler.$t = /*@__PURE__*/ markType(DescriptionTreeReconciler, 'DescriptionTreeReconciler');
    return DescriptionTreeReconciler;
})();
//# sourceMappingURL=DescriptionTreeReconciler.js.map

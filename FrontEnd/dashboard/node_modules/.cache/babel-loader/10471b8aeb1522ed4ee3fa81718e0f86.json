{"ast":null,"code":"/*\r\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\r\nhttps://www.infragistics.com/legal/license/igultimate-la\r\nhttps://www.infragistics.com/legal/license/igultimate-eula\r\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\r\n*/\nimport * as tslib_1 from \"tslib\";\nimport { XNode } from \"./XNode\";\nimport { XName } from \"./XName\";\nimport { XmlUtils } from \"./XmlUtils\";\nimport { typeCast, markType } from \"./type\";\nimport { List$1 } from \"./List$1\";\nimport { XAttribute } from \"./XAttribute\";\n/**\r\n * @hidden\r\n */\n\nvar XContainer =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(XContainer, _super);\n\n  function XContainer(a) {\n    return _super.call(this, a) || this;\n  }\n\n  XContainer.prototype.element = function (a) {\n    var b = null;\n    var c = this.backingNode;\n    var d = c.childNodes;\n    var e = d.length;\n    var f = a.localName;\n    var g = a.namespaceName;\n\n    for (var h = 0; h < e; h++) {\n      var i = d.item(h);\n\n      if (i.namespaceURI == g && i.nodeType == 1 && XmlUtils.d(i) == f) {\n        b = i;\n      }\n    }\n\n    if (b == null) {\n      return null;\n    } else {\n      return new XElement(0, b);\n    }\n  };\n\n  XContainer.prototype.elements = function () {\n    return this.f(null);\n  };\n\n  XContainer.prototype.elements1 = function (a) {\n    return this.f(a);\n  };\n\n  XContainer.prototype.f = function (a) {\n    var b = new List$1(XElement.$, 0);\n\n    for (var c = 0; c < this.backingNode.childNodes.length; c++) {\n      var d = this.backingNode.childNodes.item(c);\n\n      if (d.nodeType == 1) {\n        var e = false;\n\n        if (a != null) {\n          if (XmlUtils.d(d) == a.localName && d.namespaceURI == a.namespaceName) {\n            e = true;\n          }\n        } else {\n          e = true;\n        }\n\n        if (e) {\n          b.add(new XElement(0, d));\n        }\n      }\n    }\n\n    return b;\n  };\n\n  XContainer.prototype.add = function (a) {\n    var b = this.backingNode;\n    var c;\n\n    if (typeCast(XDocument.$, this) !== null) {\n      c = this.backingNode;\n    } else {\n      c = this.backingNode.ownerDocument;\n    }\n\n    if (typeCast(XAttribute.$, a) !== null) {\n      a.e(b);\n    } else if (typeCast(XElement.$, a) !== null) {\n      a.j(b, c);\n    }\n  };\n\n  XContainer.$t = markType(XContainer, 'XContainer', XNode.$);\n  return XContainer;\n}(XNode);\n\nexport { XContainer };\n/**\r\n * @hidden\r\n */\n\nvar XDocument =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(XDocument, _super);\n\n  function XDocument(a) {\n    var _rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      _rest[_i - 1] = arguments[_i];\n    }\n\n    var _this = this;\n\n    a = a == void 0 ? 0 : a;\n\n    switch (a) {\n      case 0:\n        {\n          var c = _rest[0];\n          _this = _super.call(this, c) || this;\n        }\n        break;\n\n      case 1:\n        {\n          _this = _super.call(this, XmlUtils.j()) || this;\n        }\n        break;\n    }\n\n    return _this;\n  }\n\n  XDocument.prototype.get_nodeType = function () {\n    return 9;\n  };\n\n  Object.defineProperty(XDocument.prototype, \"nodeType\", {\n    get: function () {\n      return this.get_nodeType();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  XDocument.parse = function (a) {\n    return new XDocument(0, XmlUtils.n(a));\n  };\n\n  XDocument.$t = markType(XDocument, 'XDocument', XContainer.$);\n  return XDocument;\n}(XContainer);\n\nexport { XDocument };\n/**\r\n * @hidden\r\n */\n\nvar XElement =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(XElement, _super);\n\n  function XElement(a) {\n    var _rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      _rest[_i - 1] = arguments[_i];\n    }\n\n    var _this = this;\n\n    a = a == void 0 ? 0 : a;\n\n    switch (a) {\n      case 0:\n        {\n          var c = _rest[0];\n          _this = _super.call(this, c) || this;\n        }\n        break;\n\n      case 1:\n        {\n          var c = _rest[0];\n          var d = [c, null];\n          {\n            var f = d[0];\n            var g = d[1];\n            _this = _super.call(this, XmlUtils.o(f.localName, f.namespaceName)) || this;\n            var h = g == null ? \"\" : g.toString();\n            _this.value = h;\n          }\n        }\n        break;\n\n      case 2:\n        {\n          var c = _rest[0];\n          var d = _rest[1];\n          _this = _super.call(this, XmlUtils.o(c.localName, c.namespaceName)) || this;\n          var e = d == null ? \"\" : d.toString();\n          _this.value = e;\n        }\n        break;\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(XElement.prototype, \"value\", {\n    get: function () {\n      return XmlUtils.c(this.backingNode);\n    },\n    set: function (a) {\n      XmlUtils.h(this.backingNode, a);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  XElement.prototype.get_nodeType = function () {\n    return 1;\n  };\n\n  Object.defineProperty(XElement.prototype, \"nodeType\", {\n    get: function () {\n      return this.get_nodeType();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XElement.prototype, \"name\", {\n    get: function () {\n      return XName.get(XmlUtils.d(this.backingNode), this.backingNode.namespaceURI);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  XElement.prototype.attribute = function (a) {\n    return new XAttribute(XmlUtils.i(this.backingNode, a.localName, a.namespaceName));\n  };\n\n  XElement.prototype.j = function (a, b) {\n    if (this.backingNode.ownerDocument != b) {\n      this.backingNode = XmlUtils.p(b, this.backingNode);\n    }\n\n    a.appendChild(this.backingNode);\n  };\n\n  XElement.$t = markType(XElement, 'XElement', XContainer.$);\n  return XElement;\n}(XContainer);\n\nexport { XElement };","map":{"version":3,"sources":["../../../../src/igniteui-core/lib/XContainer_combined.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\r\nhttps://www.infragistics.com/legal/license/igultimate-la\r\nhttps://www.infragistics.com/legal/license/igultimate-eula\r\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\r\n*/\r\nimport * as tslib_1 from \"tslib\";\r\nimport { XNode } from \"./XNode\";\r\nimport { XName } from \"./XName\";\r\nimport { XmlUtils } from \"./XmlUtils\";\r\nimport { typeCast, markType } from \"./type\";\r\nimport { List$1 } from \"./List$1\";\r\nimport { XAttribute } from \"./XAttribute\";\r\n/**\r\n * @hidden\r\n */\r\nvar XContainer = /** @class */ /*@__PURE__*/ (function (_super) {\r\n    tslib_1.__extends(XContainer, _super);\r\n    function XContainer(a) {\r\n        return _super.call(this, a) || this;\r\n    }\r\n    XContainer.prototype.element = function (a) {\r\n        var b = null;\r\n        var c = this.backingNode;\r\n        var d = c.childNodes;\r\n        var e = d.length;\r\n        var f = a.localName;\r\n        var g = a.namespaceName;\r\n        for (var h = 0; h < e; h++) {\r\n            var i = d.item(h);\r\n            if (i.namespaceURI == g && i.nodeType == 1 && XmlUtils.d(i) == f) {\r\n                b = i;\r\n            }\r\n        }\r\n        if (b == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new XElement(0, b);\r\n        }\r\n    };\r\n    XContainer.prototype.elements = function () {\r\n        return this.f(null);\r\n    };\r\n    XContainer.prototype.elements1 = function (a) {\r\n        return this.f(a);\r\n    };\r\n    XContainer.prototype.f = function (a) {\r\n        var b = new List$1(XElement.$, 0);\r\n        for (var c = 0; c < this.backingNode.childNodes.length; c++) {\r\n            var d = this.backingNode.childNodes.item(c);\r\n            if (d.nodeType == 1) {\r\n                var e = false;\r\n                if (a != null) {\r\n                    if (XmlUtils.d(d) == a.localName && d.namespaceURI == a.namespaceName) {\r\n                        e = true;\r\n                    }\r\n                }\r\n                else {\r\n                    e = true;\r\n                }\r\n                if (e) {\r\n                    b.add(new XElement(0, d));\r\n                }\r\n            }\r\n        }\r\n        return b;\r\n    };\r\n    XContainer.prototype.add = function (a) {\r\n        var b = this.backingNode;\r\n        var c;\r\n        if (typeCast(XDocument.$, this) !== null) {\r\n            c = this.backingNode;\r\n        }\r\n        else {\r\n            c = this.backingNode.ownerDocument;\r\n        }\r\n        if (typeCast(XAttribute.$, a) !== null) {\r\n            a.e(b);\r\n        }\r\n        else if (typeCast(XElement.$, a) !== null) {\r\n            a.j(b, c);\r\n        }\r\n    };\r\n    XContainer.$t = markType(XContainer, 'XContainer', XNode.$);\r\n    return XContainer;\r\n}(XNode));\r\nexport { XContainer };\r\n/**\r\n * @hidden\r\n */\r\nvar XDocument = /** @class */ /*@__PURE__*/ (function (_super) {\r\n    tslib_1.__extends(XDocument, _super);\r\n    function XDocument(a) {\r\n        var _rest = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _rest[_i - 1] = arguments[_i];\r\n        }\r\n        var _this = this;\r\n        a = (a == void 0) ? 0 : a;\r\n        switch (a) {\r\n            case 0:\r\n                {\r\n                    var c = _rest[0];\r\n                    _this = _super.call(this, c) || this;\r\n                }\r\n                break;\r\n            case 1:\r\n                {\r\n                    _this = _super.call(this, XmlUtils.j()) || this;\r\n                }\r\n                break;\r\n        }\r\n        return _this;\r\n    }\r\n    XDocument.prototype.get_nodeType = function () {\r\n        return 9;\r\n    };\r\n    Object.defineProperty(XDocument.prototype, \"nodeType\", {\r\n        get: function () {\r\n            return this.get_nodeType();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    XDocument.parse = function (a) {\r\n        return new XDocument(0, XmlUtils.n(a));\r\n    };\r\n    XDocument.$t = markType(XDocument, 'XDocument', XContainer.$);\r\n    return XDocument;\r\n}(XContainer));\r\nexport { XDocument };\r\n/**\r\n * @hidden\r\n */\r\nvar XElement = /** @class */ /*@__PURE__*/ (function (_super) {\r\n    tslib_1.__extends(XElement, _super);\r\n    function XElement(a) {\r\n        var _rest = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _rest[_i - 1] = arguments[_i];\r\n        }\r\n        var _this = this;\r\n        a = (a == void 0) ? 0 : a;\r\n        switch (a) {\r\n            case 0:\r\n                {\r\n                    var c = _rest[0];\r\n                    _this = _super.call(this, c) || this;\r\n                }\r\n                break;\r\n            case 1:\r\n                {\r\n                    var c = _rest[0];\r\n                    var d = [c, null];\r\n                    {\r\n                        var f = d[0];\r\n                        var g = d[1];\r\n                        _this = _super.call(this, XmlUtils.o(f.localName, f.namespaceName)) || this;\r\n                        var h = g == null ? \"\" : g.toString();\r\n                        _this.value = h;\r\n                    }\r\n                }\r\n                break;\r\n            case 2:\r\n                {\r\n                    var c = _rest[0];\r\n                    var d = _rest[1];\r\n                    _this = _super.call(this, XmlUtils.o(c.localName, c.namespaceName)) || this;\r\n                    var e = d == null ? \"\" : d.toString();\r\n                    _this.value = e;\r\n                }\r\n                break;\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(XElement.prototype, \"value\", {\r\n        get: function () {\r\n            return XmlUtils.c(this.backingNode);\r\n        },\r\n        set: function (a) {\r\n            XmlUtils.h(this.backingNode, a);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    XElement.prototype.get_nodeType = function () {\r\n        return 1;\r\n    };\r\n    Object.defineProperty(XElement.prototype, \"nodeType\", {\r\n        get: function () {\r\n            return this.get_nodeType();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(XElement.prototype, \"name\", {\r\n        get: function () {\r\n            return XName.get(XmlUtils.d(this.backingNode), this.backingNode.namespaceURI);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    XElement.prototype.attribute = function (a) {\r\n        return new XAttribute(XmlUtils.i(this.backingNode, a.localName, a.namespaceName));\r\n    };\r\n    XElement.prototype.j = function (a, b) {\r\n        if (this.backingNode.ownerDocument != b) {\r\n            this.backingNode = XmlUtils.p(b, this.backingNode);\r\n        }\r\n        a.appendChild(this.backingNode);\r\n    };\r\n    XElement.$t = markType(XElement, 'XElement', XContainer.$);\r\n    return XElement;\r\n}(XContainer));\r\nexport { XElement };\r\n//# sourceMappingURL=XContainer_combined.js.map\r\n"]},"metadata":{},"sourceType":"module"}
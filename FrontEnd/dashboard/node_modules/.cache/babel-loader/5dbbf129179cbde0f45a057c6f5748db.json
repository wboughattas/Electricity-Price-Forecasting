{"ast":null,"code":"/*\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, markType, Point_$type } from \"./type\";\nimport { PathFigureCollection } from \"./PathFigureCollection\";\nimport { PathMarkupToken } from \"./PathMarkupToken\";\nimport { List$1 } from \"./List$1\";\nimport { PathFigure } from \"./PathFigure\";\nimport { ArcSegment } from \"./ArcSegment\";\nimport { LineSegment } from \"./LineSegment\";\nimport { BezierSegment } from \"./BezierSegment\";\nimport { Size } from \"./Size\";\nimport { InvalidOperationException } from \"./InvalidOperationException\";\nimport { stringEmpty } from \"./string\";\n/**\n * @hidden\n */\n\nvar Geometry =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(Geometry, _super);\n\n  function Geometry() {\n    return _super.call(this) || this;\n  }\n\n  Geometry.a = function (a) {\n    if (a != null) {\n      var b = new PathMarkupParser();\n      return b.k(a);\n    }\n\n    return null;\n  };\n\n  Geometry.$t = markType(Geometry, 'Geometry');\n  return Geometry;\n}(Base);\n\nexport { Geometry };\n/**\n * @hidden\n */\n\nvar PathGeometry =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(PathGeometry, _super);\n\n  function PathGeometry() {\n    var _this = _super.call(this) || this;\n\n    _this.c = null;\n    _this.c = new PathFigureCollection();\n    return _this;\n  }\n\n  PathGeometry.prototype.get_b = function () {\n    return 4;\n  };\n\n  Object.defineProperty(PathGeometry.prototype, \"b\", {\n    get: function () {\n      return this.get_b();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  PathGeometry.$t = markType(PathGeometry, 'PathGeometry', Geometry.$);\n  return PathGeometry;\n}(Geometry);\n\nexport { PathGeometry };\n/**\n * @hidden\n */\n\nvar PathMarkupParser =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(PathMarkupParser, _super);\n\n  function PathMarkupParser() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.e = '\\0';\n    _this.h = 0;\n    _this.l = {\n      $type: Point_$type,\n      x: 0,\n      y: 0\n    };\n    _this.f = null;\n    _this.i = null;\n    return _this;\n  }\n\n  PathMarkupParser.prototype.k = function (a) {\n    this.f = new List$1(PathMarkupToken.$, 0);\n    this.h = 0;\n\n    var _loop_1 = function () {\n      switch (this_1.e) {\n        case 'M':\n        case 'm':\n          this_1.f.add(new PathMarkupToken(0, this_1.e.charCodeAt(0) < 'm'.charCodeAt(0)));\n          break;\n\n        case 'L':\n        case 'l':\n          this_1.f.add(new PathMarkupToken(1, this_1.e.charCodeAt(0) < 'l'.charCodeAt(0)));\n          break;\n\n        case 'H':\n        case 'h':\n          this_1.f.add(new PathMarkupToken(2, this_1.e.charCodeAt(0) < 'h'.charCodeAt(0)));\n          break;\n\n        case 'V':\n        case 'v':\n          this_1.f.add(new PathMarkupToken(3, this_1.e.charCodeAt(0) < 'v'.charCodeAt(0)));\n          break;\n\n        case 'C':\n        case 'c':\n          this_1.f.add(new PathMarkupToken(4, this_1.e.charCodeAt(0) < 'c'.charCodeAt(0)));\n          break;\n\n        case 'Q':\n        case 'q':\n          this_1.f.add(new PathMarkupToken(5, this_1.e.charCodeAt(0) < 'q'.charCodeAt(0)));\n          break;\n\n        case 'S':\n        case 's':\n          this_1.f.add(new PathMarkupToken(6, this_1.e.charCodeAt(0) < 's'.charCodeAt(0)));\n          break;\n\n        case 'T':\n        case 't':\n          this_1.f.add(new PathMarkupToken(7, this_1.e.charCodeAt(0) < 't'.charCodeAt(0)));\n          break;\n\n        case 'A':\n        case 'a':\n          this_1.f.add(new PathMarkupToken(8, this_1.e.charCodeAt(0) < 'a'.charCodeAt(0)));\n          break;\n\n        case 'Z':\n        case 'z':\n          this_1.f.add(new PathMarkupToken(9, this_1.e.charCodeAt(0) < 'z'.charCodeAt(0)));\n          break;\n      }\n\n      if (this_1.a(this_1.e)) {\n        var b = true;\n        var c = false;\n        var d = false;\n        var e_1 = stringEmpty();\n        var f = false;\n        this_1.h = this_1.h - 1;\n\n        while (this_1.h < a.length) {\n          var g = a.charAt(this_1.h);\n\n          if (d) {\n            if (!this_1.a(g)) {\n              f = true;\n              break;\n            } else {\n              e_1 += g;\n              this_1.h++;\n\n              if (this_1.h >= a.length) {\n                f = true;\n                break;\n              }\n            }\n          } else if (c) {\n            if (g == 'e' || g == 'E') {\n              d = true;\n              e_1 += g;\n              this_1.h++;\n              continue;\n            }\n\n            if (!this_1.a(g)) {\n              f = true;\n              break;\n            } else {\n              e_1 += g;\n              this_1.h++;\n\n              if (this_1.h >= a.length) {\n                f = true;\n                break;\n              }\n            }\n          } else if (b) {\n            if (g == '.') {\n              c = true;\n              e_1 += g;\n              this_1.h++;\n              continue;\n            }\n\n            if (g == 'e' || g == 'E') {\n              d = true;\n              e_1 += g;\n              this_1.h++;\n              continue;\n            }\n\n            if (!this_1.a(g)) {\n              f = true;\n              break;\n            } else {\n              e_1 += g;\n              this_1.h++;\n\n              if (this_1.h >= a.length) {\n                f = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (f) {\n          this_1.f.add(function () {\n            var $ret = new PathMarkupToken(10, false);\n            $ret.b = parseFloat(e_1);\n            return $ret;\n          }());\n        }\n      }\n    };\n\n    var this_1 = this;\n\n    while (this.d(a)) {\n      _loop_1();\n    }\n\n    return this.j();\n  };\n\n  PathMarkupParser.prototype.a = function (a) {\n    return a == '.' || a == '-' || a == '+' || a.charCodeAt(0) >= '0'.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0);\n  };\n\n  PathMarkupParser.prototype.j = function () {\n    var _this = this;\n\n    this.h = 0;\n    var a = true;\n    var b = new PathGeometry();\n    var c = null;\n    var d = 11;\n    var e = null;\n    var f = null;\n    var g = null;\n\n    while (this.h < this.f.count) {\n      var h = this.f._inner[this.h++];\n\n      if (a && h.c != 0) {\n        return null;\n      }\n\n      switch (h.c) {\n        case 0:\n          c = new PathFigure();\n          b.c.add(c);\n          this.l = this.m(h.a);\n          c._startPoint = this.l;\n\n          while (this.b()) {\n            this.l = this.m(h.a);\n\n            c._segments.add(new LineSegment(0, this.l));\n          }\n\n          d = 0;\n          break;\n\n        case 1:\n        case 2:\n        case 3:\n          if (c == null) {\n            return null;\n          }\n\n          do {\n            switch (h.c) {\n              case 1:\n                this.l = this.m(h.a);\n                break;\n\n              case 2:\n                this.l.x = h.a ? this.g() : this.l.x + this.g();\n                break;\n\n              case 3:\n                this.l.y = h.a ? this.g() : this.l.y + this.g();\n                break;\n            }\n\n            c._segments.add(new LineSegment(0, this.l));\n          } while (this.b());\n\n          d = 1;\n          break;\n\n        case 4:\n        case 6:\n          if (c == null) {\n            return null;\n          }\n\n          do {\n            if (h.c == 6) {\n              if (d == 4) {\n                e = {\n                  $type: Point_$type,\n                  x: 2 * this.l.x - f.x,\n                  y: 2 * this.l.y - f.y\n                };\n              } else {\n                e = this.l;\n              }\n            } else {\n              e = this.m(h.a);\n            }\n\n            f = this.m(h.a);\n            g = this.m(h.a);\n\n            c._segments.add(new BezierSegment(1, e, f, g));\n\n            this.l = g;\n            d = 4;\n          } while (this.b());\n\n          break;\n\n        case 5:\n        case 7:\n          break;\n\n        case 8:\n          if (c == null) {\n            return null;\n          }\n\n          var _loop_2 = function () {\n            var i = this_2.g();\n            var j = this_2.g();\n            var k = this_2.g();\n            var l = this_2.g();\n            var m = this_2.g();\n            this_2.l = this_2.m(h.a);\n\n            c._segments.add(function () {\n              var $ret = new ArcSegment();\n              $ret.e = _this.l;\n              $ret.f = new Size(1, i, j);\n              $ret.c = k;\n              $ret.b = l == 1;\n              $ret.d = m == 1 ? 1 : 0;\n              return $ret;\n            }());\n          };\n\n          var this_2 = this;\n\n          do {\n            _loop_2();\n          } while (this.b());\n\n          d = 8;\n          break;\n\n        case 9:\n          if (c == null) {\n            return null;\n          }\n\n          c._isClosed = true;\n          break;\n      }\n\n      a = false;\n    }\n\n    return b;\n  };\n\n  PathMarkupParser.prototype.m = function (a) {\n    var b = this.g();\n    var c = this.g();\n\n    if (!a) {\n      b += this.l.x;\n      c += this.l.y;\n    }\n\n    return {\n      $type: Point_$type,\n      x: b,\n      y: c\n    };\n  };\n\n  PathMarkupParser.prototype.g = function () {\n    var a = this.f._inner[this.h++];\n\n    if (a.c != 10) {\n      throw new InvalidOperationException(0);\n    }\n\n    return a.b;\n  };\n\n  PathMarkupParser.prototype.b = function () {\n    if (this.h >= this.f.count) {\n      return false;\n    }\n\n    return this.f._inner[this.h].c == 10;\n  };\n\n  PathMarkupParser.prototype.d = function (a) {\n    while (this.h < a.length && this.c(a.charAt(this.h))) {\n      this.h++;\n    }\n\n    if (this.h < a.length) {\n      this.e = a.charAt(this.h);\n      this.h++;\n      return true;\n    }\n\n    return false;\n  };\n\n  PathMarkupParser.prototype.c = function (a) {\n    return a == '\\r' || a == '\\n' || a == ' ' || a == '\\t';\n  };\n\n  PathMarkupParser.$t = markType(PathMarkupParser, 'PathMarkupParser');\n  return PathMarkupParser;\n}(Base);\n\nexport { PathMarkupParser };","map":{"version":3,"sources":["../../../../src/igniteui-core/lib/Geometry_combined.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, markType, Point_$type } from \"./type\";\nimport { PathFigureCollection } from \"./PathFigureCollection\";\nimport { PathMarkupToken } from \"./PathMarkupToken\";\nimport { List$1 } from \"./List$1\";\nimport { PathFigure } from \"./PathFigure\";\nimport { ArcSegment } from \"./ArcSegment\";\nimport { LineSegment } from \"./LineSegment\";\nimport { BezierSegment } from \"./BezierSegment\";\nimport { Size } from \"./Size\";\nimport { InvalidOperationException } from \"./InvalidOperationException\";\nimport { stringEmpty } from \"./string\";\n/**\n * @hidden\n */\nvar Geometry = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Geometry, _super);\n    function Geometry() {\n        return _super.call(this) || this;\n    }\n    Geometry.a = function (a) {\n        if (a != null) {\n            var b = new PathMarkupParser();\n            return b.k(a);\n        }\n        return null;\n    };\n    Geometry.$t = markType(Geometry, 'Geometry');\n    return Geometry;\n}(Base));\nexport { Geometry };\n/**\n * @hidden\n */\nvar PathGeometry = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(PathGeometry, _super);\n    function PathGeometry() {\n        var _this = _super.call(this) || this;\n        _this.c = null;\n        _this.c = new PathFigureCollection();\n        return _this;\n    }\n    PathGeometry.prototype.get_b = function () {\n        return 4;\n    };\n    Object.defineProperty(PathGeometry.prototype, \"b\", {\n        get: function () {\n            return this.get_b();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PathGeometry.$t = markType(PathGeometry, 'PathGeometry', Geometry.$);\n    return PathGeometry;\n}(Geometry));\nexport { PathGeometry };\n/**\n * @hidden\n */\nvar PathMarkupParser = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(PathMarkupParser, _super);\n    function PathMarkupParser() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.e = '\\0';\n        _this.h = 0;\n        _this.l = { $type: Point_$type, x: 0, y: 0 };\n        _this.f = null;\n        _this.i = null;\n        return _this;\n    }\n    PathMarkupParser.prototype.k = function (a) {\n        this.f = new List$1(PathMarkupToken.$, 0);\n        this.h = 0;\n        var _loop_1 = function () {\n            switch (this_1.e) {\n                case 'M':\n                case 'm':\n                    this_1.f.add(new PathMarkupToken(0, this_1.e.charCodeAt(0) < 'm'.charCodeAt(0)));\n                    break;\n                case 'L':\n                case 'l':\n                    this_1.f.add(new PathMarkupToken(1, this_1.e.charCodeAt(0) < 'l'.charCodeAt(0)));\n                    break;\n                case 'H':\n                case 'h':\n                    this_1.f.add(new PathMarkupToken(2, this_1.e.charCodeAt(0) < 'h'.charCodeAt(0)));\n                    break;\n                case 'V':\n                case 'v':\n                    this_1.f.add(new PathMarkupToken(3, this_1.e.charCodeAt(0) < 'v'.charCodeAt(0)));\n                    break;\n                case 'C':\n                case 'c':\n                    this_1.f.add(new PathMarkupToken(4, this_1.e.charCodeAt(0) < 'c'.charCodeAt(0)));\n                    break;\n                case 'Q':\n                case 'q':\n                    this_1.f.add(new PathMarkupToken(5, this_1.e.charCodeAt(0) < 'q'.charCodeAt(0)));\n                    break;\n                case 'S':\n                case 's':\n                    this_1.f.add(new PathMarkupToken(6, this_1.e.charCodeAt(0) < 's'.charCodeAt(0)));\n                    break;\n                case 'T':\n                case 't':\n                    this_1.f.add(new PathMarkupToken(7, this_1.e.charCodeAt(0) < 't'.charCodeAt(0)));\n                    break;\n                case 'A':\n                case 'a':\n                    this_1.f.add(new PathMarkupToken(8, this_1.e.charCodeAt(0) < 'a'.charCodeAt(0)));\n                    break;\n                case 'Z':\n                case 'z':\n                    this_1.f.add(new PathMarkupToken(9, this_1.e.charCodeAt(0) < 'z'.charCodeAt(0)));\n                    break;\n            }\n            if (this_1.a(this_1.e)) {\n                var b = true;\n                var c = false;\n                var d = false;\n                var e_1 = stringEmpty();\n                var f = false;\n                this_1.h = this_1.h - 1;\n                while (this_1.h < a.length) {\n                    var g = a.charAt(this_1.h);\n                    if (d) {\n                        if (!this_1.a(g)) {\n                            f = true;\n                            break;\n                        }\n                        else {\n                            e_1 += g;\n                            this_1.h++;\n                            if (this_1.h >= a.length) {\n                                f = true;\n                                break;\n                            }\n                        }\n                    }\n                    else if (c) {\n                        if (g == 'e' || g == 'E') {\n                            d = true;\n                            e_1 += g;\n                            this_1.h++;\n                            continue;\n                        }\n                        if (!this_1.a(g)) {\n                            f = true;\n                            break;\n                        }\n                        else {\n                            e_1 += g;\n                            this_1.h++;\n                            if (this_1.h >= a.length) {\n                                f = true;\n                                break;\n                            }\n                        }\n                    }\n                    else if (b) {\n                        if (g == '.') {\n                            c = true;\n                            e_1 += g;\n                            this_1.h++;\n                            continue;\n                        }\n                        if (g == 'e' || g == 'E') {\n                            d = true;\n                            e_1 += g;\n                            this_1.h++;\n                            continue;\n                        }\n                        if (!this_1.a(g)) {\n                            f = true;\n                            break;\n                        }\n                        else {\n                            e_1 += g;\n                            this_1.h++;\n                            if (this_1.h >= a.length) {\n                                f = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (f) {\n                    this_1.f.add(((function () {\n                        var $ret = new PathMarkupToken(10, false);\n                        $ret.b = parseFloat(e_1);\n                        return $ret;\n                    })()));\n                }\n            }\n        };\n        var this_1 = this;\n        while (this.d(a)) {\n            _loop_1();\n        }\n        return this.j();\n    };\n    PathMarkupParser.prototype.a = function (a) {\n        return a == '.' || a == '-' || a == '+' || (a.charCodeAt(0) >= '0'.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0));\n    };\n    PathMarkupParser.prototype.j = function () {\n        var _this = this;\n        this.h = 0;\n        var a = true;\n        var b = new PathGeometry();\n        var c = null;\n        var d = 11;\n        var e = null;\n        var f = null;\n        var g = null;\n        while (this.h < this.f.count) {\n            var h = this.f._inner[this.h++];\n            if (a && h.c != 0) {\n                return null;\n            }\n            switch (h.c) {\n                case 0:\n                    c = new PathFigure();\n                    b.c.add(c);\n                    this.l = this.m(h.a);\n                    c._startPoint = this.l;\n                    while (this.b()) {\n                        this.l = this.m(h.a);\n                        c._segments.add(new LineSegment(0, this.l));\n                    }\n                    d = 0;\n                    break;\n                case 1:\n                case 2:\n                case 3:\n                    if (c == null) {\n                        return null;\n                    }\n                    do {\n                        switch (h.c) {\n                            case 1:\n                                this.l = this.m(h.a);\n                                break;\n                            case 2:\n                                this.l.x = h.a ? this.g() : this.l.x + this.g();\n                                break;\n                            case 3:\n                                this.l.y = h.a ? this.g() : this.l.y + this.g();\n                                break;\n                        }\n                        c._segments.add(new LineSegment(0, this.l));\n                    } while (this.b());\n                    d = 1;\n                    break;\n                case 4:\n                case 6:\n                    if (c == null) {\n                        return null;\n                    }\n                    do {\n                        if (h.c == 6) {\n                            if (d == 4) {\n                                e = { $type: Point_$type, x: 2 * this.l.x - f.x, y: 2 * this.l.y - f.y };\n                            }\n                            else {\n                                e = this.l;\n                            }\n                        }\n                        else {\n                            e = this.m(h.a);\n                        }\n                        f = this.m(h.a);\n                        g = this.m(h.a);\n                        c._segments.add(new BezierSegment(1, e, f, g));\n                        this.l = g;\n                        d = 4;\n                    } while (this.b());\n                    break;\n                case 5:\n                case 7: break;\n                case 8:\n                    if (c == null) {\n                        return null;\n                    }\n                    var _loop_2 = function () {\n                        var i = this_2.g();\n                        var j = this_2.g();\n                        var k = this_2.g();\n                        var l = this_2.g();\n                        var m = this_2.g();\n                        this_2.l = this_2.m(h.a);\n                        c._segments.add(((function () {\n                            var $ret = new ArcSegment();\n                            $ret.e = _this.l;\n                            $ret.f = new Size(1, i, j);\n                            $ret.c = k;\n                            $ret.b = l == 1;\n                            $ret.d = m == 1 ? 1 : 0;\n                            return $ret;\n                        })()));\n                    };\n                    var this_2 = this;\n                    do {\n                        _loop_2();\n                    } while (this.b());\n                    d = 8;\n                    break;\n                case 9:\n                    if (c == null) {\n                        return null;\n                    }\n                    c._isClosed = true;\n                    break;\n            }\n            a = false;\n        }\n        return b;\n    };\n    PathMarkupParser.prototype.m = function (a) {\n        var b = this.g();\n        var c = this.g();\n        if (!a) {\n            b += this.l.x;\n            c += this.l.y;\n        }\n        return { $type: Point_$type, x: b, y: c };\n    };\n    PathMarkupParser.prototype.g = function () {\n        var a = this.f._inner[this.h++];\n        if (a.c != 10) {\n            throw new InvalidOperationException(0);\n        }\n        return a.b;\n    };\n    PathMarkupParser.prototype.b = function () {\n        if (this.h >= this.f.count) {\n            return false;\n        }\n        return this.f._inner[this.h].c == 10;\n    };\n    PathMarkupParser.prototype.d = function (a) {\n        while (this.h < a.length && this.c(a.charAt(this.h))) {\n            this.h++;\n        }\n        if (this.h < a.length) {\n            this.e = a.charAt(this.h);\n            this.h++;\n            return true;\n        }\n        return false;\n    };\n    PathMarkupParser.prototype.c = function (a) {\n        return a == '\\r' || a == '\\n' || a == ' ' || a == '\\t';\n    };\n    PathMarkupParser.$t = markType(PathMarkupParser, 'PathMarkupParser');\n    return PathMarkupParser;\n}(Base));\nexport { PathMarkupParser };\n//# sourceMappingURL=Geometry_combined.js.map\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/*\r\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\r\nhttps://www.infragistics.com/legal/license/igultimate-la\r\nhttps://www.infragistics.com/legal/license/igultimate-eula\r\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\r\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, markType, Point_$type } from \"./type\";\nimport { PathFigureCollection } from \"./PathFigureCollection\";\nimport { PathMarkupToken } from \"./PathMarkupToken\";\nimport { List$1 } from \"./List$1\";\nimport { PathFigure } from \"./PathFigure\";\nimport { ArcSegment } from \"./ArcSegment\";\nimport { LineSegment } from \"./LineSegment\";\nimport { BezierSegment } from \"./BezierSegment\";\nimport { Size } from \"./Size\";\nimport { InvalidOperationException } from \"./InvalidOperationException\";\nimport { stringEmpty } from \"./string\";\n/**\r\n * @hidden\r\n */\n\nvar Geometry =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(Geometry, _super);\n\n  function Geometry() {\n    return _super.call(this) || this;\n  }\n\n  Geometry.a = function (a) {\n    if (a != null) {\n      var b = new PathMarkupParser();\n      return b.k(a);\n    }\n\n    return null;\n  };\n\n  Geometry.$t = markType(Geometry, 'Geometry');\n  return Geometry;\n}(Base);\n\nexport { Geometry };\n/**\r\n * @hidden\r\n */\n\nvar PathGeometry =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(PathGeometry, _super);\n\n  function PathGeometry() {\n    var _this = _super.call(this) || this;\n\n    _this.c = null;\n    _this.c = new PathFigureCollection();\n    return _this;\n  }\n\n  PathGeometry.prototype.get_b = function () {\n    return 4;\n  };\n\n  Object.defineProperty(PathGeometry.prototype, \"b\", {\n    get: function () {\n      return this.get_b();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  PathGeometry.$t = markType(PathGeometry, 'PathGeometry', Geometry.$);\n  return PathGeometry;\n}(Geometry);\n\nexport { PathGeometry };\n/**\r\n * @hidden\r\n */\n\nvar PathMarkupParser =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(PathMarkupParser, _super);\n\n  function PathMarkupParser() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.e = '\\0';\n    _this.h = 0;\n    _this.l = {\n      $type: Point_$type,\n      x: 0,\n      y: 0\n    };\n    _this.f = null;\n    _this.i = null;\n    return _this;\n  }\n\n  PathMarkupParser.prototype.k = function (a) {\n    this.f = new List$1(PathMarkupToken.$, 0);\n    this.h = 0;\n\n    var _loop_1 = function () {\n      switch (this_1.e) {\n        case 'M':\n        case 'm':\n          this_1.f.add(new PathMarkupToken(0, this_1.e.charCodeAt(0) < 'm'.charCodeAt(0)));\n          break;\n\n        case 'L':\n        case 'l':\n          this_1.f.add(new PathMarkupToken(1, this_1.e.charCodeAt(0) < 'l'.charCodeAt(0)));\n          break;\n\n        case 'H':\n        case 'h':\n          this_1.f.add(new PathMarkupToken(2, this_1.e.charCodeAt(0) < 'h'.charCodeAt(0)));\n          break;\n\n        case 'V':\n        case 'v':\n          this_1.f.add(new PathMarkupToken(3, this_1.e.charCodeAt(0) < 'v'.charCodeAt(0)));\n          break;\n\n        case 'C':\n        case 'c':\n          this_1.f.add(new PathMarkupToken(4, this_1.e.charCodeAt(0) < 'c'.charCodeAt(0)));\n          break;\n\n        case 'Q':\n        case 'q':\n          this_1.f.add(new PathMarkupToken(5, this_1.e.charCodeAt(0) < 'q'.charCodeAt(0)));\n          break;\n\n        case 'S':\n        case 's':\n          this_1.f.add(new PathMarkupToken(6, this_1.e.charCodeAt(0) < 's'.charCodeAt(0)));\n          break;\n\n        case 'T':\n        case 't':\n          this_1.f.add(new PathMarkupToken(7, this_1.e.charCodeAt(0) < 't'.charCodeAt(0)));\n          break;\n\n        case 'A':\n        case 'a':\n          this_1.f.add(new PathMarkupToken(8, this_1.e.charCodeAt(0) < 'a'.charCodeAt(0)));\n          break;\n\n        case 'Z':\n        case 'z':\n          this_1.f.add(new PathMarkupToken(9, this_1.e.charCodeAt(0) < 'z'.charCodeAt(0)));\n          break;\n      }\n\n      if (this_1.a(this_1.e)) {\n        var b = true;\n        var c = false;\n        var d = false;\n        var e_1 = stringEmpty();\n        var f = false;\n        this_1.h = this_1.h - 1;\n\n        while (this_1.h < a.length) {\n          var g = a.charAt(this_1.h);\n\n          if (d) {\n            if (!this_1.a(g)) {\n              f = true;\n              break;\n            } else {\n              e_1 += g;\n              this_1.h++;\n\n              if (this_1.h >= a.length) {\n                f = true;\n                break;\n              }\n            }\n          } else if (c) {\n            if (g == 'e' || g == 'E') {\n              d = true;\n              e_1 += g;\n              this_1.h++;\n              continue;\n            }\n\n            if (!this_1.a(g)) {\n              f = true;\n              break;\n            } else {\n              e_1 += g;\n              this_1.h++;\n\n              if (this_1.h >= a.length) {\n                f = true;\n                break;\n              }\n            }\n          } else if (b) {\n            if (g == '.') {\n              c = true;\n              e_1 += g;\n              this_1.h++;\n              continue;\n            }\n\n            if (g == 'e' || g == 'E') {\n              d = true;\n              e_1 += g;\n              this_1.h++;\n              continue;\n            }\n\n            if (!this_1.a(g)) {\n              f = true;\n              break;\n            } else {\n              e_1 += g;\n              this_1.h++;\n\n              if (this_1.h >= a.length) {\n                f = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (f) {\n          this_1.f.add(function () {\n            var $ret = new PathMarkupToken(10, false);\n            $ret.b = parseFloat(e_1);\n            return $ret;\n          }());\n        }\n      }\n    };\n\n    var this_1 = this;\n\n    while (this.d(a)) {\n      _loop_1();\n    }\n\n    return this.j();\n  };\n\n  PathMarkupParser.prototype.a = function (a) {\n    return a == '.' || a == '-' || a == '+' || a.charCodeAt(0) >= '0'.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0);\n  };\n\n  PathMarkupParser.prototype.j = function () {\n    var _this = this;\n\n    this.h = 0;\n    var a = true;\n    var b = new PathGeometry();\n    var c = null;\n    var d = 11;\n    var e = null;\n    var f = null;\n    var g = null;\n\n    while (this.h < this.f.count) {\n      var h = this.f._inner[this.h++];\n\n      if (a && h.c != 0) {\n        return null;\n      }\n\n      switch (h.c) {\n        case 0:\n          c = new PathFigure();\n          b.c.add(c);\n          this.l = this.m(h.a);\n          c._startPoint = this.l;\n\n          while (this.b()) {\n            this.l = this.m(h.a);\n\n            c._segments.add(new LineSegment(0, this.l));\n          }\n\n          d = 0;\n          break;\n\n        case 1:\n        case 2:\n        case 3:\n          if (c == null) {\n            return null;\n          }\n\n          do {\n            switch (h.c) {\n              case 1:\n                this.l = this.m(h.a);\n                break;\n\n              case 2:\n                this.l.x = h.a ? this.g() : this.l.x + this.g();\n                break;\n\n              case 3:\n                this.l.y = h.a ? this.g() : this.l.y + this.g();\n                break;\n            }\n\n            c._segments.add(new LineSegment(0, this.l));\n          } while (this.b());\n\n          d = 1;\n          break;\n\n        case 4:\n        case 6:\n          if (c == null) {\n            return null;\n          }\n\n          do {\n            if (h.c == 6) {\n              if (d == 4) {\n                e = {\n                  $type: Point_$type,\n                  x: 2 * this.l.x - f.x,\n                  y: 2 * this.l.y - f.y\n                };\n              } else {\n                e = this.l;\n              }\n            } else {\n              e = this.m(h.a);\n            }\n\n            f = this.m(h.a);\n            g = this.m(h.a);\n\n            c._segments.add(new BezierSegment(1, e, f, g));\n\n            this.l = g;\n            d = 4;\n          } while (this.b());\n\n          break;\n\n        case 5:\n        case 7:\n          break;\n\n        case 8:\n          if (c == null) {\n            return null;\n          }\n\n          var _loop_2 = function () {\n            var i = this_2.g();\n            var j = this_2.g();\n            var k = this_2.g();\n            var l = this_2.g();\n            var m = this_2.g();\n            this_2.l = this_2.m(h.a);\n\n            c._segments.add(function () {\n              var $ret = new ArcSegment();\n              $ret.e = _this.l;\n              $ret.f = new Size(1, i, j);\n              $ret.c = k;\n              $ret.b = l == 1;\n              $ret.d = m == 1 ? 1 : 0;\n              return $ret;\n            }());\n          };\n\n          var this_2 = this;\n\n          do {\n            _loop_2();\n          } while (this.b());\n\n          d = 8;\n          break;\n\n        case 9:\n          if (c == null) {\n            return null;\n          }\n\n          c._isClosed = true;\n          break;\n      }\n\n      a = false;\n    }\n\n    return b;\n  };\n\n  PathMarkupParser.prototype.m = function (a) {\n    var b = this.g();\n    var c = this.g();\n\n    if (!a) {\n      b += this.l.x;\n      c += this.l.y;\n    }\n\n    return {\n      $type: Point_$type,\n      x: b,\n      y: c\n    };\n  };\n\n  PathMarkupParser.prototype.g = function () {\n    var a = this.f._inner[this.h++];\n\n    if (a.c != 10) {\n      throw new InvalidOperationException(0);\n    }\n\n    return a.b;\n  };\n\n  PathMarkupParser.prototype.b = function () {\n    if (this.h >= this.f.count) {\n      return false;\n    }\n\n    return this.f._inner[this.h].c == 10;\n  };\n\n  PathMarkupParser.prototype.d = function (a) {\n    while (this.h < a.length && this.c(a.charAt(this.h))) {\n      this.h++;\n    }\n\n    if (this.h < a.length) {\n      this.e = a.charAt(this.h);\n      this.h++;\n      return true;\n    }\n\n    return false;\n  };\n\n  PathMarkupParser.prototype.c = function (a) {\n    return a == '\\r' || a == '\\n' || a == ' ' || a == '\\t';\n  };\n\n  PathMarkupParser.$t = markType(PathMarkupParser, 'PathMarkupParser');\n  return PathMarkupParser;\n}(Base);\n\nexport { PathMarkupParser };","map":{"version":3,"sources":["../../../../src/igniteui-core/lib/Geometry_combined.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\r\nhttps://www.infragistics.com/legal/license/igultimate-la\r\nhttps://www.infragistics.com/legal/license/igultimate-eula\r\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\r\n*/\r\nimport * as tslib_1 from \"tslib\";\r\nimport { Base, markType, Point_$type } from \"./type\";\r\nimport { PathFigureCollection } from \"./PathFigureCollection\";\r\nimport { PathMarkupToken } from \"./PathMarkupToken\";\r\nimport { List$1 } from \"./List$1\";\r\nimport { PathFigure } from \"./PathFigure\";\r\nimport { ArcSegment } from \"./ArcSegment\";\r\nimport { LineSegment } from \"./LineSegment\";\r\nimport { BezierSegment } from \"./BezierSegment\";\r\nimport { Size } from \"./Size\";\r\nimport { InvalidOperationException } from \"./InvalidOperationException\";\r\nimport { stringEmpty } from \"./string\";\r\n/**\r\n * @hidden\r\n */\r\nvar Geometry = /** @class */ /*@__PURE__*/ (function (_super) {\r\n    tslib_1.__extends(Geometry, _super);\r\n    function Geometry() {\r\n        return _super.call(this) || this;\r\n    }\r\n    Geometry.a = function (a) {\r\n        if (a != null) {\r\n            var b = new PathMarkupParser();\r\n            return b.k(a);\r\n        }\r\n        return null;\r\n    };\r\n    Geometry.$t = markType(Geometry, 'Geometry');\r\n    return Geometry;\r\n}(Base));\r\nexport { Geometry };\r\n/**\r\n * @hidden\r\n */\r\nvar PathGeometry = /** @class */ /*@__PURE__*/ (function (_super) {\r\n    tslib_1.__extends(PathGeometry, _super);\r\n    function PathGeometry() {\r\n        var _this = _super.call(this) || this;\r\n        _this.c = null;\r\n        _this.c = new PathFigureCollection();\r\n        return _this;\r\n    }\r\n    PathGeometry.prototype.get_b = function () {\r\n        return 4;\r\n    };\r\n    Object.defineProperty(PathGeometry.prototype, \"b\", {\r\n        get: function () {\r\n            return this.get_b();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    PathGeometry.$t = markType(PathGeometry, 'PathGeometry', Geometry.$);\r\n    return PathGeometry;\r\n}(Geometry));\r\nexport { PathGeometry };\r\n/**\r\n * @hidden\r\n */\r\nvar PathMarkupParser = /** @class */ /*@__PURE__*/ (function (_super) {\r\n    tslib_1.__extends(PathMarkupParser, _super);\r\n    function PathMarkupParser() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.e = '\\0';\r\n        _this.h = 0;\r\n        _this.l = { $type: Point_$type, x: 0, y: 0 };\r\n        _this.f = null;\r\n        _this.i = null;\r\n        return _this;\r\n    }\r\n    PathMarkupParser.prototype.k = function (a) {\r\n        this.f = new List$1(PathMarkupToken.$, 0);\r\n        this.h = 0;\r\n        var _loop_1 = function () {\r\n            switch (this_1.e) {\r\n                case 'M':\r\n                case 'm':\r\n                    this_1.f.add(new PathMarkupToken(0, this_1.e.charCodeAt(0) < 'm'.charCodeAt(0)));\r\n                    break;\r\n                case 'L':\r\n                case 'l':\r\n                    this_1.f.add(new PathMarkupToken(1, this_1.e.charCodeAt(0) < 'l'.charCodeAt(0)));\r\n                    break;\r\n                case 'H':\r\n                case 'h':\r\n                    this_1.f.add(new PathMarkupToken(2, this_1.e.charCodeAt(0) < 'h'.charCodeAt(0)));\r\n                    break;\r\n                case 'V':\r\n                case 'v':\r\n                    this_1.f.add(new PathMarkupToken(3, this_1.e.charCodeAt(0) < 'v'.charCodeAt(0)));\r\n                    break;\r\n                case 'C':\r\n                case 'c':\r\n                    this_1.f.add(new PathMarkupToken(4, this_1.e.charCodeAt(0) < 'c'.charCodeAt(0)));\r\n                    break;\r\n                case 'Q':\r\n                case 'q':\r\n                    this_1.f.add(new PathMarkupToken(5, this_1.e.charCodeAt(0) < 'q'.charCodeAt(0)));\r\n                    break;\r\n                case 'S':\r\n                case 's':\r\n                    this_1.f.add(new PathMarkupToken(6, this_1.e.charCodeAt(0) < 's'.charCodeAt(0)));\r\n                    break;\r\n                case 'T':\r\n                case 't':\r\n                    this_1.f.add(new PathMarkupToken(7, this_1.e.charCodeAt(0) < 't'.charCodeAt(0)));\r\n                    break;\r\n                case 'A':\r\n                case 'a':\r\n                    this_1.f.add(new PathMarkupToken(8, this_1.e.charCodeAt(0) < 'a'.charCodeAt(0)));\r\n                    break;\r\n                case 'Z':\r\n                case 'z':\r\n                    this_1.f.add(new PathMarkupToken(9, this_1.e.charCodeAt(0) < 'z'.charCodeAt(0)));\r\n                    break;\r\n            }\r\n            if (this_1.a(this_1.e)) {\r\n                var b = true;\r\n                var c = false;\r\n                var d = false;\r\n                var e_1 = stringEmpty();\r\n                var f = false;\r\n                this_1.h = this_1.h - 1;\r\n                while (this_1.h < a.length) {\r\n                    var g = a.charAt(this_1.h);\r\n                    if (d) {\r\n                        if (!this_1.a(g)) {\r\n                            f = true;\r\n                            break;\r\n                        }\r\n                        else {\r\n                            e_1 += g;\r\n                            this_1.h++;\r\n                            if (this_1.h >= a.length) {\r\n                                f = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (c) {\r\n                        if (g == 'e' || g == 'E') {\r\n                            d = true;\r\n                            e_1 += g;\r\n                            this_1.h++;\r\n                            continue;\r\n                        }\r\n                        if (!this_1.a(g)) {\r\n                            f = true;\r\n                            break;\r\n                        }\r\n                        else {\r\n                            e_1 += g;\r\n                            this_1.h++;\r\n                            if (this_1.h >= a.length) {\r\n                                f = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (b) {\r\n                        if (g == '.') {\r\n                            c = true;\r\n                            e_1 += g;\r\n                            this_1.h++;\r\n                            continue;\r\n                        }\r\n                        if (g == 'e' || g == 'E') {\r\n                            d = true;\r\n                            e_1 += g;\r\n                            this_1.h++;\r\n                            continue;\r\n                        }\r\n                        if (!this_1.a(g)) {\r\n                            f = true;\r\n                            break;\r\n                        }\r\n                        else {\r\n                            e_1 += g;\r\n                            this_1.h++;\r\n                            if (this_1.h >= a.length) {\r\n                                f = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (f) {\r\n                    this_1.f.add(((function () {\r\n                        var $ret = new PathMarkupToken(10, false);\r\n                        $ret.b = parseFloat(e_1);\r\n                        return $ret;\r\n                    })()));\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        while (this.d(a)) {\r\n            _loop_1();\r\n        }\r\n        return this.j();\r\n    };\r\n    PathMarkupParser.prototype.a = function (a) {\r\n        return a == '.' || a == '-' || a == '+' || (a.charCodeAt(0) >= '0'.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0));\r\n    };\r\n    PathMarkupParser.prototype.j = function () {\r\n        var _this = this;\r\n        this.h = 0;\r\n        var a = true;\r\n        var b = new PathGeometry();\r\n        var c = null;\r\n        var d = 11;\r\n        var e = null;\r\n        var f = null;\r\n        var g = null;\r\n        while (this.h < this.f.count) {\r\n            var h = this.f._inner[this.h++];\r\n            if (a && h.c != 0) {\r\n                return null;\r\n            }\r\n            switch (h.c) {\r\n                case 0:\r\n                    c = new PathFigure();\r\n                    b.c.add(c);\r\n                    this.l = this.m(h.a);\r\n                    c._startPoint = this.l;\r\n                    while (this.b()) {\r\n                        this.l = this.m(h.a);\r\n                        c._segments.add(new LineSegment(0, this.l));\r\n                    }\r\n                    d = 0;\r\n                    break;\r\n                case 1:\r\n                case 2:\r\n                case 3:\r\n                    if (c == null) {\r\n                        return null;\r\n                    }\r\n                    do {\r\n                        switch (h.c) {\r\n                            case 1:\r\n                                this.l = this.m(h.a);\r\n                                break;\r\n                            case 2:\r\n                                this.l.x = h.a ? this.g() : this.l.x + this.g();\r\n                                break;\r\n                            case 3:\r\n                                this.l.y = h.a ? this.g() : this.l.y + this.g();\r\n                                break;\r\n                        }\r\n                        c._segments.add(new LineSegment(0, this.l));\r\n                    } while (this.b());\r\n                    d = 1;\r\n                    break;\r\n                case 4:\r\n                case 6:\r\n                    if (c == null) {\r\n                        return null;\r\n                    }\r\n                    do {\r\n                        if (h.c == 6) {\r\n                            if (d == 4) {\r\n                                e = { $type: Point_$type, x: 2 * this.l.x - f.x, y: 2 * this.l.y - f.y };\r\n                            }\r\n                            else {\r\n                                e = this.l;\r\n                            }\r\n                        }\r\n                        else {\r\n                            e = this.m(h.a);\r\n                        }\r\n                        f = this.m(h.a);\r\n                        g = this.m(h.a);\r\n                        c._segments.add(new BezierSegment(1, e, f, g));\r\n                        this.l = g;\r\n                        d = 4;\r\n                    } while (this.b());\r\n                    break;\r\n                case 5:\r\n                case 7: break;\r\n                case 8:\r\n                    if (c == null) {\r\n                        return null;\r\n                    }\r\n                    var _loop_2 = function () {\r\n                        var i = this_2.g();\r\n                        var j = this_2.g();\r\n                        var k = this_2.g();\r\n                        var l = this_2.g();\r\n                        var m = this_2.g();\r\n                        this_2.l = this_2.m(h.a);\r\n                        c._segments.add(((function () {\r\n                            var $ret = new ArcSegment();\r\n                            $ret.e = _this.l;\r\n                            $ret.f = new Size(1, i, j);\r\n                            $ret.c = k;\r\n                            $ret.b = l == 1;\r\n                            $ret.d = m == 1 ? 1 : 0;\r\n                            return $ret;\r\n                        })()));\r\n                    };\r\n                    var this_2 = this;\r\n                    do {\r\n                        _loop_2();\r\n                    } while (this.b());\r\n                    d = 8;\r\n                    break;\r\n                case 9:\r\n                    if (c == null) {\r\n                        return null;\r\n                    }\r\n                    c._isClosed = true;\r\n                    break;\r\n            }\r\n            a = false;\r\n        }\r\n        return b;\r\n    };\r\n    PathMarkupParser.prototype.m = function (a) {\r\n        var b = this.g();\r\n        var c = this.g();\r\n        if (!a) {\r\n            b += this.l.x;\r\n            c += this.l.y;\r\n        }\r\n        return { $type: Point_$type, x: b, y: c };\r\n    };\r\n    PathMarkupParser.prototype.g = function () {\r\n        var a = this.f._inner[this.h++];\r\n        if (a.c != 10) {\r\n            throw new InvalidOperationException(0);\r\n        }\r\n        return a.b;\r\n    };\r\n    PathMarkupParser.prototype.b = function () {\r\n        if (this.h >= this.f.count) {\r\n            return false;\r\n        }\r\n        return this.f._inner[this.h].c == 10;\r\n    };\r\n    PathMarkupParser.prototype.d = function (a) {\r\n        while (this.h < a.length && this.c(a.charAt(this.h))) {\r\n            this.h++;\r\n        }\r\n        if (this.h < a.length) {\r\n            this.e = a.charAt(this.h);\r\n            this.h++;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    PathMarkupParser.prototype.c = function (a) {\r\n        return a == '\\r' || a == '\\n' || a == ' ' || a == '\\t';\r\n    };\r\n    PathMarkupParser.$t = markType(PathMarkupParser, 'PathMarkupParser');\r\n    return PathMarkupParser;\r\n}(Base));\r\nexport { PathMarkupParser };\r\n//# sourceMappingURL=Geometry_combined.js.map\r\n"]},"metadata":{},"sourceType":"module"}
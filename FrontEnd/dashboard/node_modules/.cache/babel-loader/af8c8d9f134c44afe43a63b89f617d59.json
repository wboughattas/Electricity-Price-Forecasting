{"ast":null,"code":"/*\r\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\r\nhttps://www.infragistics.com/legal/license/igultimate-la\r\nhttps://www.infragistics.com/legal/license/igultimate-eula\r\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\r\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, Point_$type, markType } from \"igniteui-react-core\";\nimport { List$1 } from \"igniteui-react-core\";\nimport { GeometryUtil } from \"igniteui-react-core\";\nimport { PolyLineSegment } from \"igniteui-react-core\";\nimport { ArcSegment } from \"igniteui-react-core\";\nimport { Size } from \"igniteui-react-core\";\nimport { InterpolationUtil } from \"igniteui-react-core\";\n/**\r\n * @hidden\r\n */\n\nvar MorphSegment =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(MorphSegment, _super);\n\n  function MorphSegment() {\n    var _this = _super.call(this) || this;\n\n    _this.f = null;\n    _this.g = null;\n    _this.b = false;\n    _this.h = 0;\n    _this.e = false;\n    _this.a = false;\n    _this.d = false;\n    _this.c = false;\n    _this.f = new List$1(Point_$type, 0);\n    _this.g = new List$1(Point_$type, 0);\n    return _this;\n  }\n\n  MorphSegment.prototype.i = function (a) {\n    this.g.clear();\n    var b = 20;\n\n    if (this.b) {\n      var c = void 0;\n      var d = void 0;\n      var e = void 0;\n\n      if (this.f.count == 0) {\n        d = {\n          $type: Point_$type,\n          x: 0,\n          y: 0\n        };\n        e = {\n          $type: Point_$type,\n          x: 0,\n          y: 0\n        };\n      } else {\n        d = this.f._inner[0];\n        e = this.f._inner[1];\n      }\n\n      var f = GeometryUtil.l(d, e, this.h, !this.c, this.d);\n      var g = GeometryUtil.e(f, d);\n      var h = GeometryUtil.e(f, e);\n\n      while (this.c && h < g) {\n        h += Math.PI * 2;\n      }\n\n      while (!this.c && h > g) {\n        h -= Math.PI * 2;\n      }\n\n      var i = 0;\n\n      for (var j = 0; j < b; j++) {\n        c = j / b;\n\n        if (this.c) {\n          i = g + (h - g) * c;\n        } else {\n          i = g - (g - h) * c;\n        }\n\n        this.g.add({\n          $type: Point_$type,\n          x: f.x + Math.cos(i) * this.h,\n          y: f.y + Math.sin(i) * this.h\n        });\n      }\n    } else {\n      var k = void 0;\n      var l = void 0;\n      var m = void 0;\n\n      if (this.f.count == 0) {\n        l = {\n          $type: Point_$type,\n          x: 0,\n          y: 0\n        };\n        m = {\n          $type: Point_$type,\n          x: 0,\n          y: 0\n        };\n      } else {\n        l = this.f._inner[0];\n        m = this.f._inner[1];\n      }\n\n      var n = l.x;\n      var o = l.y;\n      var p = m.x;\n      var q = m.y;\n\n      for (var r = 0; r < b; r++) {\n        k = r / b;\n        this.g.add({\n          $type: Point_$type,\n          x: n + (p - n) * k,\n          y: o + (q - o) * k\n        });\n      }\n    }\n\n    this.a = true;\n  };\n\n  MorphSegment.prototype.l = function (a, b, c, d, e) {\n    var f = this;\n    var g = null;\n    var h = f.f;\n    var i = h.count;\n\n    if (i == 0) {\n      return a;\n    }\n\n    if (b._segments.count == 0) {\n      var j = h._inner[0];\n      b._startPoint = {\n        $type: Point_$type,\n        x: d + c * j.x,\n        y: e + c * j.y\n      };\n    }\n\n    if (f.b) {\n      if (i > 1) {\n        var k = new ArcSegment();\n        g = k;\n        var l = h._inner[1];\n        k.e = {\n          $type: Point_$type,\n          x: d + c * l.x,\n          y: e + c * l.y\n        };\n        k.b = f.d;\n        k.d = f.c ? 1 : 0;\n        k.f = new Size(1, f.h * c, f.h * c);\n        a = k.e;\n      }\n    } else {\n      var m = new PolyLineSegment();\n      g = m;\n\n      if (i > 1) {\n        var n = void 0;\n        var o = m._points;\n\n        for (var p = 1; p < i; p++) {\n          n = h._inner[p];\n          o.add({\n            $type: Point_$type,\n            x: d + c * n.x,\n            y: e + c * n.y\n          });\n        }\n\n        a = m._points._inner[m._points.count - 1];\n      }\n    }\n\n    b._segments.add(g);\n\n    return a;\n  };\n\n  MorphSegment.prototype.j = function (a, b, c) {\n    var d = this;\n    var e = b.f;\n    var f = false;\n    var g = c.f;\n    var h = false;\n\n    if (e.count == 0 && g.count == 0) {\n      return;\n    }\n\n    d.b = false;\n    d.e = false;\n    d.a = false;\n    d.d = false;\n    d.c = false;\n\n    if (b.e) {\n      f = true;\n    }\n\n    if (c.e) {\n      h = true;\n    }\n\n    if (b.b != c.b || b.e || c.e || b.d != c.d || b.c != c.c) {\n      f = true;\n      h = true;\n      d.e = true;\n    }\n\n    if (f && !b.e) {\n      if (!b.a) {\n        b.i(c.h);\n      }\n\n      e = b.g;\n    }\n\n    if (h && !c.e) {\n      if (!c.a) {\n        c.i(b.h);\n      }\n\n      g = c.g;\n    }\n\n    if (b.e) {\n      e = b.g;\n    }\n\n    if (c.e) {\n      g = c.g;\n    }\n\n    d.g.clear();\n\n    if (b.b && c.b) {\n      d.b = true;\n    }\n\n    InterpolationUtil.b(d.f, a, e, g);\n\n    if (d.e) {\n      var i = void 0;\n      var j = d.f.count;\n\n      for (var k = 0; k < j; k++) {\n        i = d.f._inner[k];\n        d.g.add({\n          $type: Point_$type,\n          x: i.x,\n          y: i.y\n        });\n      }\n\n      d.a = true;\n    }\n\n    if (b.d == c.d) {\n      d.d = c.d;\n    }\n\n    if (b.c == c.c) {\n      d.c = c.c;\n    }\n\n    if (d.b) {\n      d.h = b.h + (c.h - b.h) * a;\n    }\n  };\n\n  MorphSegment.prototype.k = function () {\n    this.f.clear();\n    this.g.clear();\n    this.e = false;\n    this.a = false;\n    this.b = false;\n  };\n\n  MorphSegment.$t = markType(MorphSegment, 'MorphSegment');\n  return MorphSegment;\n}(Base);\n\nexport { MorphSegment };","map":{"version":3,"sources":["../../../../src/igniteui-gauges/lib/MorphSegment.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\r\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\r\nhttps://www.infragistics.com/legal/license/igultimate-la\r\nhttps://www.infragistics.com/legal/license/igultimate-eula\r\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\r\n*/\r\nimport * as tslib_1 from \"tslib\";\r\nimport { Base, Point_$type, markType } from \"igniteui-react-core\";\r\nimport { List$1 } from \"igniteui-react-core\";\r\nimport { GeometryUtil } from \"igniteui-react-core\";\r\nimport { PolyLineSegment } from \"igniteui-react-core\";\r\nimport { ArcSegment } from \"igniteui-react-core\";\r\nimport { Size } from \"igniteui-react-core\";\r\nimport { InterpolationUtil } from \"igniteui-react-core\";\r\n/**\r\n * @hidden\r\n */\r\nvar MorphSegment = /** @class */ /*@__PURE__*/ (function (_super) {\r\n    tslib_1.__extends(MorphSegment, _super);\r\n    function MorphSegment() {\r\n        var _this = _super.call(this) || this;\r\n        _this.f = null;\r\n        _this.g = null;\r\n        _this.b = false;\r\n        _this.h = 0;\r\n        _this.e = false;\r\n        _this.a = false;\r\n        _this.d = false;\r\n        _this.c = false;\r\n        _this.f = new List$1(Point_$type, 0);\r\n        _this.g = new List$1(Point_$type, 0);\r\n        return _this;\r\n    }\r\n    MorphSegment.prototype.i = function (a) {\r\n        this.g.clear();\r\n        var b = 20;\r\n        if (this.b) {\r\n            var c = void 0;\r\n            var d = void 0;\r\n            var e = void 0;\r\n            if (this.f.count == 0) {\r\n                d = { $type: Point_$type, x: 0, y: 0 };\r\n                e = { $type: Point_$type, x: 0, y: 0 };\r\n            }\r\n            else {\r\n                d = this.f._inner[0];\r\n                e = this.f._inner[1];\r\n            }\r\n            var f = GeometryUtil.l(d, e, this.h, !this.c, this.d);\r\n            var g = GeometryUtil.e(f, d);\r\n            var h = GeometryUtil.e(f, e);\r\n            while (this.c && h < g) {\r\n                h += Math.PI * 2;\r\n            }\r\n            while (!this.c && h > g) {\r\n                h -= Math.PI * 2;\r\n            }\r\n            var i = 0;\r\n            for (var j = 0; j < b; j++) {\r\n                c = j / b;\r\n                if (this.c) {\r\n                    i = g + (h - g) * c;\r\n                }\r\n                else {\r\n                    i = g - (g - h) * c;\r\n                }\r\n                this.g.add({ $type: Point_$type, x: f.x + Math.cos(i) * this.h, y: f.y + Math.sin(i) * this.h });\r\n            }\r\n        }\r\n        else {\r\n            var k = void 0;\r\n            var l = void 0;\r\n            var m = void 0;\r\n            if (this.f.count == 0) {\r\n                l = { $type: Point_$type, x: 0, y: 0 };\r\n                m = { $type: Point_$type, x: 0, y: 0 };\r\n            }\r\n            else {\r\n                l = this.f._inner[0];\r\n                m = this.f._inner[1];\r\n            }\r\n            var n = l.x;\r\n            var o = l.y;\r\n            var p = m.x;\r\n            var q = m.y;\r\n            for (var r = 0; r < b; r++) {\r\n                k = r / b;\r\n                this.g.add({ $type: Point_$type, x: n + (p - n) * k, y: o + (q - o) * k });\r\n            }\r\n        }\r\n        this.a = true;\r\n    };\r\n    MorphSegment.prototype.l = function (a, b, c, d, e) {\r\n        var f = this;\r\n        var g = null;\r\n        var h = f.f;\r\n        var i = h.count;\r\n        if (i == 0) {\r\n            return a;\r\n        }\r\n        if (b._segments.count == 0) {\r\n            var j = h._inner[0];\r\n            b._startPoint = { $type: Point_$type, x: d + c * j.x, y: e + c * j.y };\r\n        }\r\n        if (f.b) {\r\n            if (i > 1) {\r\n                var k = new ArcSegment();\r\n                g = k;\r\n                var l = h._inner[1];\r\n                k.e = { $type: Point_$type, x: d + c * l.x, y: e + c * l.y };\r\n                k.b = f.d;\r\n                k.d = f.c ? 1 : 0;\r\n                k.f = new Size(1, f.h * c, f.h * c);\r\n                a = k.e;\r\n            }\r\n        }\r\n        else {\r\n            var m = new PolyLineSegment();\r\n            g = m;\r\n            if (i > 1) {\r\n                var n = void 0;\r\n                var o = m._points;\r\n                for (var p = 1; p < i; p++) {\r\n                    n = h._inner[p];\r\n                    o.add({ $type: Point_$type, x: d + c * n.x, y: e + c * n.y });\r\n                }\r\n                a = m._points._inner[m._points.count - 1];\r\n            }\r\n        }\r\n        b._segments.add(g);\r\n        return a;\r\n    };\r\n    MorphSegment.prototype.j = function (a, b, c) {\r\n        var d = this;\r\n        var e = b.f;\r\n        var f = false;\r\n        var g = c.f;\r\n        var h = false;\r\n        if (e.count == 0 && g.count == 0) {\r\n            return;\r\n        }\r\n        d.b = false;\r\n        d.e = false;\r\n        d.a = false;\r\n        d.d = false;\r\n        d.c = false;\r\n        if (b.e) {\r\n            f = true;\r\n        }\r\n        if (c.e) {\r\n            h = true;\r\n        }\r\n        if (b.b != c.b || b.e || c.e || b.d != c.d || b.c != c.c) {\r\n            f = true;\r\n            h = true;\r\n            d.e = true;\r\n        }\r\n        if (f && !b.e) {\r\n            if (!b.a) {\r\n                b.i(c.h);\r\n            }\r\n            e = b.g;\r\n        }\r\n        if (h && !c.e) {\r\n            if (!c.a) {\r\n                c.i(b.h);\r\n            }\r\n            g = c.g;\r\n        }\r\n        if (b.e) {\r\n            e = b.g;\r\n        }\r\n        if (c.e) {\r\n            g = c.g;\r\n        }\r\n        d.g.clear();\r\n        if (b.b && c.b) {\r\n            d.b = true;\r\n        }\r\n        InterpolationUtil.b(d.f, a, e, g);\r\n        if (d.e) {\r\n            var i = void 0;\r\n            var j = d.f.count;\r\n            for (var k = 0; k < j; k++) {\r\n                i = d.f._inner[k];\r\n                d.g.add({ $type: Point_$type, x: i.x, y: i.y });\r\n            }\r\n            d.a = true;\r\n        }\r\n        if (b.d == c.d) {\r\n            d.d = c.d;\r\n        }\r\n        if (b.c == c.c) {\r\n            d.c = c.c;\r\n        }\r\n        if (d.b) {\r\n            d.h = b.h + (c.h - b.h) * a;\r\n        }\r\n    };\r\n    MorphSegment.prototype.k = function () {\r\n        this.f.clear();\r\n        this.g.clear();\r\n        this.e = false;\r\n        this.a = false;\r\n        this.b = false;\r\n    };\r\n    MorphSegment.$t = markType(MorphSegment, 'MorphSegment');\r\n    return MorphSegment;\r\n}(Base));\r\nexport { MorphSegment };\r\n//# sourceMappingURL=MorphSegment.js.map\r\n"]},"metadata":{},"sourceType":"module"}
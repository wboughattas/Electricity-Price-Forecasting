{"ast":null,"code":"/*!\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nvar _typeIdentifierCache = {};\nvar _nextTypeIdentifier = 0; // interface Function {\n//     $type?: Type;\n// }\n\nexport function getInstanceType(obj) {\n  if (obj.$type) {\n    return obj.$type;\n  } else if (typeof obj === 'number') {\n    return Number_$type;\n  } else if (typeof obj === 'string') {\n    return String_$type;\n  } else if (typeof obj === 'boolean') {\n    return Boolean_$type;\n  } else if (obj instanceof Date) {\n    return Date_$type;\n  }\n\n  return Base.prototype.$type;\n}\n\nvar Base =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function Base() {}\n\n  Base.prototype.equals = function (other) {\n    return this === other;\n  };\n\n  Base.equalsStatic = function (a, b) {\n    var aIsNull = a == null || !!a.isNullable && !a.hasValue;\n    var bIsNull = b == null || !!b.isNullable && !b.hasValue;\n\n    if (aIsNull || bIsNull) {\n      return aIsNull && bIsNull;\n    }\n\n    if (a.equals) {\n      return a.equals(b);\n    }\n\n    if (b.equals) {\n      return b.equals(a);\n    }\n\n    if (Number.isNaN(a) && Number.isNaN(b)) {\n      return true;\n    }\n\n    if (a instanceof Date) {\n      return b instanceof Date && +a === +b;\n    }\n\n    return a == b && typeof a == typeof b;\n  };\n\n  Base.equalsSimple = function (item1, item2) {\n    return item1 == item2;\n  };\n\n  ;\n\n  Base.compareSimple = function (item1, item2) {\n    if (item1 == item2) {\n      return 0;\n    }\n\n    if (item1 < item2) {\n      return -1;\n    }\n\n    return 1;\n  };\n\n  ;\n\n  Base.compare = function (item1, item2) {\n    if (item1 === item2) {\n      return 0;\n    }\n\n    var xComparable = typeCast(IComparable_$type, item1);\n\n    if (xComparable !== null && xComparable.compareToObject) {\n      return xComparable.compareToObject(item2);\n    }\n\n    var yComparable = typeCast(IComparable_$type, item2);\n\n    if (yComparable !== null && yComparable.compareToObject) {\n      return -yComparable.compareToObject(item1);\n    }\n\n    return Base.compareSimple(item1, item2);\n  };\n\n  ;\n\n  Base.prototype.getHashCode = function () {\n    if (this.$hashCode === undefined) {\n      this.$hashCode = Base.nextHashCode++;\n    }\n\n    return this.$hashCode;\n  };\n\n  Base.getHashCodeStatic = function (obj) {\n    if (obj.getHashCode) {\n      return obj.getHashCode();\n    }\n\n    if (obj.$hashCode !== undefined) {\n      return obj.$hashCode;\n    }\n\n    if (!(typeof obj == \"object\")) {\n      return Type.getPrimitiveHashCode(obj);\n    } else {\n      obj.$hashCode = Base.nextHashCode++;\n      return obj.$hashCode;\n    }\n  };\n\n  Base.prototype.memberwiseClone = function () {\n    var clone;\n\n    try {\n      clone = Object.create(this.$type.InstanceConstructor.prototype);\n    } catch (e) {\n      var Cons =\n      /** @class */\n\n      /*@__PURE__*/\n      function () {\n        function Cons() {}\n\n        return Cons;\n      }();\n\n      Cons.prototype = this.$type.InstanceConstructor.prototype;\n      clone = new Cons();\n    }\n\n    for (var prop in this) {\n      if (this.hasOwnProperty(prop)) {\n        clone[prop] = this[prop];\n      }\n    }\n\n    return clone;\n  };\n\n  Base.referenceEquals = function (a, b) {\n    return a === b || a == null && b == null;\n  };\n\n  Base.getArrayOfValues = function (obj) {\n    var result = [];\n\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  };\n\n  Base.getArrayOfProperties = function (obj) {\n    var result = [];\n\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        result.push(i);\n      }\n    }\n\n    return result;\n  };\n\n  ;\n  Base.nextHashCode = 0;\n  return Base;\n}();\n\nexport { Base };\n\nvar Type =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(Type, _super);\n\n  function Type(instanceConstructor, identifier, baseType, interfaces, staticInitializer) {\n    if (baseType === void 0) {\n      baseType = Base.prototype.$type;\n    }\n\n    if (interfaces === void 0) {\n      interfaces = null;\n    }\n\n    if (staticInitializer === void 0) {\n      staticInitializer = null;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.specializationCache = null;\n    _this._staticInitializer = null;\n    _this.name = null;\n    _this.typeArguments = null;\n    _this.baseType = null;\n    _this.interfaces = null;\n    _this.isEnumType = false;\n    _this._isGenericType = undefined;\n    _this._staticFields = null;\n    _this.isNullable = false;\n    _this._$nullNullable = null;\n    _this.enumInfo = null;\n    _this.specializationCache = {};\n    _this._staticInitializer = staticInitializer;\n    _this._fullName = identifier;\n    _this.name = identifier;\n    _this.InstanceConstructor = instanceConstructor;\n\n    var lastDotIndex = _this.name.lastIndexOf(\".\");\n\n    if (lastDotIndex >= 0) {\n      _this.name = _this.name.substr(lastDotIndex + 1);\n    }\n\n    _this.typeArguments = null;\n    _this.baseType = null;\n    _this.interfaces = null;\n\n    if (baseType) {\n      _this.baseType = baseType;\n    }\n\n    if (interfaces) {\n      _this.interfaces = interfaces;\n    }\n\n    if (_typeIdentifierCache[identifier]) {\n      _this.identifier = _typeIdentifierCache[identifier];\n    } else {\n      _this.identifier = _nextTypeIdentifier++;\n      _typeIdentifierCache[identifier] = _this.identifier;\n    }\n\n    return _this; // rather than always evaluating a function on a type to see if it is an enum\n    // we can just cache it once on the type\n    // if (baseType && Enum && baseType == Enum.prototype.$type) {\n    //     this.isEnumType = true;\n    // }\n  }\n\n  Object.defineProperty(Type.prototype, \"typeName\", {\n    get: function () {\n      return this.name;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Type.prototype, \"fullName\", {\n    get: function () {\n      return this._fullName;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Type.prototype.getSpecId = function (types) {\n    if (types.length === 1) {\n      if (!types[0]) {\n        return \"undef\";\n      } else if (types[0] === -1) {\n        return undefined;\n      } else if (!types[0].typeName) {\n        return types[0].toString();\n      } else if (types[0].stringId) {\n        return types[0].stringId;\n      } else {\n        return types[0].identifier.toString();\n      }\n    }\n\n    var ret = \"\";\n\n    for (var i = 0; i < types.length; i++) {\n      var type = types[i];\n\n      if (!type) {\n        ret += \"undef\";\n      } else if (type == -1) {\n        return undefined;\n      } else if (!type.typeName) {\n        ret += type.toString();\n      } else if (type.stringId) {\n        ret += type.stringId;\n      } else {\n        ret += type.identifier.toString();\n      }\n    }\n\n    return ret;\n  };\n\n  Object.defineProperty(Type.prototype, \"isGenericType\", {\n    get: function () {\n      if (this._isGenericType === undefined) {\n        this._isGenericType = this.name.indexOf(\"$\") >= 0;\n      }\n\n      return this._isGenericType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Type.prototype, \"isGenericTypeDefinition\", {\n    get: function () {\n      return this.typeArguments === null && this.isGenericType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Type.prototype, \"genericTypeArguments\", {\n    get: function () {\n      return this.typeArguments;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Type.prototype.getStaticFields = function (type) {\n    if (type === undefined) {\n      type = this;\n    }\n\n    var t = this;\n\n    while (t != null) {\n      if (t === type || t._fullName == type._fullName) {\n        if (t._staticFields == null && t._staticInitializer) {\n          t._staticFields = {};\n\n          t._staticInitializer.apply(t._staticFields, t.typeArguments);\n        }\n\n        return t._staticFields;\n      }\n\n      t = t.baseType;\n    }\n\n    return null;\n  };\n\n  Type.prototype.initSelfReferences = function (replacement) {\n    var i, j;\n\n    if (replacement) {\n      if (this.typeArguments) {\n        var updateCache = false;\n\n        for (j = 0; j < this.typeArguments.length; j++) {\n          var typeArg = this.typeArguments[j];\n\n          if (typeArg == -1) {\n            updateCache = true;\n            this.typeArguments[j] = replacement;\n          } else if (typeArg && typeArg instanceof Type && typeArg.initSelfReferences) {\n            typeArg.initSelfReferences(replacement);\n          }\n        }\n\n        if (updateCache) {\n          var specId = this.getSpecId(this.typeArguments);\n          var ret = this.specializationCache[specId];\n\n          if (!ret) {\n            this.specializationCache[specId] = this;\n          }\n        }\n      }\n    } else {\n      if (this.baseType) {\n        this.baseType.initSelfReferences(this);\n      }\n\n      if (this.interfaces) {\n        for (i = 0; i < this.interfaces.length; i++) {\n          this.interfaces[i].initSelfReferences(this);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  Type.prototype.specialize = function () {\n    var rest = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      rest[_i] = arguments[_i];\n    }\n\n    var i;\n\n    if (!this.isGenericType) {\n      return this;\n    }\n\n    var specId = this.getSpecId(Array.from(arguments));\n    var ret = this.specializationCache[specId];\n\n    if (ret) {\n      return ret;\n    }\n\n    ret = new Type(this.InstanceConstructor, this._fullName, this.baseType, this.interfaces, this._staticInitializer);\n    ret.specializationCache = this.specializationCache;\n    var placeholders = this.typeArguments;\n    var hasPlaceholders = false; // Make sure the placeholders are actually numbers. If they are types, we are re-specializing an\n    // already specialized type.\n\n    if (placeholders && placeholders.length) {\n      /* going back to how it used to be. we shouldn't assume that the number/order of the arguments\n          relates to the typearguments. this may be an interface that has its type information already\n          and either has placeholders or is a closed type\n      // you can have a mixed bag where some are placeholders and others are not and the\n      // placeholder doesn't have to be the first slot\n      for (i = 0; i < placeholders.length; i++) {\n          if (isFinite(placeholders[ i ])) {\n              hasPlaceholders = true;\n              break;\n          }\n      }*/\n      hasPlaceholders = true;\n    }\n\n    ret.typeArguments = [];\n\n    if (hasPlaceholders) {\n      for (i = 0; i < placeholders.length; i++) {\n        // if the argument being provided is a placeholder index and we already have\n        // a placeholder then keep the index we have. otherwise we're taking the index\n        // of the parent type\n        if (typeof placeholders[i] === \"number\" && isFinite(placeholders[i]) && !isFinite(arguments[placeholders[i]])) {\n          ret.typeArguments[i] = arguments[placeholders[i]];\n        } else {\n          ret.typeArguments[i] = placeholders[i];\n        }\n      }\n    } else {\n      for (i = 0; i < arguments.length; i++) {\n        ret.typeArguments[i] = arguments[i];\n      }\n    } // since the placeholder indexes for the basetype and interfaces implemented are based\n    // on the order of the type arguments for the defining types we should pass its typeargs\n    // and not the outermost type's type arguments which may be different in number and order\n    // than the base type of the base types and interfaces implemented\n\n\n    if (this.baseType && this.baseType.typeArguments) {\n      ret.baseType = this.specialize.apply(this.baseType, ret.typeArguments);\n    }\n\n    if (this.interfaces) {\n      ret.interfaces = [];\n\n      for (i = 0; i < this.interfaces.length; i++) {\n        ret.interfaces[i] = this.specialize.apply(this.interfaces[i], ret.typeArguments);\n      }\n    } // rather than doing this check in various places we could just cache a field on the type\n\n\n    if (this._fullName == \"Nullable$1\" && ret.typeArguments.length == 1) {\n      ret.isNullable = true;\n    } // if this was a self referencing type (e.g. IEquatable<Int32> for Int32 then we won't have the\n    // specId yet because we don't know the type argument. we'll update the cache when we update\n    // the self references. otherwise other types that use self references (but for a different type)\n    // will get and use the wrong type arguments\n\n\n    if (specId) {\n      this.specializationCache[specId] = ret;\n      ret.stringId = ret.generateString();\n    } else {// the self referencing type needs to be able to put itself into the specialization cache\n      // of the original type\n      //ret.specializationCache = this.specializationCache;\n    }\n\n    if (this.InstanceConstructor != null) {\n      var _self = this;\n\n      ret.InstanceConstructor = function () {\n        _self.InstanceConstructor.apply(this, ret.typeArguments.concat(Array.prototype.slice.call(arguments, 0)));\n\n        return this;\n      };\n\n      ret.InstanceConstructor.prototype = this.InstanceConstructor.prototype;\n    }\n\n    return ret;\n  };\n\n  Type.prototype.equals = function (other) {\n    if (!(other instanceof Type)) {\n      return false;\n    }\n\n    if (this.identifier !== other.identifier) {\n      return false;\n    }\n\n    if (this.typeArguments === null && other.typeArguments === null) {\n      return true;\n    }\n\n    if (this.typeArguments === null && other.typeArguments !== null) {\n      return false;\n    }\n\n    if (this.typeArguments !== null && other.typeArguments === null) {\n      return false;\n    }\n\n    if (this.typeArguments.length !== other.typeArguments.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.typeArguments.length; i++) {\n      //TODO: handle covariance case here.\n      //if (!$.ig.util.canAssign(this.typeArguments[ i ], other.typeArguments[ i ])) {\n      //    return false;\n      //}\n      if (!Type.checkEquals(this.typeArguments[i], other.typeArguments[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Type.checkEquals = function (type1, type2) {\n    if (type1 instanceof Type) {\n      return type1.equals(type2);\n    } else if (type2 instanceof Type) {\n      return type2.equals(type1);\n    } else {\n      return type1 === type2;\n    }\n  };\n\n  Type.op_Equality = function (type1, type2) {\n    return type1.equals(type2);\n  };\n\n  Type.op_Inequality = function (type1, type2) {\n    return !type1.equals(type2);\n  };\n\n  Type.prototype.generateString = function () {\n    if (!this.typeArguments || !this.typeArguments.length) {\n      return this.identifier.toString();\n    } else {\n      var ret = this.identifier.toString() + \"[\";\n      var first = true;\n\n      for (var i = 0; i < this.typeArguments.length; i++) {\n        if (this.typeArguments[i] == undefined) {\n          continue;\n        }\n\n        if (first) {\n          first = false;\n        } else {\n          ret += \",\";\n        }\n\n        if (this.typeArguments[i].toString) {\n          ret += this.typeArguments[i].toString();\n        } else {\n          ret += this.typeArguments[i].identifier.toString();\n        }\n      }\n\n      ret += \"]\";\n      return ret;\n    }\n  };\n\n  Object.defineProperty(Type.prototype, \"isValueType\", {\n    get: function () {\n      return this.baseType === ValueType.prototype.$type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Type.prototype.isAssignableFrom = function (tOther) {\n    // TODO: Unit test and make sure this is right (especially with generics\n    if (this === tOther) {\n      return true;\n    }\n\n    if (tOther.baseType && this.isAssignableFrom(tOther.baseType)) {\n      return true;\n    }\n\n    if (tOther.interfaces) {\n      for (var i = 0; i < tOther.interfaces.length; i++) {\n        if (this.isAssignableFrom(tOther.interfaces[i])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Type.prototype.isInstanceOfType = function (value) {\n    return typeCast(this, value) !== null;\n  };\n\n  Object.defineProperty(Type.prototype, \"isPrimitive\", {\n    get: function () {\n      return this === Number_$type || this === Boolean_$type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Type.canAssign = function (targetType, type) {\n    if (targetType.name === 'Nullable$1' && type.name !== 'Nullable$1') {\n      targetType = Nullable.getUnderlyingType(targetType);\n    }\n\n    return Type.canAssignSimple(targetType, type);\n  };\n\n  Type.canAssignSimple = function (targetType, type) {\n    if (targetType === type || Type.checkEquals(targetType, type)) {\n      return true;\n    }\n\n    if (type.interfaces) {\n      for (var i = 0; i < type.interfaces.length; i++) {\n        if (Type.canAssignSimple(targetType, type.interfaces[i])) {\n          return true;\n        }\n      }\n    }\n\n    if (type.baseType) {\n      return Type.canAssignSimple(targetType, type.baseType);\n    }\n\n    return false;\n  };\n\n  Type.createInstance = function ($t) {\n    if ($t === Number || $t == Number_$type || $t.isEnumType) {\n      return 0;\n    }\n\n    if ($t == Boolean || $t == Boolean_$type) {\n      return false;\n    }\n\n    if ($t.InstanceConstructor) {\n      var result; //result = Object.create((<Type>$t).InstanceConstructor.prototype);\n\n      var C = $t.InstanceConstructor; //(<Type>$t).InstanceConstructor.apply(result, Array.prototype.slice.call(arguments, 1));\n\n      result = new (C.bind.apply(C, tslib_1.__spread([void 0], Array.prototype.slice.call(arguments, 1))))();\n      return result;\n    }\n\n    throw new Error(\"Cannot find instance constructor for the type parameter\");\n  };\n\n  ;\n\n  Type.getDefaultValue = function ($t) {\n    if ($t === Number_$type || $t.isEnumType) {\n      return 0;\n    }\n\n    if ($t == Boolean_$type) {\n      return false;\n    }\n\n    if ($t.baseType === ValueType.$type) {\n      return Type.createInstance($t);\n    }\n\n    return null;\n  };\n\n  ;\n\n  Type.getPrimitiveHashCode = function (v) {\n    var val = typeof v;\n\n    if (val === \"string\" || v instanceof String) {\n      var hash = 0,\n          i,\n          chr,\n          len;\n\n      if (v.length === 0) {\n        return hash;\n      }\n\n      for (i = 0, len = this.length; i < len; i++) {\n        chr = v.charCodeAt(i);\n        /*jslint bitwise: true */\n\n        hash = (hash << 5) - hash + chr;\n        hash |= 0; // Convert to 32bit integer\n      }\n\n      return hash;\n    } else if (val === \"boolean\" || v instanceof Boolean) {\n      return +v;\n    } else {\n      return v;\n    }\n  }; // static mark(t: Function, name: string,\n  //     baseType: Type = Base.prototype.$type, \n  //     interfaces: Type[] = null, \n  //     staticInitializer: () => void = null) {\n  //     t.prototype.$type = new Type(t, name, baseType, interfaces, staticInitializer);\n  //     (<any>t).$type = t.prototype.$type;\n  // }\n\n\n  Type.decodePropType = function (val) {\n    if (val === 0) {\n      return Boolean_$type;\n    } else if (val === 1) {\n      return Number_$type;\n    } else if (val === 2) {\n      return String_$type;\n    } else if (val === 3) {\n      return Date_$type;\n    } else {\n      return val;\n    }\n  };\n\n  return Type;\n}(Base);\n\nexport { Type };\nexport function markDep(depProp, PropMeta, t, changedFunction, props) {\n  var names = [];\n  var currName = \"\";\n  var currOpts = [];\n  var hasDefaultValue = false;\n  var defaultValue = null;\n  var propType = null;\n  var changeHandler = null;\n  var setterFunc = null;\n  var getterFunc = null;\n  var aliasName = null;\n  var propertyAlias = null;\n\n  var _loop_1 = function () {\n    if (i % 2 == 0) {\n      currName = props[i];\n\n      if (currName.indexOf(\":\") >= 0) {\n        var parts = currName.split(':');\n\n        if (parts.length == 2) {\n          currName = parts[0];\n          aliasName = parts[1];\n          propertyAlias = currName.substring(0, 1).toLowerCase() + currName.substring(1) + \"Property\";\n        } else {\n          currName = parts[0];\n          aliasName = parts[1];\n\n          if (aliasName.length == 0) {\n            aliasName = currName.substring(0, 1).toLowerCase() + currName.substring(1);\n          }\n\n          propertyAlias = parts[2];\n        }\n      } else {\n        aliasName = currName.substring(0, 1).toLowerCase() + currName.substring(1);\n        propertyAlias = aliasName + \"Property\";\n      }\n\n      names.push(currName);\n    } else {\n      currOpts = props[i];\n\n      if (currOpts.length == 2) {\n        hasDefaultValue = true;\n        defaultValue = currOpts[1];\n        propType = Type.decodePropType(currOpts[0]);\n      } else {\n        hasDefaultValue = false;\n        propType = Type.decodePropType(currOpts[0]);\n      }\n\n      var changedName_1 = currName;\n\n      changeHandler = function (o, a) {\n        o[changedFunction].call(o, changedName_1, a.oldValue, a.newValue);\n      };\n\n      var meta = null;\n\n      if (hasDefaultValue) {\n        meta = PropMeta.createWithDefaultAndCallback(defaultValue, changeHandler);\n      } else {\n        meta = PropMeta.createWithCallback(changeHandler);\n      }\n\n      var dp_1 = depProp.registerAlt(currName, propType, t.$type, meta);\n\n      setterFunc = function (v) {\n        this.setValueAlt(dp_1, v);\n      };\n\n      if (propType.isEnumType) {\n        getterFunc = function () {\n          return typeGetValue(this.getValueAlt(dp_1));\n        };\n      } else {\n        getterFunc = function () {\n          return this.getValueAlt(dp_1);\n        };\n      }\n\n      Object.defineProperty(t.prototype, aliasName, {\n        set: setterFunc,\n        get: getterFunc,\n        configurable: true\n      });\n      t[propertyAlias] = dp_1;\n    }\n  }; //debugger;\n\n\n  for (var i = 0; i < props.length; i++) {\n    _loop_1();\n  } // let superClass = (<any>t).$type.baseType;\n  // if (superClass !== null && superClass !== undefined) {\n  //     let superNames = superClass.InstanceConstructor.$$p;\n  //     if (superNames) {\n  //         for (var j = superNames.length - 1; j >= 0; j--) {\n  //             names.unshift(superNames[j]);\n  //         }\n  //     }\n  // }\n  //(<any>t).$$p = names;\n\n\n  return names;\n}\nexport function typeGetValue(v) {\n  if (v !== null && v.$type && v.$type.isEnumType) {\n    return v.value;\n  }\n\n  return v;\n}\nexport function typeCast(targetType, obj) {\n  if (obj === undefined || obj === null) {\n    return null;\n  }\n\n  if (targetType === Array) {\n    return obj instanceof Array ? obj : null;\n  }\n\n  if (targetType === String) {\n    targetType = String_$type;\n  }\n\n  if (targetType === Number) {\n    targetType = Number_$type;\n  }\n\n  if (targetType === Boolean) {\n    targetType = Boolean_$type;\n  }\n\n  if (targetType === Date) {\n    targetType = Date_$type;\n  }\n\n  var type = obj;\n\n  if (obj.$type) {\n    type = obj.$type;\n  } else if (typeof obj === 'number') {\n    type = targetType === Number ? Number : Number_$type;\n  } else if (typeof obj === 'string') {\n    type = String_$type;\n  } else if (typeof obj === 'boolean') {\n    type = Boolean_$type;\n  } else if (obj instanceof Date) {\n    type = Date_$type;\n  } else if (obj instanceof Array) {\n    type = Array_$type;\n  }\n\n  if (Type.canAssignSimple(targetType, type)) {\n    return obj;\n  }\n\n  if (targetType.name === 'Nullable$1' && type.name !== 'Nullable$1') {\n    targetType = Nullable.getUnderlyingType(targetType);\n\n    if (Type.canAssignSimple(targetType, type)) {\n      return toNullable(targetType, obj);\n    }\n\n    return toNullable(targetType, null);\n  }\n\n  return null;\n}\nexport function typeCastObjTo$t($t, v) {\n  var shouldWrap = false;\n\n  if ($t.isNullable) {\n    $t = $t.typeArguments[0];\n    shouldWrap = true;\n  }\n\n  if (v !== null && $t.isEnumType) {\n    v = v.value;\n  }\n\n  return shouldWrap ? toNullable($t, v) : v;\n}\nvar pendingStaticCtors = /*@__PURE__*/new Array();\nexport function markStruct(t, name, baseType, interfaces, staticInitializer) {\n  if (baseType === void 0) {\n    baseType = ValueType.prototype.$type;\n  }\n\n  if (interfaces === void 0) {\n    interfaces = null;\n  }\n\n  if (staticInitializer === void 0) {\n    staticInitializer = null;\n  }\n\n  t.prototype.$type = new Type(t, name, baseType, interfaces, staticInitializer); //TODO: do we need/want a flag on the function like we have in js?\n\n  if (typeof t.staticInit === \"function\") {\n    pendingStaticCtors.push(t);\n  }\n\n  t.$type = t.prototype.$type;\n  t.$ = t.prototype.$type;\n  return t.prototype.$type;\n}\nexport function markEnum(name, encodedDef) {\n  var t = new Type(null, name, Base.prototype.$type, [IConvertible_$type]);\n  t.isEnumType = true;\n  var parts = encodedDef.split(\"|\");\n  var names = [];\n  var actualNames = [];\n  var namesValuesMap = {};\n  var actualNamesValuesMap = {};\n\n  for (var i = 0; i < parts.length; i++) {\n    var subParts = parts[i].split(\",\");\n    var nameParts = subParts[0].split(\":\");\n    var name_1 = nameParts[0];\n    var actualName = nameParts[0];\n\n    if (nameParts.length > 1) {\n      actualName = nameParts[1];\n    }\n\n    names.push(name_1);\n    actualNames.push(actualName); //TODO: did we support string enums??\n\n    namesValuesMap[name_1] = parseInt(subParts[1]);\n    actualNamesValuesMap[actualName] = parseInt(subParts[1]);\n  }\n\n  var info = {\n    names: names,\n    actualNames: actualNames,\n    namesValuesMap: namesValuesMap,\n    actualNamesValuesMap: actualNamesValuesMap\n  };\n  t.enumInfo = info;\n  return t;\n}\nvar markTypeInitialized = false;\nexport function markType(t, name, baseType, interfaces, staticInitializer) {\n  if (baseType === void 0) {\n    baseType = Base.prototype.$type;\n  }\n\n  if (interfaces === void 0) {\n    interfaces = null;\n  }\n\n  if (staticInitializer === void 0) {\n    staticInitializer = null;\n  }\n\n  t.prototype.$type = new Type(t, name, baseType, interfaces, staticInitializer);\n\n  if (!markTypeInitialized) {\n    markTypeInitialized = true;\n    markType(Type, \"Type\");\n    markType(Base, \"Base\", null);\n  } //TODO: do we need/want a flag on the function like we have in js?\n\n\n  if (typeof t.staticInit === \"function\") {\n    pendingStaticCtors.push(t);\n  } //t.prototype.$ = t.prototype.$type;\n\n\n  t.$type = t.prototype.$type;\n  t.$ = t.prototype.$type;\n  return t.prototype.$type;\n}\nexport function callStaticConstructors() {\n  var e_1, _a;\n\n  if (pendingStaticCtors.length > 0) {\n    //TODO: is the copy of the array needed? \n    var classes = Array.from(pendingStaticCtors);\n    pendingStaticCtors.length = 0;\n\n    try {\n      for (var classes_1 = tslib_1.__values(classes), classes_1_1 = classes_1.next(); !classes_1_1.done; classes_1_1 = classes_1.next()) {\n        var c = classes_1_1.value;\n        c.staticInit();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (classes_1_1 && !classes_1_1.done && (_a = classes_1.return)) _a.call(classes_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n}\nexport var IConvertible_$type = /*@__PURE__*/new Type(null, \"IConvertible\");\n\nvar Enum =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(Enum, _super);\n\n  function Enum() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Enum.$t = markType(Enum, \"Enum\");\n  return Enum;\n}(Base);\n\nexport { Enum };\n\nvar EnumBox =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(EnumBox, _super);\n\n  function EnumBox(value, type) {\n    var _this = _super.call(this) || this;\n\n    _this.value = value;\n    _this.$type = type;\n    return _this;\n  }\n\n  EnumBox.prototype.getHashCode = function () {\n    return this.value;\n  }; // TODO: Fill out remaining IConvertible implementation\n\n\n  EnumBox.prototype.toDouble = function (provider) {\n    return this.value;\n  };\n\n  EnumBox.prototype.toString = function () {\n    return EnumUtil.getName(this.$type, this.value);\n  };\n\n  return EnumBox;\n}(Enum);\n\nexport function getBoxIfEnum($t, v) {\n  if (v !== null && $t) {\n    // TODO: Remove the $t check here and fix the null ref issue\n    if ($t.isNullable) {\n      $t = $t.typeArguments[0];\n    }\n\n    if ($t.isEnumType) {\n      return enumGetBox($t, v);\n    }\n  }\n\n  return v;\n}\n;\nexport function enumGetBox($t, v) {\n  if (!$t._boxes) {\n    $t._boxes = {};\n  }\n\n  if (!$t._boxes[v]) {\n    $t._boxes[v] = new EnumBox(v, $t);\n  }\n\n  return $t._boxes[v];\n}\n\nvar EnumUtil =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function EnumUtil() {}\n\n  EnumUtil.getValueFromName = function (values, enumType, value, ignoreCase) {\n    if (values.hasOwnProperty(value)) {\n      return enumGetBox(enumType, values[value]);\n    } else if (ignoreCase) {\n      var upper = value.toUpperCase();\n\n      for (var x in values) {\n        if (x.toUpperCase() === upper) {\n          return enumGetBox(enumType, values[x]);\n        }\n      }\n    } else {\n      // A.S. Nov 4, 2016 Adjusted to handle case where leading char is _.\n      var firstChar = value.charAt(0);\n\n      if (firstChar != \"_\") {\n        value = firstChar.toLowerCase() + value.substr(1);\n      } else {\n        value = \"_\" + value.charAt(1).toLowerCase() + value.substr(2);\n      }\n\n      if (values.hasOwnProperty(value)) {\n        return enumGetBox(enumType, values[value]);\n      }\n    }\n\n    return null;\n  };\n\n  EnumUtil.parse = function (enumType, value, ignoreCase) {\n    //var info = Type.getDefinedNameAndNamespace(enumType.fullName);\n    //if (Type.canAssign(this.$type, enumType)) \n    {\n      //var p = info.namespace[ info.name ].prototype;\n      var values = enumType.isEnumType ? enumType.enumInfo.actualNamesValuesMap : enumType.InstanceConstructor.prototype;\n      var val = EnumUtil.getValueFromName(values, enumType, value, ignoreCase);\n\n      if (val !== null) {\n        return val;\n      }\n\n      if (enumType.isEnumType) {\n        values = enumType.enumInfo.namesValuesMap;\n        var val_1 = EnumUtil.getValueFromName(values, enumType, value, ignoreCase);\n\n        if (val_1 !== null) {\n          return val_1;\n        }\n      }\n    }\n    throw new Error(\"Invalid \" + enumType.name + \" value: \" + value);\n  }; // static $getName(value: number): string {\n  // }\n  // static $value(): number {\n  // }\n  //private _v: number;\n\n\n  EnumUtil.enumHasFlag = function (value, flag) {\n    /*jslint bitwise: true */\n    return (value & flag) === flag;\n  };\n\n  EnumUtil.toString = function (enumType, value) {\n    return EnumUtil.getName(enumType, value);\n  };\n\n  EnumUtil.getName = function (enumType, v) {\n    if (enumType._nameMap == undefined) {\n      var vals = EnumUtil.getValues(enumType);\n      var names = enumType.isEnumType ? enumType.enumInfo.names : EnumUtil.getNames(enumType);\n      var map = {};\n\n      for (var i = 0; i < vals.length; i++) {\n        map[vals[i]] = names[i];\n      }\n\n      enumType._nameMap = map;\n    }\n\n    var lookup = enumType._nameMap;\n    return lookup[v];\n  };\n\n  EnumUtil.getFlaggedName = function (enumType, v, getName) {\n    var _this = this;\n\n    var names = [];\n    var original = v;\n    var zeroValueName;\n    var value;\n    var values = [];\n\n    for (var p in this) {\n      if (this.hasOwnProperty(p)) {\n        value = enumType[p];\n\n        if (typeof enumType[p] == \"number\") {\n          values.push(p);\n        }\n      }\n    }\n\n    values.sort(function (a, b) {\n      return _this[a] - _this[b];\n    });\n\n    for (var i = values.length - 1; i >= 0; i--) {\n      value = this[values[i]];\n\n      if (value === 0) {\n        zeroValueName = getName(0);\n      }\n      /*jslint bitwise: true */\n      else if ((v & value) === value) {\n          v -= value;\n          names.unshift(getName(value));\n        }\n    }\n\n    if (v !== 0) {\n      return original.toString();\n    }\n\n    if (original !== 0) {\n      return names.join(\", \");\n    }\n\n    return zeroValueName || \"0\";\n  };\n\n  EnumUtil.getValues = function ($t) {\n    var result = [];\n\n    if ($t.isEnumType) {\n      for (var i = 0; i < $t.enumInfo.actualNames.length; i++) {\n        result.push($t.enumInfo.actualNamesValuesMap[$t.enumInfo.actualNames[i]]);\n      }\n\n      return result;\n    }\n\n    var p = $t.isEnumType ? $t.enumInfo.actualNames : $t.InstanceConstructor.prototype;\n\n    for (var member in p) {\n      if (p.hasOwnProperty(member)) {\n        if (typeof p[member] === \"number\") {\n          result.push(p[member]);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  EnumUtil.getNames = function ($t) {\n    var result = [];\n\n    if ($t.isEnumType) {\n      for (var i = 0; i < $t.enumInfo.actualNames.length; i++) {\n        result.push($t.enumInfo.actualNames[i]);\n      }\n\n      return result;\n    }\n\n    var p = $t.isEnumType ? $t.enumInfo.actualNames : $t.InstanceConstructor.prototype;\n\n    for (var member in p) {\n      if (p.hasOwnProperty(member)) {\n        if (typeof p[member] === \"number\") {\n          result.push(member);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  EnumUtil.getEnumValue = function ($t, v) {\n    if (v !== null) {\n      if (typeof v === \"number\") {\n        return v;\n      } else {\n        return v.value;\n      }\n    }\n\n    return 0;\n  };\n\n  EnumUtil.isDefined = function ($t, value) {\n    value = typeGetValue(value);\n    var p = $t.isEnumType ? $t.enumInfo.actualNamesValuesMap : $t.InstanceConstructor.prototype;\n\n    for (var member in p) {\n      if (p.hasOwnProperty(member)) {\n        if (p[member] === value) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }; // TODO: Fill out remaining IConvertible implementation\n\n\n  EnumUtil.toDouble = function (enumType, value, provider) {\n    return value.value;\n  };\n\n  EnumUtil.toObject = function ($t, value) {\n    return value;\n  };\n\n  EnumUtil.tryParse$1 = function ($tEnum, value, ignoreCase, result) {\n    try {\n      return {\n        ret: true,\n        p2: typeGetValue(EnumUtil.parse($tEnum, value, ignoreCase))\n      };\n    } catch (e) {\n      result = Type.createInstance($tEnum);\n      return {\n        ret: false,\n        p2: result\n      };\n    }\n  };\n\n  return EnumUtil;\n}();\n\nexport { EnumUtil };\n\nvar ValueType =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(ValueType, _super);\n\n  function ValueType() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ValueType.$t = markType(ValueType, \"ValueType\");\n  return ValueType;\n}(Base);\n\nexport { ValueType };\n\nvar Nullable =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(Nullable, _super);\n\n  function Nullable() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Nullable.getUnderlyingType = function (nullableType) {\n    if (nullableType.isGenericType !== undefined && nullableType.isGenericType && !nullableType.isGenericTypeDefinition && Nullable$1.prototype.$type.typeName == nullableType.typeName) {\n      return nullableType.genericTypeArguments[0];\n    }\n\n    return null;\n  };\n\n  Nullable.$t = markType(Nullable, \"Nullable\");\n  return Nullable;\n}(Base);\n\nexport { Nullable };\n\nvar Nullable$1 =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(Nullable$1, _super);\n\n  function Nullable$1($t, value) {\n    var _this = _super.call(this) || this;\n\n    _this.$t = null;\n    _this._value = null;\n    _this.isNullable = true;\n    _this.$t = $t;\n    _this.$type = _this.$type.specialize(_this.$t);\n\n    if (value !== undefined) {\n      _this._value = value;\n    }\n\n    return _this;\n  }\n\n  Nullable$1.nullableEquals = function (v1, v2) {\n    /*jshint eqnull:true */\n    var v1IsNull = v1 == null || !!v1.isNullable && !v1.hasValue;\n    var v2IsNull = v2 == null || !!v2.isNullable && !v2.hasValue;\n\n    if (v1IsNull && v2IsNull) {\n      return true;\n    }\n\n    if (v1IsNull != v2IsNull) {\n      return false;\n    }\n\n    var val1 = v1;\n    var val2 = v2;\n\n    if (v1.isNullable) {\n      val1 = v1.value;\n    }\n\n    if (v2.isNullable) {\n      val2 = v2.value;\n    }\n\n    return val1 == val2;\n  };\n\n  Nullable$1.prototype.equals = function (value) {\n    return Nullable$1.nullableEquals(this, value);\n  };\n\n  Nullable$1.prototype.getHashCode = function () {\n    if (this._value === null) {\n      return 0;\n    }\n\n    if (this._value[\"getHashCode\"] !== undefined) {\n      return this._value.getHashCode();\n    }\n\n    return Type.getPrimitiveHashCode(this._value);\n  };\n\n  Object.defineProperty(Nullable$1.prototype, \"hasValue\", {\n    get: function () {\n      return this._value !== null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Nullable$1.prototype.toString = function () {\n    return this._value === null ? \"\" : this._value.toString();\n  };\n\n  Object.defineProperty(Nullable$1.prototype, \"value\", {\n    get: function () {\n      return this._value;\n    },\n    set: function (value) {\n      this._value = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Nullable$1.prototype.getValueOrDefault = function () {\n    if (this.hasValue) {\n      return this._value;\n    } else {\n      return this.getDefaultValue();\n    }\n  };\n\n  Nullable$1.prototype.getDefaultValue = function () {\n    if (Type.canAssign(Number_$type, this.$t)) {\n      return 0;\n    } else if (Type.canAssign(Boolean_$type, this.$t)) {\n      return false;\n    } else if (this.$t.baseType == ValueType.prototype.$type) {\n      return Type.createInstance(this.$t);\n    } else {\n      return null;\n    }\n  };\n\n  Nullable$1.prototype.getValueOrDefault1 = function (defaultValue) {\n    if (this.hasValue) {\n      return this._value;\n    } else {\n      return defaultValue;\n    }\n  };\n\n  Nullable$1.prototype.preIncrement = function () {\n    if (!this.hasValue) {\n      return this;\n    }\n\n    this._value = this._value + 1;\n    return this;\n  };\n\n  Nullable$1.prototype.preDecrement = function () {\n    if (!this.hasValue) {\n      return this;\n    }\n\n    this._value = this._value - 1;\n    return this;\n  };\n\n  Nullable$1.prototype.postIncrement = function () {\n    if (!this.hasValue) {\n      return this;\n    }\n\n    var originalValue = this._value;\n    this._value = this._value + 1;\n    return new Nullable$1(this.$t, originalValue);\n  };\n\n  Nullable$1.prototype.postDecrement = function () {\n    if (!this.hasValue) {\n      return this;\n    }\n\n    var originalValue = this._value;\n    this._value = this._value - 1;\n    return new Nullable$1(this.$t, originalValue);\n  };\n\n  Nullable$1.$t = markType(Nullable$1, \"Nullable$1\");\n  return Nullable$1;\n}(Base);\n\nexport { Nullable$1 };\nexport function toNullable(t, value) {\n  if (value == null) {\n    return t._$nullNullable || (t._$nullNullable = new Nullable$1(t, null));\n  } else if (value.isNullable) {\n    return value;\n  }\n\n  return new Nullable$1(t, value);\n}\nexport var IComparable_$type = /*@__PURE__*/new Type(null, \"IComparable\");\nexport var IComparable$1_$type = /*@__PURE__*/new Type(null, \"IComparable$1\");\nexport var IEquatable$1_$type = /*@__PURE__*/new Type(null, \"IEquatable$1\");\nexport var INotifyPropertyChanged_$type = /*@__PURE__*/new Type(null, \"INotifyPropertyChanged\");\n\nvar PropertyChangedEventArgs =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(PropertyChangedEventArgs, _super);\n\n  function PropertyChangedEventArgs(propertyName) {\n    var _this = _super.call(this) || this;\n\n    _this._propertyName = null;\n    _this._propertyName = propertyName;\n    return _this;\n  }\n\n  Object.defineProperty(PropertyChangedEventArgs.prototype, \"propertyName\", {\n    get: function () {\n      return this._propertyName;\n    },\n    set: function (value) {\n      this._propertyName = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  PropertyChangedEventArgs.$t = markType(PropertyChangedEventArgs, \"PropertyChangedEventArgs\");\n  return PropertyChangedEventArgs;\n}(Base);\n\nexport { PropertyChangedEventArgs };\n\nvar IteratorWrapper =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function IteratorWrapper(inner, getNew) {\n    this._inner = null;\n    this._getNew = null;\n    this._hasNext = true;\n    this._current = null;\n    this._inner = inner;\n    this._getNew = getNew;\n  }\n\n  IteratorWrapper.prototype.moveNext = function () {\n    var next = this._inner.next();\n\n    this._hasNext = !next.done;\n    this._current = next.value;\n    return this._hasNext;\n  };\n\n  Object.defineProperty(IteratorWrapper.prototype, \"current\", {\n    get: function () {\n      return this._current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IteratorWrapper.prototype, \"currentObject\", {\n    get: function () {\n      return this._current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  IteratorWrapper.prototype.dispose = function () {};\n\n  IteratorWrapper.prototype.reset = function () {\n    this._inner = this._getNew();\n    this._current = null;\n    this._hasNext = true;\n  };\n\n  return IteratorWrapper;\n}();\n\nexport { IteratorWrapper };\n\nvar IterableWrapper =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function IterableWrapper(inner) {\n    this._inner = null;\n    this._inner = inner;\n  }\n\n  IterableWrapper.prototype.getEnumerator = function () {\n    var _this = this;\n\n    return new IteratorWrapper(this._inner()[Symbol.iterator](), function () {\n      return _this._inner()[Symbol.iterator]();\n    });\n  };\n\n  IterableWrapper.prototype.getEnumeratorObject = function () {\n    var _this = this;\n\n    return new IteratorWrapper(this._inner()[Symbol.iterator](), function () {\n      return _this._inner()[Symbol.iterator]();\n    });\n  };\n\n  return IterableWrapper;\n}();\n\nexport { IterableWrapper };\n\nvar EnumeratorWrapper =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function EnumeratorWrapper(inner) {\n    this._inner = null;\n    this._inner = inner;\n  }\n\n  EnumeratorWrapper.prototype.next = function () {\n    var done = !this._inner.moveNext();\n    var value = null;\n\n    if (!done) {\n      value = this._inner.current;\n    }\n\n    return {\n      done: done,\n      value: value\n    };\n  };\n\n  return EnumeratorWrapper;\n}();\n\nexport { EnumeratorWrapper };\n\nvar EnumeratorWrapperObject =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function EnumeratorWrapperObject(inner) {\n    this._inner = null;\n    this._inner = inner;\n  }\n\n  EnumeratorWrapperObject.prototype.next = function () {\n    var done = !this._inner.moveNext();\n    var value = null;\n\n    if (!done) {\n      value = this._inner.currentObject;\n    }\n\n    return {\n      done: done,\n      value: value\n    };\n  };\n\n  return EnumeratorWrapperObject;\n}();\n\nexport { EnumeratorWrapperObject };\nexport function getEn(arr) {\n  var arr_1, arr_1_1, item, e_2_1;\n\n  var e_2, _a;\n\n  return tslib_1.__generator(this, function (_b) {\n    switch (_b.label) {\n      case 0:\n        _b.trys.push([0, 5, 6, 7]);\n\n        arr_1 = tslib_1.__values(arr), arr_1_1 = arr_1.next();\n        _b.label = 1;\n\n      case 1:\n        if (!!arr_1_1.done) return [3\n        /*break*/\n        , 4];\n        item = arr_1_1.value;\n        return [4\n        /*yield*/\n        , item];\n\n      case 2:\n        _b.sent();\n\n        _b.label = 3;\n\n      case 3:\n        arr_1_1 = arr_1.next();\n        return [3\n        /*break*/\n        , 1];\n\n      case 4:\n        return [3\n        /*break*/\n        , 7];\n\n      case 5:\n        e_2_1 = _b.sent();\n        e_2 = {\n          error: e_2_1\n        };\n        return [3\n        /*break*/\n        , 7];\n\n      case 6:\n        try {\n          if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n\n        return [7\n        /*endfinally*/\n        ];\n\n      case 7:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\nexport function getEnumeratorObject(en) {\n  if (en instanceof Array || Array.isArray(en)) {\n    var arr_2 = en;\n    return new IteratorWrapper(getEn(arr_2), function () {\n      return getEn(arr_2);\n    });\n  }\n\n  return en.getEnumeratorObject();\n}\nexport function getEnumerator(en) {\n  if (en instanceof Array || Array.isArray(en)) {\n    var arr_3 = en;\n    return new IteratorWrapper(getEn(arr_3), function () {\n      return getEn(arr_3);\n    });\n  }\n\n  return en.getEnumerator();\n}\n\nvar EnumerableWrapper =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function EnumerableWrapper(inner) {\n    this._inner = null;\n    this._inner = inner;\n  }\n\n  EnumerableWrapper.prototype[Symbol.iterator] = function () {\n    return new EnumeratorWrapper(getEnumerator(this._inner));\n  };\n\n  return EnumerableWrapper;\n}();\n\nexport { EnumerableWrapper };\n\nvar EnumerableWrapperObject =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function EnumerableWrapperObject(inner) {\n    this._inner = null;\n    this._inner = inner;\n  }\n\n  EnumerableWrapperObject.prototype[Symbol.iterator] = function () {\n    return new EnumeratorWrapperObject(getEnumeratorObject(this._inner));\n  };\n\n  return EnumerableWrapperObject;\n}();\n\nexport { EnumerableWrapperObject };\nexport function toEnum(v) {\n  return new IterableWrapper(v);\n}\nexport function fromEnum(v) {\n  return new EnumerableWrapper(v);\n}\nexport function toEn(v) {\n  return new IterableWrapper(v);\n}\nexport function fromEn(v) {\n  return new EnumerableWrapperObject(v);\n}\nexport function fromDict(v) {\n  var v_1, v_1_1, item, _a, key, value, e_3_1;\n\n  var e_3, _b;\n\n  return tslib_1.__generator(this, function (_c) {\n    switch (_c.label) {\n      case 0:\n        _c.trys.push([0, 5, 6, 7]);\n\n        v_1 = tslib_1.__values(v), v_1_1 = v_1.next();\n        _c.label = 1;\n\n      case 1:\n        if (!!v_1_1.done) return [3\n        /*break*/\n        , 4];\n        item = v_1_1.value;\n        _a = tslib_1.__read(item, 2), key = _a[0], value = _a[1];\n        return [4\n        /*yield*/\n        , {\n          key: key,\n          value: value\n        }];\n\n      case 2:\n        _c.sent();\n\n        _c.label = 3;\n\n      case 3:\n        v_1_1 = v_1.next();\n        return [3\n        /*break*/\n        , 1];\n\n      case 4:\n        return [3\n        /*break*/\n        , 7];\n\n      case 5:\n        e_3_1 = _c.sent();\n        e_3 = {\n          error: e_3_1\n        };\n        return [3\n        /*break*/\n        , 7];\n\n      case 6:\n        try {\n          if (v_1_1 && !v_1_1.done && (_b = v_1.return)) _b.call(v_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n\n        return [7\n        /*endfinally*/\n        ];\n\n      case 7:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\nexport var Number_$type = /*@__PURE__*/new Type(Number, \"Number\", Base.prototype.$type, [IComparable_$type, IConvertible_$type]);\nexport var String_$type = /*@__PURE__*/new Type(String, \"String\", Base.prototype.$type, [IComparable_$type, IConvertible_$type]);\nexport var Date_$type = /*@__PURE__*/new Type(Date, \"Date\", Base.prototype.$type, [IComparable_$type, IConvertible_$type]);\nexport var Boolean_$type = /*@__PURE__*/new Type(Boolean, \"Boolean\", Base.prototype.$type, [IComparable_$type, IConvertible_$type]);\nexport var Void_$type = /*@__PURE__*/new Type(null, \"Void\", Base.prototype.$type);\nexport var n$ = Number_$type;\nexport var s$ = String_$type;\nexport var d$ = Date_$type;\nexport var b$ = Boolean_$type;\nexport var v$ = Void_$type;\nexport var Delegate_$type = /*@__PURE__*/new Type(null, \"Delegate\");\nexport function runOn(target, func) {\n  var self = func;\n\n  var ret = function () {\n    return self.apply(target, arguments);\n  };\n\n  ret.original = self;\n  ret.target = target;\n  return ret;\n}\nexport function delegateCombine(del1, del2) {\n  if (!del1) {\n    return del2;\n  }\n\n  if (!del2) {\n    return del1;\n  }\n\n  var ret = function () {\n    del1.apply(null, arguments);\n    return del2.apply(null, arguments);\n  };\n\n  ret.enumerate = function (arr) {\n    if (del1) {\n      if (del1.enumerate) {\n        del1.enumerate(arr);\n      } else {\n        arr.push(del1);\n      }\n    }\n\n    if (del2) {\n      if (del2.enumerate) {\n        del2.enumerate(arr);\n      } else {\n        arr.push(del2);\n      }\n    }\n  };\n\n  return ret;\n}\n;\nexport function delegateRemove(del1, del2) {\n  if (!del1) {\n    return null;\n  }\n\n  if (!del2) {\n    return del1;\n  }\n\n  var arr = [];\n  var del = null;\n\n  if (del1.enumerate) {\n    del1.enumerate(arr);\n  } else {\n    arr.push(del1);\n  }\n\n  for (var i = 0; i < arr.length; i++) {\n    if (del2.original) {\n      if (arr[i].original == del2.original && arr[i].target == del2.target) {\n        continue;\n      }\n    }\n\n    if (arr[i] == del2) {\n      continue;\n    }\n\n    del = delegateCombine(del, arr[i]);\n  }\n\n  return del;\n}\n;\nexport var IDisposable_$type = /*@__PURE__*/new Type(null, 'IDisposable');\nexport var IEnumerable_$type = /*@__PURE__*/new Type(null, \"IEnumerable\");\nexport var IEnumerator_$type = /*@__PURE__*/new Type(null, \"IEnumerator\");\nexport var IEqualityComparer$1_$type = /*@__PURE__*/new Type(null, \"IEqualityComparer$1\");\nexport var IEqualityComparer_$type = /*@__PURE__*/new Type(null, \"IEqualityComparer\");\nexport var ICollection_$type = /*@__PURE__*/new Type(null, \"ICollection\", null, [IEnumerable_$type]);\nexport var IList_$type = /*@__PURE__*/new Type(null, \"IList\", null, [IEnumerable_$type, ICollection_$type]);\nexport var IEnumerable$1_$type = /*@__PURE__*/new Type(null, \"IEnumerable$1\", null, [IEnumerable_$type]);\nexport var ICollection$1_$type = /*@__PURE__*/new Type(null, \"ICollection$1\", null, [/*@__PURE__*/IEnumerable$1_$type.specialize(0), IEnumerable_$type]);\nexport var IList$1_$type = /*@__PURE__*/new Type(null, \"IList$1\", null, [/*@__PURE__*/ICollection$1_$type.specialize(0), /*@__PURE__*/IEnumerable$1_$type.specialize(0), IEnumerable_$type]);\nexport var IEnumerator$1_$type = /*@__PURE__*/new Type(null, \"IEnumerator$1\", null, [IEnumerator_$type, IDisposable_$type]);\nexport var IDictionary_$type = /*@__PURE__*/new Type(null, \"IDictionary\");\n\nvar BaseError =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(BaseError, _super);\n\n  function BaseError(initNumber) {\n    if (initNumber === void 0) {\n      initNumber = -1;\n    }\n\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this._message = null;\n    _this._innerException = null;\n\n    if (initNumber >= 0) {\n      switch (initNumber) {\n        case 1:\n          _this.init1.apply(_this, arguments);\n\n          break;\n\n        case 2:\n          _this.init2.apply(_this, arguments);\n\n          break;\n      }\n    }\n\n    return _this;\n  }\n\n  BaseError.prototype.get_message = function () {\n    return this._message;\n  };\n\n  Object.defineProperty(BaseError.prototype, \"message\", {\n    get: function () {\n      return this.get_message();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseError.prototype, \"innerException\", {\n    get: function () {\n      return this._innerException;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseError.prototype.init1 = function (initNumber, message) {\n    this._message = message;\n  };\n\n  BaseError.prototype.init2 = function (initNumber, message, innerException) {\n    this._message = message;\n    this._innerException = innerException;\n  };\n\n  BaseError.prototype.toString = function () {\n    return this._message;\n  };\n\n  BaseError.$t = markType(BaseError, \"BaseError\");\n  return BaseError;\n}(Base);\n\nexport { BaseError };\n\nvar SystemException =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(SystemException, _super);\n\n  function SystemException(initNumber) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    var _this = _super.call(this, 0) || this;\n\n    if (initNumber > 0) {\n      switch (initNumber) {\n        case 1:\n          _this.init1.apply(_this, arguments);\n\n          break;\n\n        case 2:\n          _this.init2.apply(_this, arguments);\n\n          break;\n      }\n\n      return _this;\n    }\n\n    return _this; //super(0);\n  }\n\n  SystemException.prototype.init1 = function (initNumber, message) {\n    _super.prototype.init1.call(this, 1, message);\n  };\n\n  SystemException.prototype.init2 = function (initNumber, message, innerException) {\n    _super.prototype.init2.call(this, 2, message, innerException);\n  };\n\n  SystemException.$t = markType(SystemException, \"SystemException\", BaseError.prototype.$type);\n  return SystemException;\n}(BaseError);\n\nexport { SystemException };\n\nvar NotSupportedException =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(NotSupportedException, _super);\n\n  function NotSupportedException(initNumber) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    var _this = _super.call(this, 0) || this;\n\n    if (initNumber > 0) {\n      switch (initNumber) {\n        case 1:\n          _this.init1.apply(_this, arguments);\n\n          break;\n\n        case 2:\n          _this.init2.apply(_this, arguments);\n\n          break;\n      }\n\n      return _this;\n    }\n\n    return _this;\n  }\n\n  NotSupportedException.prototype.init1 = function (initNumber, message) {\n    _super.prototype.init1.call(this, 1, message);\n  };\n\n  NotSupportedException.prototype.init2 = function (initNumber, message, innerException) {\n    _super.prototype.init2.call(this, 2, message, innerException);\n  };\n\n  NotSupportedException.$t = markType(NotSupportedException, \"NotSupportedException\", SystemException.prototype.$type);\n  return NotSupportedException;\n}(SystemException);\n\nexport { NotSupportedException };\n\nvar FormatException =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(FormatException, _super);\n\n  function FormatException(initNumber) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    var _this = _super.call(this, 0) || this;\n\n    if (initNumber > 0) {\n      switch (initNumber) {\n        case 1:\n          _this.init1.apply(_this, arguments);\n\n          break;\n\n        case 2:\n          _this.init2.apply(_this, arguments);\n\n          break;\n      }\n\n      return _this;\n    }\n\n    return _this;\n  }\n\n  FormatException.prototype.init1 = function (initNumber, message) {\n    _super.prototype.init1.call(this, 1, message);\n  };\n\n  FormatException.prototype.init2 = function (initNumber, message, innerException) {\n    _super.prototype.init2.call(this, 2, message, innerException);\n  };\n\n  FormatException.$t = markType(FormatException, \"FormatException\", SystemException.prototype.$type);\n  return FormatException;\n}(SystemException);\n\nexport { FormatException };\n\nvar PointUtil =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function PointUtil() {}\n\n  PointUtil.equals = function (p1, p2) {\n    if (p1 == null && p2 == null) {\n      return true;\n    }\n\n    if (p1 == null && p2 != null) {\n      return false;\n    }\n\n    if (p1 != null && p2 == null) {\n      return false;\n    }\n\n    return p1.x == p2.x && p1.y == p2.y;\n  };\n\n  PointUtil.notEquals = function (p1, p2) {\n    return !PointUtil.equals(p1, p2);\n  };\n\n  PointUtil.create = function () {\n    return {\n      x: 0,\n      y: 0,\n      $type: Point_$type\n    };\n  };\n\n  PointUtil.createXY = function (x, y) {\n    return {\n      x: x,\n      y: y,\n      $type: Point_$type\n    };\n  };\n\n  return PointUtil;\n}();\n\nexport { PointUtil };\nexport var Point_$type = /*@__PURE__*/new Type(null, \"Point\");\nexport var SeekOrigin = /*@__PURE__*/function (SeekOrigin) {\n  SeekOrigin[SeekOrigin[\"Begin\"] = 0] = \"Begin\";\n  SeekOrigin[SeekOrigin[\"Current\"] = 1] = \"Current\";\n  SeekOrigin[SeekOrigin[\"End\"] = 2] = \"End\";\n  return SeekOrigin;\n}({});\n\nvar Stream =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(Stream, _super);\n\n  function Stream() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Stream.prototype.close = function () {\n    this.disposeCore(true);\n  };\n\n  Stream.prototype.dispose = function () {\n    this.close();\n  };\n\n  Stream.prototype.disposeCore = function (disposing) {};\n\n  Stream.prototype.readByte = function () {\n    var bytes = [0];\n    var count = this.read(bytes, 0, 1);\n\n    if (count === 0) {\n      return -1;\n    }\n\n    return bytes[0];\n  };\n\n  Stream.prototype.writeByte = function (value) {\n    this.write([value], 0, 1);\n  };\n\n  Stream.$t = markType(Stream, \"Stream\");\n  return Stream;\n}(Base);\n\nexport { Stream };\n\nvar EventArgs =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(EventArgs, _super);\n\n  function EventArgs() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(EventArgs, \"empty\", {\n    get: function () {\n      if (EventArgs._empty) {\n        return EventArgs._empty;\n      }\n\n      EventArgs._empty = new EventArgs();\n      return EventArgs._empty;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  EventArgs.$t = markType(EventArgs, \"EventArgs\");\n  return EventArgs;\n}(Base);\n\nexport { EventArgs };\nexport var IFormatProvider_$type = /*@__PURE__*/new Type(null, 'IFormatProvider');\nexport var Array_$type = /*@__PURE__*/new Type(Array, \"Array\", Base.prototype.$type, [IEnumerable_$type, ICollection_$type]);\nexport var a$ = Array_$type;\n\nvar TypeRegistrar =\n/** @class */\n\n/*@__PURE__*/\nfunction () {\n  function TypeRegistrar() {}\n\n  TypeRegistrar.create = function (typeName) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    if (TypeRegistrar.isRegistered(typeName)) {\n      var C = TypeRegistrar.get(typeName);\n\n      if (C.htmlTagName) {\n        return document.createElement(C.htmlTagName);\n      } else {\n        return new (C.bind.apply(C, tslib_1.__spread([void 0], rest)))();\n      }\n    } else {\n      return null;\n    }\n  };\n\n  TypeRegistrar.register = function (typeName, type) {\n    TypeRegistrar._registrar.set(typeName, type.InstanceConstructor);\n  };\n\n  TypeRegistrar.registerCons = function (typeName, type) {\n    TypeRegistrar._registrar.set(typeName, type);\n  };\n\n  TypeRegistrar.callRegister = function (typeName) {\n    var type = TypeRegistrar.get(typeName);\n\n    if (type !== undefined && type !== null && type[\"register\"] !== undefined) {\n      type[\"register\"]();\n    }\n  };\n\n  TypeRegistrar.isRegistered = function (typeName) {\n    return TypeRegistrar.get(typeName) !== null;\n  };\n\n  TypeRegistrar.get = function (typeName) {\n    if (TypeRegistrar._registrar.has(typeName)) {\n      return TypeRegistrar._registrar.get(typeName);\n    }\n\n    if (typeName.indexOf(\"Igx\") == 0) {\n      var igc = typeName.replace(\"Igx\", \"Igc\");\n\n      if (TypeRegistrar._registrar.has(igc)) {\n        return TypeRegistrar._registrar.get(igc);\n      }\n\n      var igr = typeName.replace(\"Igx\", \"Igr\");\n\n      if (igr.indexOf(\"Component\") == igr.length - 9) {\n        igr = igr.substring(0, igr.length - 9);\n      }\n\n      if (TypeRegistrar._registrar.has(igr)) {\n        return TypeRegistrar._registrar.get(igr);\n      }\n    }\n\n    return null;\n  };\n\n  TypeRegistrar.createFromInternal = function (internal, prefix, postfix) {\n    if (!internal) {\n      return null;\n    }\n\n    if (!internal.$type) {\n      return null;\n    }\n\n    var name = internal.$type.name;\n    var externalName = prefix + name + postfix;\n\n    if (!TypeRegistrar.isRegistered(externalName)) {\n      return null;\n    }\n\n    return TypeRegistrar.create(externalName);\n  };\n\n  TypeRegistrar._registrar = new Map();\n  return TypeRegistrar;\n}();\n\nexport { TypeRegistrar };","map":{"version":3,"sources":["../../../../src/igniteui-core/lib/type.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*!\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nvar _typeIdentifierCache = {};\nvar _nextTypeIdentifier = 0;\n// interface Function {\n//     $type?: Type;\n// }\nexport function getInstanceType(obj) {\n    if (obj.$type) {\n        return obj.$type;\n    }\n    else if (typeof obj === 'number') {\n        return Number_$type;\n    }\n    else if (typeof obj === 'string') {\n        return String_$type;\n    }\n    else if (typeof obj === 'boolean') {\n        return Boolean_$type;\n    }\n    else if (obj instanceof Date) {\n        return Date_$type;\n    }\n    return Base.prototype.$type;\n}\nvar Base = /** @class */ /*@__PURE__*/ (function () {\n    function Base() {\n    }\n    Base.prototype.equals = function (other) {\n        return this === other;\n    };\n    Base.equalsStatic = function (a, b) {\n        var aIsNull = (a == null) || (!!a.isNullable && !a.hasValue);\n        var bIsNull = (b == null) || (!!b.isNullable && !b.hasValue);\n        if (aIsNull || bIsNull) {\n            return aIsNull && bIsNull;\n        }\n        if (a.equals) {\n            return a.equals(b);\n        }\n        if (b.equals) {\n            return b.equals(a);\n        }\n        if (Number.isNaN(a) && Number.isNaN(b)) {\n            return true;\n        }\n        if (a instanceof Date) {\n            return b instanceof Date && +a === +b;\n        }\n        return a == b && typeof a == typeof b;\n    };\n    Base.equalsSimple = function (item1, item2) {\n        return item1 == item2;\n    };\n    ;\n    Base.compareSimple = function (item1, item2) {\n        if (item1 == item2) {\n            return 0;\n        }\n        if (item1 < item2) {\n            return -1;\n        }\n        return 1;\n    };\n    ;\n    Base.compare = function (item1, item2) {\n        if (item1 === item2) {\n            return 0;\n        }\n        var xComparable = typeCast(IComparable_$type, item1);\n        if (xComparable !== null && xComparable.compareToObject) {\n            return xComparable.compareToObject(item2);\n        }\n        var yComparable = typeCast(IComparable_$type, item2);\n        if (yComparable !== null && yComparable.compareToObject) {\n            return -yComparable.compareToObject(item1);\n        }\n        return Base.compareSimple(item1, item2);\n    };\n    ;\n    Base.prototype.getHashCode = function () {\n        if (this.$hashCode === undefined) {\n            this.$hashCode = Base.nextHashCode++;\n        }\n        return this.$hashCode;\n    };\n    Base.getHashCodeStatic = function (obj) {\n        if (obj.getHashCode) {\n            return obj.getHashCode();\n        }\n        if (obj.$hashCode !== undefined) {\n            return obj.$hashCode;\n        }\n        if (!(typeof obj == \"object\")) {\n            return Type.getPrimitiveHashCode(obj);\n        }\n        else {\n            obj.$hashCode = Base.nextHashCode++;\n            return obj.$hashCode;\n        }\n    };\n    Base.prototype.memberwiseClone = function () {\n        var clone;\n        try {\n            clone = Object.create(this.$type.InstanceConstructor.prototype);\n        }\n        catch (e) {\n            var Cons = /** @class */ /*@__PURE__*/ (function () {\n                function Cons() {\n                }\n                return Cons;\n            }());\n            Cons.prototype = this.$type.InstanceConstructor.prototype;\n            clone = new Cons();\n        }\n        for (var prop in this) {\n            if (this.hasOwnProperty(prop)) {\n                clone[prop] = this[prop];\n            }\n        }\n        return clone;\n    };\n    Base.referenceEquals = function (a, b) {\n        return a === b || (a == null && b == null);\n    };\n    Base.getArrayOfValues = function (obj) {\n        var result = [];\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                result.push(obj[i]);\n            }\n        }\n        return result;\n    };\n    Base.getArrayOfProperties = function (obj) {\n        var result = [];\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                result.push(i);\n            }\n        }\n        return result;\n    };\n    ;\n    Base.nextHashCode = 0;\n    return Base;\n}());\nexport { Base };\nvar Type = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Type, _super);\n    function Type(instanceConstructor, identifier, baseType, interfaces, staticInitializer) {\n        if (baseType === void 0) {\n            baseType = Base.prototype.$type;\n        }\n        if (interfaces === void 0) {\n            interfaces = null;\n        }\n        if (staticInitializer === void 0) {\n            staticInitializer = null;\n        }\n        var _this = _super.call(this) || this;\n        _this.specializationCache = null;\n        _this._staticInitializer = null;\n        _this.name = null;\n        _this.typeArguments = null;\n        _this.baseType = null;\n        _this.interfaces = null;\n        _this.isEnumType = false;\n        _this._isGenericType = undefined;\n        _this._staticFields = null;\n        _this.isNullable = false;\n        _this._$nullNullable = null;\n        _this.enumInfo = null;\n        _this.specializationCache = {};\n        _this._staticInitializer = staticInitializer;\n        _this._fullName = identifier;\n        _this.name = identifier;\n        _this.InstanceConstructor = instanceConstructor;\n        var lastDotIndex = _this.name.lastIndexOf(\".\");\n        if (lastDotIndex >= 0) {\n            _this.name = _this.name.substr(lastDotIndex + 1);\n        }\n        _this.typeArguments = null;\n        _this.baseType = null;\n        _this.interfaces = null;\n        if (baseType) {\n            _this.baseType = baseType;\n        }\n        if (interfaces) {\n            _this.interfaces = interfaces;\n        }\n        if (_typeIdentifierCache[identifier]) {\n            _this.identifier = _typeIdentifierCache[identifier];\n        }\n        else {\n            _this.identifier = _nextTypeIdentifier++;\n            _typeIdentifierCache[identifier] = _this.identifier;\n        }\n        return _this;\n        // rather than always evaluating a function on a type to see if it is an enum\n        // we can just cache it once on the type\n        // if (baseType && Enum && baseType == Enum.prototype.$type) {\n        //     this.isEnumType = true;\n        // }\n    }\n    Object.defineProperty(Type.prototype, \"typeName\", {\n        get: function () {\n            return this.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Type.prototype, \"fullName\", {\n        get: function () {\n            return this._fullName;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Type.prototype.getSpecId = function (types) {\n        if (types.length === 1) {\n            if (!types[0]) {\n                return \"undef\";\n            }\n            else if (types[0] === -1) {\n                return undefined;\n            }\n            else if (!types[0].typeName) {\n                return types[0].toString();\n            }\n            else if (types[0].stringId) {\n                return types[0].stringId;\n            }\n            else {\n                return types[0].identifier.toString();\n            }\n        }\n        var ret = \"\";\n        for (var i = 0; i < types.length; i++) {\n            var type = types[i];\n            if (!type) {\n                ret += \"undef\";\n            }\n            else if (type == -1) {\n                return undefined;\n            }\n            else if (!type.typeName) {\n                ret += type.toString();\n            }\n            else if (type.stringId) {\n                ret += type.stringId;\n            }\n            else {\n                ret += type.identifier.toString();\n            }\n        }\n        return ret;\n    };\n    Object.defineProperty(Type.prototype, \"isGenericType\", {\n        get: function () {\n            if (this._isGenericType === undefined) {\n                this._isGenericType = this.name.indexOf(\"$\") >= 0;\n            }\n            return this._isGenericType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Type.prototype, \"isGenericTypeDefinition\", {\n        get: function () {\n            return this.typeArguments === null && this.isGenericType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Type.prototype, \"genericTypeArguments\", {\n        get: function () {\n            return this.typeArguments;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Type.prototype.getStaticFields = function (type) {\n        if (type === undefined) {\n            type = this;\n        }\n        var t = this;\n        while (t != null) {\n            if (t === type || t._fullName == type._fullName) {\n                if (t._staticFields == null && t._staticInitializer) {\n                    t._staticFields = {};\n                    t._staticInitializer.apply(t._staticFields, t.typeArguments);\n                }\n                return t._staticFields;\n            }\n            t = t.baseType;\n        }\n        return null;\n    };\n    Type.prototype.initSelfReferences = function (replacement) {\n        var i, j;\n        if (replacement) {\n            if (this.typeArguments) {\n                var updateCache = false;\n                for (j = 0; j < this.typeArguments.length; j++) {\n                    var typeArg = this.typeArguments[j];\n                    if (typeArg == -1) {\n                        updateCache = true;\n                        this.typeArguments[j] = replacement;\n                    }\n                    else if (typeArg &&\n                        typeArg instanceof Type &&\n                        typeArg.initSelfReferences) {\n                        typeArg.initSelfReferences(replacement);\n                    }\n                }\n                if (updateCache) {\n                    var specId = this.getSpecId(this.typeArguments);\n                    var ret = this.specializationCache[specId];\n                    if (!ret) {\n                        this.specializationCache[specId] = this;\n                    }\n                }\n            }\n        }\n        else {\n            if (this.baseType) {\n                this.baseType.initSelfReferences(this);\n            }\n            if (this.interfaces) {\n                for (i = 0; i < this.interfaces.length; i++) {\n                    this.interfaces[i].initSelfReferences(this);\n                }\n            }\n        }\n        return this;\n    };\n    Type.prototype.specialize = function () {\n        var rest = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            rest[_i] = arguments[_i];\n        }\n        var i;\n        if (!this.isGenericType) {\n            return this;\n        }\n        var specId = this.getSpecId(Array.from(arguments));\n        var ret = this.specializationCache[specId];\n        if (ret) {\n            return ret;\n        }\n        ret = new Type(this.InstanceConstructor, this._fullName, this.baseType, this.interfaces, this._staticInitializer);\n        ret.specializationCache = this.specializationCache;\n        var placeholders = this.typeArguments;\n        var hasPlaceholders = false;\n        // Make sure the placeholders are actually numbers. If they are types, we are re-specializing an\n        // already specialized type.\n        if (placeholders && placeholders.length) {\n            /* going back to how it used to be. we shouldn't assume that the number/order of the arguments\n                relates to the typearguments. this may be an interface that has its type information already\n                and either has placeholders or is a closed type\n            // you can have a mixed bag where some are placeholders and others are not and the\n            // placeholder doesn't have to be the first slot\n            for (i = 0; i < placeholders.length; i++) {\n                if (isFinite(placeholders[ i ])) {\n                    hasPlaceholders = true;\n                    break;\n                }\n            }*/\n            hasPlaceholders = true;\n        }\n        ret.typeArguments = [];\n        if (hasPlaceholders) {\n            for (i = 0; i < placeholders.length; i++) {\n                // if the argument being provided is a placeholder index and we already have\n                // a placeholder then keep the index we have. otherwise we're taking the index\n                // of the parent type\n                if (typeof placeholders[i] === \"number\" &&\n                    isFinite(placeholders[i]) && !isFinite(arguments[placeholders[i]])) {\n                    ret.typeArguments[i] = arguments[placeholders[i]];\n                }\n                else {\n                    ret.typeArguments[i] = placeholders[i];\n                }\n            }\n        }\n        else {\n            for (i = 0; i < arguments.length; i++) {\n                ret.typeArguments[i] = arguments[i];\n            }\n        }\n        // since the placeholder indexes for the basetype and interfaces implemented are based\n        // on the order of the type arguments for the defining types we should pass its typeargs\n        // and not the outermost type's type arguments which may be different in number and order\n        // than the base type of the base types and interfaces implemented\n        if (this.baseType && this.baseType.typeArguments) {\n            ret.baseType = this.specialize.apply(this.baseType, ret.typeArguments);\n        }\n        if (this.interfaces) {\n            ret.interfaces = [];\n            for (i = 0; i < this.interfaces.length; i++) {\n                ret.interfaces[i] = this.specialize.apply(this.interfaces[i], ret.typeArguments);\n            }\n        }\n        // rather than doing this check in various places we could just cache a field on the type\n        if (this._fullName == \"Nullable$1\" && ret.typeArguments.length == 1) {\n            ret.isNullable = true;\n        }\n        // if this was a self referencing type (e.g. IEquatable<Int32> for Int32 then we won't have the\n        // specId yet because we don't know the type argument. we'll update the cache when we update\n        // the self references. otherwise other types that use self references (but for a different type)\n        // will get and use the wrong type arguments\n        if (specId) {\n            this.specializationCache[specId] = ret;\n            ret.stringId = ret.generateString();\n        }\n        else {\n            // the self referencing type needs to be able to put itself into the specialization cache\n            // of the original type\n            //ret.specializationCache = this.specializationCache;\n        }\n        if (this.InstanceConstructor != null) {\n            var _self = this;\n            ret.InstanceConstructor = function () {\n                _self.InstanceConstructor.apply(this, ret.typeArguments.concat(Array.prototype.slice.call(arguments, 0)));\n                return this;\n            };\n            ret.InstanceConstructor.prototype = this.InstanceConstructor.prototype;\n        }\n        return ret;\n    };\n    Type.prototype.equals = function (other) {\n        if (!(other instanceof Type)) {\n            return false;\n        }\n        if (this.identifier !== other.identifier) {\n            return false;\n        }\n        if (this.typeArguments === null && other.typeArguments === null) {\n            return true;\n        }\n        if (this.typeArguments === null && other.typeArguments !== null) {\n            return false;\n        }\n        if (this.typeArguments !== null && other.typeArguments === null) {\n            return false;\n        }\n        if (this.typeArguments.length !== other.typeArguments.length) {\n            return false;\n        }\n        for (var i = 0; i < this.typeArguments.length; i++) {\n            //TODO: handle covariance case here.\n            //if (!$.ig.util.canAssign(this.typeArguments[ i ], other.typeArguments[ i ])) {\n            //    return false;\n            //}\n            if (!Type.checkEquals(this.typeArguments[i], other.typeArguments[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Type.checkEquals = function (type1, type2) {\n        if (type1 instanceof Type) {\n            return type1.equals(type2);\n        }\n        else if (type2 instanceof Type) {\n            return type2.equals(type1);\n        }\n        else {\n            return type1 === type2;\n        }\n    };\n    Type.op_Equality = function (type1, type2) {\n        return type1.equals(type2);\n    };\n    Type.op_Inequality = function (type1, type2) {\n        return !type1.equals(type2);\n    };\n    Type.prototype.generateString = function () {\n        if (!this.typeArguments || !this.typeArguments.length) {\n            return this.identifier.toString();\n        }\n        else {\n            var ret = this.identifier.toString() + \"[\";\n            var first = true;\n            for (var i = 0; i < this.typeArguments.length; i++) {\n                if (this.typeArguments[i] == undefined) {\n                    continue;\n                }\n                if (first) {\n                    first = false;\n                }\n                else {\n                    ret += \",\";\n                }\n                if (this.typeArguments[i].toString) {\n                    ret += this.typeArguments[i].toString();\n                }\n                else {\n                    ret += this.typeArguments[i].identifier.toString();\n                }\n            }\n            ret += \"]\";\n            return ret;\n        }\n    };\n    Object.defineProperty(Type.prototype, \"isValueType\", {\n        get: function () {\n            return this.baseType === ValueType.prototype.$type;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Type.prototype.isAssignableFrom = function (tOther) {\n        // TODO: Unit test and make sure this is right (especially with generics\n        if (this === tOther) {\n            return true;\n        }\n        if (tOther.baseType && this.isAssignableFrom(tOther.baseType)) {\n            return true;\n        }\n        if (tOther.interfaces) {\n            for (var i = 0; i < tOther.interfaces.length; i++) {\n                if (this.isAssignableFrom(tOther.interfaces[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    Type.prototype.isInstanceOfType = function (value) {\n        return typeCast(this, value) !== null;\n    };\n    Object.defineProperty(Type.prototype, \"isPrimitive\", {\n        get: function () {\n            return this === Number_$type ||\n                this === Boolean_$type;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Type.canAssign = function (targetType, type) {\n        if (targetType.name === 'Nullable$1' && type.name !== 'Nullable$1') {\n            targetType = Nullable.getUnderlyingType(targetType);\n        }\n        return Type.canAssignSimple(targetType, type);\n    };\n    Type.canAssignSimple = function (targetType, type) {\n        if (targetType === type || Type.checkEquals(targetType, type)) {\n            return true;\n        }\n        if (type.interfaces) {\n            for (var i = 0; i < type.interfaces.length; i++) {\n                if (Type.canAssignSimple(targetType, type.interfaces[i])) {\n                    return true;\n                }\n            }\n        }\n        if (type.baseType) {\n            return Type.canAssignSimple(targetType, type.baseType);\n        }\n        return false;\n    };\n    Type.createInstance = function ($t) {\n        if ($t === Number || $t == Number_$type ||\n            $t.isEnumType) {\n            return 0;\n        }\n        if ($t == Boolean || $t == Boolean_$type) {\n            return false;\n        }\n        if ($t.InstanceConstructor) {\n            var result;\n            //result = Object.create((<Type>$t).InstanceConstructor.prototype);\n            var C = $t.InstanceConstructor;\n            //(<Type>$t).InstanceConstructor.apply(result, Array.prototype.slice.call(arguments, 1));\n            result = new (C.bind.apply(C, tslib_1.__spread([void 0], Array.prototype.slice.call(arguments, 1))))();\n            return result;\n        }\n        throw new Error(\"Cannot find instance constructor for the type parameter\");\n    };\n    ;\n    Type.getDefaultValue = function ($t) {\n        if ($t === Number_$type ||\n            $t.isEnumType) {\n            return 0;\n        }\n        if ($t == Boolean_$type) {\n            return false;\n        }\n        if ($t.baseType === ValueType.$type) {\n            return Type.createInstance($t);\n        }\n        return null;\n    };\n    ;\n    Type.getPrimitiveHashCode = function (v) {\n        var val = typeof v;\n        if (val === \"string\" || v instanceof String) {\n            var hash = 0, i, chr, len;\n            if (v.length === 0) {\n                return hash;\n            }\n            for (i = 0, len = this.length; i < len; i++) {\n                chr = v.charCodeAt(i);\n                /*jslint bitwise: true */\n                hash = ((hash << 5) - hash) + chr;\n                hash |= 0; // Convert to 32bit integer\n            }\n            return hash;\n        }\n        else if (val === \"boolean\" || v instanceof Boolean) {\n            return +v;\n        }\n        else {\n            return v;\n        }\n    };\n    // static mark(t: Function, name: string,\n    //     baseType: Type = Base.prototype.$type, \n    //     interfaces: Type[] = null, \n    //     staticInitializer: () => void = null) {\n    //     t.prototype.$type = new Type(t, name, baseType, interfaces, staticInitializer);\n    //     (<any>t).$type = t.prototype.$type;\n    // }\n    Type.decodePropType = function (val) {\n        if (val === 0) {\n            return Boolean_$type;\n        }\n        else if (val === 1) {\n            return Number_$type;\n        }\n        else if (val === 2) {\n            return String_$type;\n        }\n        else if (val === 3) {\n            return Date_$type;\n        }\n        else {\n            return val;\n        }\n    };\n    return Type;\n}(Base));\nexport { Type };\nexport function markDep(depProp, PropMeta, t, changedFunction, props) {\n    var names = [];\n    var currName = \"\";\n    var currOpts = [];\n    var hasDefaultValue = false;\n    var defaultValue = null;\n    var propType = null;\n    var changeHandler = null;\n    var setterFunc = null;\n    var getterFunc = null;\n    var aliasName = null;\n    var propertyAlias = null;\n    var _loop_1 = function () {\n        if (i % 2 == 0) {\n            currName = props[i];\n            if (currName.indexOf(\":\") >= 0) {\n                var parts = currName.split(':');\n                if (parts.length == 2) {\n                    currName = parts[0];\n                    aliasName = parts[1];\n                    propertyAlias = currName.substring(0, 1).toLowerCase() + currName.substring(1) + \"Property\";\n                }\n                else {\n                    currName = parts[0];\n                    aliasName = parts[1];\n                    if (aliasName.length == 0) {\n                        aliasName = currName.substring(0, 1).toLowerCase() + currName.substring(1);\n                    }\n                    propertyAlias = parts[2];\n                }\n            }\n            else {\n                aliasName = currName.substring(0, 1).toLowerCase() + currName.substring(1);\n                propertyAlias = aliasName + \"Property\";\n            }\n            names.push(currName);\n        }\n        else {\n            currOpts = props[i];\n            if (currOpts.length == 2) {\n                hasDefaultValue = true;\n                defaultValue = currOpts[1];\n                propType = Type.decodePropType(currOpts[0]);\n            }\n            else {\n                hasDefaultValue = false;\n                propType = Type.decodePropType(currOpts[0]);\n            }\n            var changedName_1 = currName;\n            changeHandler = function (o, a) {\n                o[changedFunction].call(o, changedName_1, a.oldValue, a.newValue);\n            };\n            var meta = null;\n            if (hasDefaultValue) {\n                meta = PropMeta.createWithDefaultAndCallback(defaultValue, changeHandler);\n            }\n            else {\n                meta = PropMeta.createWithCallback(changeHandler);\n            }\n            var dp_1 = depProp.registerAlt(currName, propType, t.$type, meta);\n            setterFunc = function (v) {\n                this.setValueAlt(dp_1, v);\n            };\n            if (propType.isEnumType) {\n                getterFunc = function () {\n                    return typeGetValue(this.getValueAlt(dp_1));\n                };\n            }\n            else {\n                getterFunc = function () {\n                    return this.getValueAlt(dp_1);\n                };\n            }\n            Object.defineProperty(t.prototype, aliasName, {\n                set: setterFunc,\n                get: getterFunc,\n                configurable: true\n            });\n            t[propertyAlias] = dp_1;\n        }\n    };\n    //debugger;\n    for (var i = 0; i < props.length; i++) {\n        _loop_1();\n    }\n    // let superClass = (<any>t).$type.baseType;\n    // if (superClass !== null && superClass !== undefined) {\n    //     let superNames = superClass.InstanceConstructor.$$p;\n    //     if (superNames) {\n    //         for (var j = superNames.length - 1; j >= 0; j--) {\n    //             names.unshift(superNames[j]);\n    //         }\n    //     }\n    // }\n    //(<any>t).$$p = names;\n    return names;\n}\nexport function typeGetValue(v) {\n    if (v !== null && v.$type && v.$type.isEnumType) {\n        return v.value;\n    }\n    return v;\n}\nexport function typeCast(targetType, obj) {\n    if (obj === undefined || obj === null) {\n        return null;\n    }\n    if (targetType === Array) {\n        return ((obj instanceof Array) ? obj : null);\n    }\n    if (targetType === String) {\n        targetType = String_$type;\n    }\n    if (targetType === Number) {\n        targetType = Number_$type;\n    }\n    if (targetType === Boolean) {\n        targetType = Boolean_$type;\n    }\n    if (targetType === Date) {\n        targetType = Date_$type;\n    }\n    var type = obj;\n    if (obj.$type) {\n        type = obj.$type;\n    }\n    else if (typeof obj === 'number') {\n        type = targetType === Number ? Number : Number_$type;\n    }\n    else if (typeof obj === 'string') {\n        type = String_$type;\n    }\n    else if (typeof obj === 'boolean') {\n        type = Boolean_$type;\n    }\n    else if (obj instanceof Date) {\n        type = Date_$type;\n    }\n    else if (obj instanceof Array) {\n        type = Array_$type;\n    }\n    if (Type.canAssignSimple(targetType, type)) {\n        return obj;\n    }\n    if (targetType.name === 'Nullable$1' && type.name !== 'Nullable$1') {\n        targetType = Nullable.getUnderlyingType(targetType);\n        if (Type.canAssignSimple(targetType, type)) {\n            return toNullable(targetType, obj);\n        }\n        return toNullable(targetType, null);\n    }\n    return null;\n}\nexport function typeCastObjTo$t($t, v) {\n    var shouldWrap = false;\n    if ($t.isNullable) {\n        $t = $t.typeArguments[0];\n        shouldWrap = true;\n    }\n    if (v !== null && $t.isEnumType) {\n        v = v.value;\n    }\n    return shouldWrap ? toNullable($t, v) : v;\n}\nvar pendingStaticCtors = /*@__PURE__*/ new Array();\nexport function markStruct(t, name, baseType, interfaces, staticInitializer) {\n    if (baseType === void 0) {\n        baseType = ValueType.prototype.$type;\n    }\n    if (interfaces === void 0) {\n        interfaces = null;\n    }\n    if (staticInitializer === void 0) {\n        staticInitializer = null;\n    }\n    t.prototype.$type = new Type(t, name, baseType, interfaces, staticInitializer);\n    //TODO: do we need/want a flag on the function like we have in js?\n    if (typeof t.staticInit === \"function\") {\n        pendingStaticCtors.push(t);\n    }\n    t.$type = t.prototype.$type;\n    t.$ = t.prototype.$type;\n    return t.prototype.$type;\n}\nexport function markEnum(name, encodedDef) {\n    var t = new Type(null, name, Base.prototype.$type, [IConvertible_$type]);\n    t.isEnumType = true;\n    var parts = encodedDef.split(\"|\");\n    var names = [];\n    var actualNames = [];\n    var namesValuesMap = {};\n    var actualNamesValuesMap = {};\n    for (var i = 0; i < parts.length; i++) {\n        var subParts = parts[i].split(\",\");\n        var nameParts = subParts[0].split(\":\");\n        var name_1 = nameParts[0];\n        var actualName = nameParts[0];\n        if (nameParts.length > 1) {\n            actualName = nameParts[1];\n        }\n        names.push(name_1);\n        actualNames.push(actualName);\n        //TODO: did we support string enums??\n        namesValuesMap[name_1] = parseInt(subParts[1]);\n        actualNamesValuesMap[actualName] = parseInt(subParts[1]);\n    }\n    var info = {\n        names: names,\n        actualNames: actualNames,\n        namesValuesMap: namesValuesMap,\n        actualNamesValuesMap: actualNamesValuesMap\n    };\n    t.enumInfo = info;\n    return t;\n}\nvar markTypeInitialized = false;\nexport function markType(t, name, baseType, interfaces, staticInitializer) {\n    if (baseType === void 0) {\n        baseType = Base.prototype.$type;\n    }\n    if (interfaces === void 0) {\n        interfaces = null;\n    }\n    if (staticInitializer === void 0) {\n        staticInitializer = null;\n    }\n    t.prototype.$type = new Type(t, name, baseType, interfaces, staticInitializer);\n    if (!markTypeInitialized) {\n        markTypeInitialized = true;\n        markType(Type, \"Type\");\n        markType(Base, \"Base\", null);\n    }\n    //TODO: do we need/want a flag on the function like we have in js?\n    if (typeof t.staticInit === \"function\") {\n        pendingStaticCtors.push(t);\n    }\n    //t.prototype.$ = t.prototype.$type;\n    t.$type = t.prototype.$type;\n    t.$ = t.prototype.$type;\n    return t.prototype.$type;\n}\nexport function callStaticConstructors() {\n    var e_1, _a;\n    if (pendingStaticCtors.length > 0) {\n        //TODO: is the copy of the array needed? \n        var classes = Array.from(pendingStaticCtors);\n        pendingStaticCtors.length = 0;\n        try {\n            for (var classes_1 = tslib_1.__values(classes), classes_1_1 = classes_1.next(); !classes_1_1.done; classes_1_1 = classes_1.next()) {\n                var c = classes_1_1.value;\n                c.staticInit();\n            }\n        }\n        catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n        }\n        finally {\n            try {\n                if (classes_1_1 && !classes_1_1.done && (_a = classes_1.return))\n                    _a.call(classes_1);\n            }\n            finally {\n                if (e_1)\n                    throw e_1.error;\n            }\n        }\n    }\n}\nexport var IConvertible_$type = /*@__PURE__*/ new Type(null, \"IConvertible\");\nvar Enum = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Enum, _super);\n    function Enum() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Enum.$t = markType(Enum, \"Enum\");\n    return Enum;\n}(Base));\nexport { Enum };\nvar EnumBox = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(EnumBox, _super);\n    function EnumBox(value, type) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.$type = type;\n        return _this;\n    }\n    EnumBox.prototype.getHashCode = function () {\n        return this.value;\n    };\n    // TODO: Fill out remaining IConvertible implementation\n    EnumBox.prototype.toDouble = function (provider) {\n        return this.value;\n    };\n    EnumBox.prototype.toString = function () {\n        return EnumUtil.getName(this.$type, this.value);\n    };\n    return EnumBox;\n}(Enum));\nexport function getBoxIfEnum($t, v) {\n    if (v !== null && $t) { // TODO: Remove the $t check here and fix the null ref issue\n        if ($t.isNullable) {\n            $t = $t.typeArguments[0];\n        }\n        if ($t.isEnumType) {\n            return enumGetBox($t, v);\n        }\n    }\n    return v;\n}\n;\nexport function enumGetBox($t, v) {\n    if (!$t._boxes) {\n        $t._boxes = {};\n    }\n    if (!$t._boxes[v]) {\n        $t._boxes[v] = new EnumBox(v, $t);\n    }\n    return $t._boxes[v];\n}\nvar EnumUtil = /** @class */ /*@__PURE__*/ (function () {\n    function EnumUtil() {\n    }\n    EnumUtil.getValueFromName = function (values, enumType, value, ignoreCase) {\n        if (values.hasOwnProperty(value)) {\n            return enumGetBox(enumType, values[value]);\n        }\n        else if (ignoreCase) {\n            var upper = value.toUpperCase();\n            for (var x in values) {\n                if (x.toUpperCase() === upper) {\n                    return enumGetBox(enumType, values[x]);\n                }\n            }\n        }\n        else {\n            // A.S. Nov 4, 2016 Adjusted to handle case where leading char is _.\n            var firstChar = value.charAt(0);\n            if (firstChar != \"_\") {\n                value = firstChar.toLowerCase() + value.substr(1);\n            }\n            else {\n                value = \"_\" + value.charAt(1).toLowerCase() + value.substr(2);\n            }\n            if (values.hasOwnProperty(value)) {\n                return enumGetBox(enumType, values[value]);\n            }\n        }\n        return null;\n    };\n    EnumUtil.parse = function (enumType, value, ignoreCase) {\n        //var info = Type.getDefinedNameAndNamespace(enumType.fullName);\n        //if (Type.canAssign(this.$type, enumType)) \n        {\n            //var p = info.namespace[ info.name ].prototype;\n            var values = enumType.isEnumType ? enumType.enumInfo.actualNamesValuesMap : enumType.InstanceConstructor.prototype;\n            var val = EnumUtil.getValueFromName(values, enumType, value, ignoreCase);\n            if (val !== null) {\n                return val;\n            }\n            if (enumType.isEnumType) {\n                values = enumType.enumInfo.namesValuesMap;\n                var val_1 = EnumUtil.getValueFromName(values, enumType, value, ignoreCase);\n                if (val_1 !== null) {\n                    return val_1;\n                }\n            }\n        }\n        throw new Error(\"Invalid \" + enumType.name + \" value: \" + value);\n    };\n    // static $getName(value: number): string {\n    // }\n    // static $value(): number {\n    // }\n    //private _v: number;\n    EnumUtil.enumHasFlag = function (value, flag) {\n        /*jslint bitwise: true */\n        return (value & flag) === flag;\n    };\n    EnumUtil.toString = function (enumType, value) {\n        return EnumUtil.getName(enumType, value);\n    };\n    EnumUtil.getName = function (enumType, v) {\n        if (enumType._nameMap == undefined) {\n            var vals = EnumUtil.getValues(enumType);\n            var names = enumType.isEnumType ? enumType.enumInfo.names : EnumUtil.getNames(enumType);\n            var map = {};\n            for (var i = 0; i < vals.length; i++) {\n                map[vals[i]] = names[i];\n            }\n            enumType._nameMap = map;\n        }\n        var lookup = enumType._nameMap;\n        return lookup[v];\n    };\n    EnumUtil.getFlaggedName = function (enumType, v, getName) {\n        var _this = this;\n        var names = [];\n        var original = v;\n        var zeroValueName;\n        var value;\n        var values = [];\n        for (var p in this) {\n            if (this.hasOwnProperty(p)) {\n                value = enumType[p];\n                if (typeof enumType[p] == \"number\") {\n                    values.push(p);\n                }\n            }\n        }\n        values.sort(function (a, b) { return _this[a] - _this[b]; });\n        for (var i = values.length - 1; i >= 0; i--) {\n            value = this[values[i]];\n            if (value === 0) {\n                zeroValueName = getName(0);\n            }\n            /*jslint bitwise: true */\n            else if ((v & value) === value) {\n                v -= value;\n                names.unshift(getName(value));\n            }\n        }\n        if (v !== 0) {\n            return original.toString();\n        }\n        if (original !== 0) {\n            return names.join(\", \");\n        }\n        return zeroValueName || \"0\";\n    };\n    EnumUtil.getValues = function ($t) {\n        var result = [];\n        if ($t.isEnumType) {\n            for (var i = 0; i < $t.enumInfo.actualNames.length; i++) {\n                result.push($t.enumInfo.actualNamesValuesMap[$t.enumInfo.actualNames[i]]);\n            }\n            return result;\n        }\n        var p = $t.isEnumType ?\n            $t.enumInfo.actualNames : $t.InstanceConstructor.prototype;\n        for (var member in p) {\n            if (p.hasOwnProperty(member)) {\n                if (typeof p[member] === \"number\") {\n                    result.push(p[member]);\n                }\n            }\n        }\n        return result;\n    };\n    EnumUtil.getNames = function ($t) {\n        var result = [];\n        if ($t.isEnumType) {\n            for (var i = 0; i < $t.enumInfo.actualNames.length; i++) {\n                result.push($t.enumInfo.actualNames[i]);\n            }\n            return result;\n        }\n        var p = $t.isEnumType ?\n            $t.enumInfo.actualNames : $t.InstanceConstructor.prototype;\n        for (var member in p) {\n            if (p.hasOwnProperty(member)) {\n                if (typeof p[member] === \"number\") {\n                    result.push(member);\n                }\n            }\n        }\n        return result;\n    };\n    EnumUtil.getEnumValue = function ($t, v) {\n        if (v !== null) {\n            if (typeof v === \"number\") {\n                return v;\n            }\n            else {\n                return v.value;\n            }\n        }\n        return 0;\n    };\n    EnumUtil.isDefined = function ($t, value) {\n        value = typeGetValue(value);\n        var p = $t.isEnumType ?\n            $t.enumInfo.actualNamesValuesMap : $t.InstanceConstructor.prototype;\n        for (var member in p) {\n            if (p.hasOwnProperty(member)) {\n                if (p[member] === value) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    // TODO: Fill out remaining IConvertible implementation\n    EnumUtil.toDouble = function (enumType, value, provider) {\n        return value.value;\n    };\n    EnumUtil.toObject = function ($t, value) {\n        return value;\n    };\n    EnumUtil.tryParse$1 = function ($tEnum, value, ignoreCase, result) {\n        try {\n            return {\n                ret: true,\n                p2: typeGetValue(EnumUtil.parse($tEnum, value, ignoreCase))\n            };\n        }\n        catch (e) {\n            result = Type.createInstance($tEnum);\n            return {\n                ret: false,\n                p2: result\n            };\n        }\n    };\n    return EnumUtil;\n}());\nexport { EnumUtil };\nvar ValueType = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ValueType, _super);\n    function ValueType() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ValueType.$t = markType(ValueType, \"ValueType\");\n    return ValueType;\n}(Base));\nexport { ValueType };\nvar Nullable = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Nullable, _super);\n    function Nullable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Nullable.getUnderlyingType = function (nullableType) {\n        if (nullableType.isGenericType !== undefined && nullableType.isGenericType &&\n            !nullableType.isGenericTypeDefinition &&\n            Nullable$1.prototype.$type.typeName == nullableType.typeName) {\n            return nullableType.genericTypeArguments[0];\n        }\n        return null;\n    };\n    Nullable.$t = markType(Nullable, \"Nullable\");\n    return Nullable;\n}(Base));\nexport { Nullable };\nvar Nullable$1 = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Nullable$1, _super);\n    function Nullable$1($t, value) {\n        var _this = _super.call(this) || this;\n        _this.$t = null;\n        _this._value = null;\n        _this.isNullable = true;\n        _this.$t = $t;\n        _this.$type = _this.$type.specialize(_this.$t);\n        if (value !== undefined) {\n            _this._value = value;\n        }\n        return _this;\n    }\n    Nullable$1.nullableEquals = function (v1, v2) {\n        /*jshint eqnull:true */\n        var v1IsNull = (v1 == null) || (!!v1.isNullable && !v1.hasValue);\n        var v2IsNull = (v2 == null) || (!!v2.isNullable && !v2.hasValue);\n        if (v1IsNull && v2IsNull) {\n            return true;\n        }\n        if (v1IsNull != v2IsNull) {\n            return false;\n        }\n        var val1 = v1;\n        var val2 = v2;\n        if (v1.isNullable) {\n            val1 = v1.value;\n        }\n        if (v2.isNullable) {\n            val2 = v2.value;\n        }\n        return val1 == val2;\n    };\n    Nullable$1.prototype.equals = function (value) {\n        return Nullable$1.nullableEquals(this, value);\n    };\n    Nullable$1.prototype.getHashCode = function () {\n        if (this._value === null) {\n            return 0;\n        }\n        if (this._value[\"getHashCode\"] !== undefined) {\n            return this._value.getHashCode();\n        }\n        return Type.getPrimitiveHashCode(this._value);\n    };\n    Object.defineProperty(Nullable$1.prototype, \"hasValue\", {\n        get: function () {\n            return this._value !== null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Nullable$1.prototype.toString = function () {\n        return this._value === null ? \"\" : this._value.toString();\n    };\n    Object.defineProperty(Nullable$1.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (value) {\n            this._value = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Nullable$1.prototype.getValueOrDefault = function () {\n        if (this.hasValue) {\n            return this._value;\n        }\n        else {\n            return this.getDefaultValue();\n        }\n    };\n    Nullable$1.prototype.getDefaultValue = function () {\n        if (Type.canAssign(Number_$type, this.$t)) {\n            return 0;\n        }\n        else if (Type.canAssign(Boolean_$type, this.$t)) {\n            return false;\n        }\n        else if (this.$t.baseType == ValueType.prototype.$type) {\n            return Type.createInstance(this.$t);\n        }\n        else {\n            return null;\n        }\n    };\n    Nullable$1.prototype.getValueOrDefault1 = function (defaultValue) {\n        if (this.hasValue) {\n            return this._value;\n        }\n        else {\n            return defaultValue;\n        }\n    };\n    Nullable$1.prototype.preIncrement = function () {\n        if (!this.hasValue) {\n            return this;\n        }\n        this._value = (this._value + 1);\n        return this;\n    };\n    Nullable$1.prototype.preDecrement = function () {\n        if (!this.hasValue) {\n            return this;\n        }\n        this._value = (this._value - 1);\n        return this;\n    };\n    Nullable$1.prototype.postIncrement = function () {\n        if (!this.hasValue) {\n            return this;\n        }\n        var originalValue = this._value;\n        this._value = (this._value + 1);\n        return new Nullable$1(this.$t, originalValue);\n    };\n    Nullable$1.prototype.postDecrement = function () {\n        if (!this.hasValue) {\n            return this;\n        }\n        var originalValue = this._value;\n        this._value = (this._value - 1);\n        return new Nullable$1(this.$t, originalValue);\n    };\n    Nullable$1.$t = markType(Nullable$1, \"Nullable$1\");\n    return Nullable$1;\n}(Base));\nexport { Nullable$1 };\nexport function toNullable(t, value) {\n    if (value == null) {\n        return t._$nullNullable || (t._$nullNullable = new Nullable$1(t, null));\n    }\n    else if (value.isNullable) {\n        return value;\n    }\n    return new Nullable$1(t, value);\n}\nexport var IComparable_$type = /*@__PURE__*/ new Type(null, \"IComparable\");\nexport var IComparable$1_$type = /*@__PURE__*/ new Type(null, \"IComparable$1\");\nexport var IEquatable$1_$type = /*@__PURE__*/ new Type(null, \"IEquatable$1\");\nexport var INotifyPropertyChanged_$type = /*@__PURE__*/ new Type(null, \"INotifyPropertyChanged\");\nvar PropertyChangedEventArgs = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(PropertyChangedEventArgs, _super);\n    function PropertyChangedEventArgs(propertyName) {\n        var _this = _super.call(this) || this;\n        _this._propertyName = null;\n        _this._propertyName = propertyName;\n        return _this;\n    }\n    Object.defineProperty(PropertyChangedEventArgs.prototype, \"propertyName\", {\n        get: function () {\n            return this._propertyName;\n        },\n        set: function (value) {\n            this._propertyName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PropertyChangedEventArgs.$t = markType(PropertyChangedEventArgs, \"PropertyChangedEventArgs\");\n    return PropertyChangedEventArgs;\n}(Base));\nexport { PropertyChangedEventArgs };\nvar IteratorWrapper = /** @class */ /*@__PURE__*/ (function () {\n    function IteratorWrapper(inner, getNew) {\n        this._inner = null;\n        this._getNew = null;\n        this._hasNext = true;\n        this._current = null;\n        this._inner = inner;\n        this._getNew = getNew;\n    }\n    IteratorWrapper.prototype.moveNext = function () {\n        var next = this._inner.next();\n        this._hasNext = !next.done;\n        this._current = next.value;\n        return this._hasNext;\n    };\n    Object.defineProperty(IteratorWrapper.prototype, \"current\", {\n        get: function () {\n            return this._current;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IteratorWrapper.prototype, \"currentObject\", {\n        get: function () {\n            return this._current;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    IteratorWrapper.prototype.dispose = function () {\n    };\n    IteratorWrapper.prototype.reset = function () {\n        this._inner = this._getNew();\n        this._current = null;\n        this._hasNext = true;\n    };\n    return IteratorWrapper;\n}());\nexport { IteratorWrapper };\nvar IterableWrapper = /** @class */ /*@__PURE__*/ (function () {\n    function IterableWrapper(inner) {\n        this._inner = null;\n        this._inner = inner;\n    }\n    IterableWrapper.prototype.getEnumerator = function () {\n        var _this = this;\n        return new IteratorWrapper(this._inner()[Symbol.iterator](), function () { return _this._inner()[Symbol.iterator](); });\n    };\n    IterableWrapper.prototype.getEnumeratorObject = function () {\n        var _this = this;\n        return new IteratorWrapper(this._inner()[Symbol.iterator](), function () { return _this._inner()[Symbol.iterator](); });\n    };\n    return IterableWrapper;\n}());\nexport { IterableWrapper };\nvar EnumeratorWrapper = /** @class */ /*@__PURE__*/ (function () {\n    function EnumeratorWrapper(inner) {\n        this._inner = null;\n        this._inner = inner;\n    }\n    EnumeratorWrapper.prototype.next = function () {\n        var done = !this._inner.moveNext();\n        var value = null;\n        if (!done) {\n            value = this._inner.current;\n        }\n        return {\n            done: done,\n            value: value\n        };\n    };\n    return EnumeratorWrapper;\n}());\nexport { EnumeratorWrapper };\nvar EnumeratorWrapperObject = /** @class */ /*@__PURE__*/ (function () {\n    function EnumeratorWrapperObject(inner) {\n        this._inner = null;\n        this._inner = inner;\n    }\n    EnumeratorWrapperObject.prototype.next = function () {\n        var done = !this._inner.moveNext();\n        var value = null;\n        if (!done) {\n            value = this._inner.currentObject;\n        }\n        return {\n            done: done,\n            value: value\n        };\n    };\n    return EnumeratorWrapperObject;\n}());\nexport { EnumeratorWrapperObject };\nexport function getEn(arr) {\n    var arr_1, arr_1_1, item, e_2_1;\n    var e_2, _a;\n    return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                _b.trys.push([0, 5, 6, 7]);\n                arr_1 = tslib_1.__values(arr), arr_1_1 = arr_1.next();\n                _b.label = 1;\n            case 1:\n                if (!!arr_1_1.done)\n                    return [3 /*break*/, 4];\n                item = arr_1_1.value;\n                return [4 /*yield*/, item];\n            case 2:\n                _b.sent();\n                _b.label = 3;\n            case 3:\n                arr_1_1 = arr_1.next();\n                return [3 /*break*/, 1];\n            case 4: return [3 /*break*/, 7];\n            case 5:\n                e_2_1 = _b.sent();\n                e_2 = { error: e_2_1 };\n                return [3 /*break*/, 7];\n            case 6:\n                try {\n                    if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return))\n                        _a.call(arr_1);\n                }\n                finally {\n                    if (e_2)\n                        throw e_2.error;\n                }\n                return [7 /*endfinally*/];\n            case 7: return [2 /*return*/];\n        }\n    });\n}\nexport function getEnumeratorObject(en) {\n    if ((en instanceof Array || Array.isArray(en))) {\n        var arr_2 = en;\n        return new IteratorWrapper(getEn(arr_2), function () { return getEn(arr_2); });\n    }\n    return en.getEnumeratorObject();\n}\nexport function getEnumerator(en) {\n    if ((en instanceof Array || Array.isArray(en))) {\n        var arr_3 = en;\n        return new IteratorWrapper(getEn(arr_3), function () { return getEn(arr_3); });\n    }\n    return en.getEnumerator();\n}\nvar EnumerableWrapper = /** @class */ /*@__PURE__*/ (function () {\n    function EnumerableWrapper(inner) {\n        this._inner = null;\n        this._inner = inner;\n    }\n    EnumerableWrapper.prototype[Symbol.iterator] = function () {\n        return new EnumeratorWrapper(getEnumerator(this._inner));\n    };\n    return EnumerableWrapper;\n}());\nexport { EnumerableWrapper };\nvar EnumerableWrapperObject = /** @class */ /*@__PURE__*/ (function () {\n    function EnumerableWrapperObject(inner) {\n        this._inner = null;\n        this._inner = inner;\n    }\n    EnumerableWrapperObject.prototype[Symbol.iterator] = function () {\n        return new EnumeratorWrapperObject(getEnumeratorObject(this._inner));\n    };\n    return EnumerableWrapperObject;\n}());\nexport { EnumerableWrapperObject };\nexport function toEnum(v) {\n    return new IterableWrapper(v);\n}\nexport function fromEnum(v) {\n    return new EnumerableWrapper(v);\n}\nexport function toEn(v) {\n    return new IterableWrapper(v);\n}\nexport function fromEn(v) {\n    return new EnumerableWrapperObject(v);\n}\nexport function fromDict(v) {\n    var v_1, v_1_1, item, _a, key, value, e_3_1;\n    var e_3, _b;\n    return tslib_1.__generator(this, function (_c) {\n        switch (_c.label) {\n            case 0:\n                _c.trys.push([0, 5, 6, 7]);\n                v_1 = tslib_1.__values(v), v_1_1 = v_1.next();\n                _c.label = 1;\n            case 1:\n                if (!!v_1_1.done)\n                    return [3 /*break*/, 4];\n                item = v_1_1.value;\n                _a = tslib_1.__read(item, 2), key = _a[0], value = _a[1];\n                return [4 /*yield*/, { key: key, value: value }];\n            case 2:\n                _c.sent();\n                _c.label = 3;\n            case 3:\n                v_1_1 = v_1.next();\n                return [3 /*break*/, 1];\n            case 4: return [3 /*break*/, 7];\n            case 5:\n                e_3_1 = _c.sent();\n                e_3 = { error: e_3_1 };\n                return [3 /*break*/, 7];\n            case 6:\n                try {\n                    if (v_1_1 && !v_1_1.done && (_b = v_1.return))\n                        _b.call(v_1);\n                }\n                finally {\n                    if (e_3)\n                        throw e_3.error;\n                }\n                return [7 /*endfinally*/];\n            case 7: return [2 /*return*/];\n        }\n    });\n}\nexport var Number_$type = /*@__PURE__*/ new Type(Number, \"Number\", Base.prototype.$type, [IComparable_$type, IConvertible_$type]);\nexport var String_$type = /*@__PURE__*/ new Type(String, \"String\", Base.prototype.$type, [IComparable_$type, IConvertible_$type]);\nexport var Date_$type = /*@__PURE__*/ new Type(Date, \"Date\", Base.prototype.$type, [IComparable_$type, IConvertible_$type]);\nexport var Boolean_$type = /*@__PURE__*/ new Type(Boolean, \"Boolean\", Base.prototype.$type, [IComparable_$type, IConvertible_$type]);\nexport var Void_$type = /*@__PURE__*/ new Type(null, \"Void\", Base.prototype.$type);\nexport var n$ = Number_$type;\nexport var s$ = String_$type;\nexport var d$ = Date_$type;\nexport var b$ = Boolean_$type;\nexport var v$ = Void_$type;\nexport var Delegate_$type = /*@__PURE__*/ new Type(null, \"Delegate\");\nexport function runOn(target, func) {\n    var self = func;\n    var ret = function () {\n        return self.apply(target, arguments);\n    };\n    ret.original = self;\n    ret.target = target;\n    return ret;\n}\nexport function delegateCombine(del1, del2) {\n    if (!del1) {\n        return del2;\n    }\n    if (!del2) {\n        return del1;\n    }\n    var ret = function () {\n        del1.apply(null, arguments);\n        return del2.apply(null, arguments);\n    };\n    ret.enumerate = function (arr) {\n        if (del1) {\n            if (del1.enumerate) {\n                del1.enumerate(arr);\n            }\n            else {\n                arr.push(del1);\n            }\n        }\n        if (del2) {\n            if (del2.enumerate) {\n                del2.enumerate(arr);\n            }\n            else {\n                arr.push(del2);\n            }\n        }\n    };\n    return ret;\n}\n;\nexport function delegateRemove(del1, del2) {\n    if (!del1) {\n        return null;\n    }\n    if (!del2) {\n        return del1;\n    }\n    var arr = [];\n    var del = null;\n    if (del1.enumerate) {\n        del1.enumerate(arr);\n    }\n    else {\n        arr.push(del1);\n    }\n    for (var i = 0; i < arr.length; i++) {\n        if (del2.original) {\n            if (arr[i].original == del2.original &&\n                arr[i].target == del2.target) {\n                continue;\n            }\n        }\n        if (arr[i] == del2) {\n            continue;\n        }\n        del = delegateCombine(del, arr[i]);\n    }\n    return del;\n}\n;\nexport var IDisposable_$type = /*@__PURE__*/ new Type(null, 'IDisposable');\nexport var IEnumerable_$type = /*@__PURE__*/ new Type(null, \"IEnumerable\");\nexport var IEnumerator_$type = /*@__PURE__*/ new Type(null, \"IEnumerator\");\nexport var IEqualityComparer$1_$type = /*@__PURE__*/ new Type(null, \"IEqualityComparer$1\");\nexport var IEqualityComparer_$type = /*@__PURE__*/ new Type(null, \"IEqualityComparer\");\nexport var ICollection_$type = /*@__PURE__*/ new Type(null, \"ICollection\", null, [IEnumerable_$type]);\nexport var IList_$type = /*@__PURE__*/ new Type(null, \"IList\", null, [IEnumerable_$type, ICollection_$type]);\nexport var IEnumerable$1_$type = /*@__PURE__*/ new Type(null, \"IEnumerable$1\", null, [IEnumerable_$type]);\nexport var ICollection$1_$type = /*@__PURE__*/ new Type(null, \"ICollection$1\", null, [/*@__PURE__*/ IEnumerable$1_$type.specialize(0), IEnumerable_$type]);\nexport var IList$1_$type = /*@__PURE__*/ new Type(null, \"IList$1\", null, [\n    /*@__PURE__*/ ICollection$1_$type.specialize(0),\n    /*@__PURE__*/ IEnumerable$1_$type.specialize(0),\n    IEnumerable_$type\n]);\nexport var IEnumerator$1_$type = /*@__PURE__*/ new Type(null, \"IEnumerator$1\", null, [IEnumerator_$type, IDisposable_$type]);\nexport var IDictionary_$type = /*@__PURE__*/ new Type(null, \"IDictionary\");\nvar BaseError = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BaseError, _super);\n    function BaseError(initNumber) {\n        if (initNumber === void 0) {\n            initNumber = -1;\n        }\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var _this = _super.call(this) || this;\n        _this._message = null;\n        _this._innerException = null;\n        if (initNumber >= 0) {\n            switch (initNumber) {\n                case 1:\n                    _this.init1.apply(_this, arguments);\n                    break;\n                case 2:\n                    _this.init2.apply(_this, arguments);\n                    break;\n            }\n        }\n        return _this;\n    }\n    BaseError.prototype.get_message = function () {\n        return this._message;\n    };\n    Object.defineProperty(BaseError.prototype, \"message\", {\n        get: function () {\n            return this.get_message();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseError.prototype, \"innerException\", {\n        get: function () {\n            return this._innerException;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BaseError.prototype.init1 = function (initNumber, message) {\n        this._message = message;\n    };\n    BaseError.prototype.init2 = function (initNumber, message, innerException) {\n        this._message = message;\n        this._innerException = innerException;\n    };\n    BaseError.prototype.toString = function () {\n        return this._message;\n    };\n    BaseError.$t = markType(BaseError, \"BaseError\");\n    return BaseError;\n}(Base));\nexport { BaseError };\nvar SystemException = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SystemException, _super);\n    function SystemException(initNumber) {\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var _this = _super.call(this, 0) || this;\n        if (initNumber > 0) {\n            switch (initNumber) {\n                case 1:\n                    _this.init1.apply(_this, arguments);\n                    break;\n                case 2:\n                    _this.init2.apply(_this, arguments);\n                    break;\n            }\n            return _this;\n        }\n        return _this;\n        //super(0);\n    }\n    SystemException.prototype.init1 = function (initNumber, message) {\n        _super.prototype.init1.call(this, 1, message);\n    };\n    SystemException.prototype.init2 = function (initNumber, message, innerException) {\n        _super.prototype.init2.call(this, 2, message, innerException);\n    };\n    SystemException.$t = markType(SystemException, \"SystemException\", BaseError.prototype.$type);\n    return SystemException;\n}(BaseError));\nexport { SystemException };\nvar NotSupportedException = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(NotSupportedException, _super);\n    function NotSupportedException(initNumber) {\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var _this = _super.call(this, 0) || this;\n        if (initNumber > 0) {\n            switch (initNumber) {\n                case 1:\n                    _this.init1.apply(_this, arguments);\n                    break;\n                case 2:\n                    _this.init2.apply(_this, arguments);\n                    break;\n            }\n            return _this;\n        }\n        return _this;\n    }\n    NotSupportedException.prototype.init1 = function (initNumber, message) {\n        _super.prototype.init1.call(this, 1, message);\n    };\n    NotSupportedException.prototype.init2 = function (initNumber, message, innerException) {\n        _super.prototype.init2.call(this, 2, message, innerException);\n    };\n    NotSupportedException.$t = markType(NotSupportedException, \"NotSupportedException\", SystemException.prototype.$type);\n    return NotSupportedException;\n}(SystemException));\nexport { NotSupportedException };\nvar FormatException = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(FormatException, _super);\n    function FormatException(initNumber) {\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var _this = _super.call(this, 0) || this;\n        if (initNumber > 0) {\n            switch (initNumber) {\n                case 1:\n                    _this.init1.apply(_this, arguments);\n                    break;\n                case 2:\n                    _this.init2.apply(_this, arguments);\n                    break;\n            }\n            return _this;\n        }\n        return _this;\n    }\n    FormatException.prototype.init1 = function (initNumber, message) {\n        _super.prototype.init1.call(this, 1, message);\n    };\n    FormatException.prototype.init2 = function (initNumber, message, innerException) {\n        _super.prototype.init2.call(this, 2, message, innerException);\n    };\n    FormatException.$t = markType(FormatException, \"FormatException\", SystemException.prototype.$type);\n    return FormatException;\n}(SystemException));\nexport { FormatException };\nvar PointUtil = /** @class */ /*@__PURE__*/ (function () {\n    function PointUtil() {\n    }\n    PointUtil.equals = function (p1, p2) {\n        if (p1 == null && p2 == null) {\n            return true;\n        }\n        if (p1 == null && p2 != null) {\n            return false;\n        }\n        if (p1 != null && p2 == null) {\n            return false;\n        }\n        return p1.x == p2.x && p1.y == p2.y;\n    };\n    PointUtil.notEquals = function (p1, p2) {\n        return !PointUtil.equals(p1, p2);\n    };\n    PointUtil.create = function () {\n        return { x: 0, y: 0, $type: Point_$type };\n    };\n    PointUtil.createXY = function (x, y) {\n        return { x: x, y: y, $type: Point_$type };\n    };\n    return PointUtil;\n}());\nexport { PointUtil };\nexport var Point_$type = /*@__PURE__*/ new Type(null, \"Point\");\nexport var SeekOrigin = /*@__PURE__*/ (function (SeekOrigin) {\n    SeekOrigin[SeekOrigin[\"Begin\"] = 0] = \"Begin\";\n    SeekOrigin[SeekOrigin[\"Current\"] = 1] = \"Current\";\n    SeekOrigin[SeekOrigin[\"End\"] = 2] = \"End\";\n    return SeekOrigin;\n})({});\nvar Stream = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Stream, _super);\n    function Stream() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Stream.prototype.close = function () {\n        this.disposeCore(true);\n    };\n    Stream.prototype.dispose = function () {\n        this.close();\n    };\n    Stream.prototype.disposeCore = function (disposing) {\n    };\n    Stream.prototype.readByte = function () {\n        var bytes = [0];\n        var count = this.read(bytes, 0, 1);\n        if (count === 0) {\n            return -1;\n        }\n        return bytes[0];\n    };\n    Stream.prototype.writeByte = function (value) {\n        this.write([value], 0, 1);\n    };\n    Stream.$t = markType(Stream, \"Stream\");\n    return Stream;\n}(Base));\nexport { Stream };\nvar EventArgs = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(EventArgs, _super);\n    function EventArgs() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(EventArgs, \"empty\", {\n        get: function () {\n            if (EventArgs._empty) {\n                return EventArgs._empty;\n            }\n            EventArgs._empty = new EventArgs;\n            return EventArgs._empty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EventArgs.$t = markType(EventArgs, \"EventArgs\");\n    return EventArgs;\n}(Base));\nexport { EventArgs };\nexport var IFormatProvider_$type = /*@__PURE__*/ new Type(null, 'IFormatProvider');\nexport var Array_$type = /*@__PURE__*/ new Type(Array, \"Array\", Base.prototype.$type, [IEnumerable_$type, ICollection_$type]);\nexport var a$ = Array_$type;\nvar TypeRegistrar = /** @class */ /*@__PURE__*/ (function () {\n    function TypeRegistrar() {\n    }\n    TypeRegistrar.create = function (typeName) {\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        if (TypeRegistrar.isRegistered(typeName)) {\n            var C = TypeRegistrar.get(typeName);\n            if (C.htmlTagName) {\n                return document.createElement(C.htmlTagName);\n            }\n            else {\n                return new (C.bind.apply(C, tslib_1.__spread([void 0], rest)))();\n            }\n        }\n        else {\n            return null;\n        }\n    };\n    TypeRegistrar.register = function (typeName, type) {\n        TypeRegistrar._registrar.set(typeName, type.InstanceConstructor);\n    };\n    TypeRegistrar.registerCons = function (typeName, type) {\n        TypeRegistrar._registrar.set(typeName, type);\n    };\n    TypeRegistrar.callRegister = function (typeName) {\n        var type = TypeRegistrar.get(typeName);\n        if (type !== undefined && type !== null &&\n            type[\"register\"] !== undefined) {\n            type[\"register\"]();\n        }\n    };\n    TypeRegistrar.isRegistered = function (typeName) {\n        return TypeRegistrar.get(typeName) !== null;\n    };\n    TypeRegistrar.get = function (typeName) {\n        if (TypeRegistrar._registrar.has(typeName)) {\n            return TypeRegistrar._registrar.get(typeName);\n        }\n        if (typeName.indexOf(\"Igx\") == 0) {\n            var igc = typeName.replace(\"Igx\", \"Igc\");\n            if (TypeRegistrar._registrar.has(igc)) {\n                return TypeRegistrar._registrar.get(igc);\n            }\n            var igr = typeName.replace(\"Igx\", \"Igr\");\n            if (igr.indexOf(\"Component\") == igr.length - 9) {\n                igr = igr.substring(0, igr.length - 9);\n            }\n            if (TypeRegistrar._registrar.has(igr)) {\n                return TypeRegistrar._registrar.get(igr);\n            }\n        }\n        return null;\n    };\n    TypeRegistrar.createFromInternal = function (internal, prefix, postfix) {\n        if (!internal) {\n            return null;\n        }\n        if (!internal.$type) {\n            return null;\n        }\n        var name = internal.$type.name;\n        var externalName = prefix + name + postfix;\n        if (!TypeRegistrar.isRegistered(externalName)) {\n            return null;\n        }\n        return TypeRegistrar.create(externalName);\n    };\n    TypeRegistrar._registrar = new Map();\n    return TypeRegistrar;\n}());\nexport { TypeRegistrar };\n//# sourceMappingURL=type.js.map\n"]},"metadata":{},"sourceType":"module"}
/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { PathSegment } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { Tuple$2 } from "igniteui-react-core";
import { PolyLineSegment } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
/**
 * @hidden
 */
export let RadialGaugeRangeFrame = /*@__PURE__*/ (() => {
    class RadialGaugeRangeFrame extends Base {
        constructor() {
            super(...arguments);
            this.f = 0;
            this.g = 0;
            this.e = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.k = null;
            this.l = null;
            this.h = 0;
        }
        static a(a, b, c, d) {
            let e = new RadialGaugeRangeFrame();
            e.k = BrushUtil.k(c.k, a, d.k, 0);
            e.l = BrushUtil.k(c.l, a, d.l, 0);
            e.h = b * c.h + a * d.h;
            e.f = b * c.f + a * d.f;
            e.g = b * c.g + a * d.g;
            e.e = b * c.e + a * d.e;
            e.b = b * c.b + a * d.b;
            e.c = b * c.c + a * d.c;
            e.d = b * c.d + a * d.d;
            return e;
        }
        m(a, b, c) {
            let d = new PathGeometry();
            let e = new PathFigure();
            let f = 4;
            let g = 1 / a;
            let h = false;
            if (Math.abs(this.g - this.d) < g) {
                h = true;
            }
            let i = false;
            if (Math.abs(this.f - this.c) < g) {
                i = true;
            }
            let j = false;
            if ((this.b - this.e) >= 2 * Math.PI) {
                j = true;
            }
            if (i && h && j) {
                let k = this.i(0, Math.PI, this.g, a, b, c, true);
                e._startPoint = k.c;
                let l = this.i(Math.PI, 0, this.g, a, b, c, true);
                let m = new PathFigure();
                let n = this.i(0, Math.PI, this.f, a, b, c, false);
                m._startPoint = n.c;
                let o = this.i(Math.PI, 0, this.f, a, b, c, false);
                e._segments.add(k.d);
                e._segments.add(l.d);
                m._segments.add(n.d);
                m._segments.add(o.d);
                d.c.add(e);
                d.c.add(m);
                return d;
            }
            let p = null;
            if (h) {
                let q = this.i(this.e, this.b, Math.max(0, this.g), a, b, c, true);
                e._startPoint = q.c;
                p = q.d;
            }
            else {
                let r = this.j(this.e, this.b, this.g, this.d, a, b, c, true, f);
                e._startPoint = r.c;
                p = r.d;
            }
            let s = null;
            let t = new LineSegment(1);
            if (i) {
                let u = this.i(this.e, this.b, Math.max(0, this.f), a, b, c, false);
                s = u.d;
                t.c = u.c;
            }
            else {
                let v = this.j(this.e, this.b, this.f, this.c, a, b, c, false, f);
                s = v.d;
                t.c = v.c;
            }
            e._segments.add(p);
            e._segments.add(t);
            e._segments.add(s);
            e._isFilled = true;
            e._isClosed = true;
            d.c.add(e);
            return d;
        }
        j(a, b, c, d, e, f, g, h, i) {
            let j = new PolyLineSegment();
            let k = e * c;
            let l = e * d;
            let m = Math.max(k, l);
            let n = m + m;
            let o = Math.asin(i / n) * 2;
            let p;
            let q;
            let r;
            let s = l - k;
            let t = Math.abs(b - a);
            let u = j._points;
            if (h) {
                let v;
                for (v = a; v < b; v += o) {
                    r = (v - a) / t;
                    q = k + r * s;
                    p = { $type: Point_$type, x: f + Math.cos(v) * q, y: g + Math.sin(v) * q };
                    u.add(p);
                }
                v = b;
                r = (v - a) / t;
                q = k + r * s;
                p = { $type: Point_$type, x: f + Math.cos(v) * q, y: g + Math.sin(v) * q };
                u.add(p);
            }
            else {
                let w;
                for (w = b; w > a; w -= o) {
                    r = (w - b) / t;
                    q = l + r * s;
                    p = { $type: Point_$type, x: f + Math.cos(w) * q, y: g + Math.sin(w) * q };
                    u.add(p);
                }
                w = a;
                r = (w - b) / t;
                q = l + r * s;
                p = { $type: Point_$type, x: f + Math.cos(w) * q, y: g + Math.sin(w) * q };
                u.add(p);
            }
            return new Tuple$2(Point_$type, PathSegment.$, u._inner[0], j);
        }
        i(a, b, c, d, e, f, g) {
            let h = c * d;
            let i = new ArcSegment();
            i.d = g ? 1 : 0;
            i.b = b - a > Math.PI;
            i.f = new Size(1, h, h);
            let j = g ? b : a;
            let k = g ? a : b;
            i.e = { $type: Point_$type, x: e + Math.cos(j) * h, y: f + Math.sin(j) * h };
            let l = { $type: Point_$type, x: e + Math.cos(k) * h, y: f + Math.sin(k) * h };
            return new Tuple$2(Point_$type, PathSegment.$, l, i);
        }
    }
    RadialGaugeRangeFrame.$t = /*@__PURE__*/ markType(RadialGaugeRangeFrame, 'RadialGaugeRangeFrame');
    return RadialGaugeRangeFrame;
})();
//# sourceMappingURL=RadialGaugeRangeFrame.js.map

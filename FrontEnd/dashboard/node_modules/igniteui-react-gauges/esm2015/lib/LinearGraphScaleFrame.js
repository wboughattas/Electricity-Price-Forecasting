/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { LinearGraphRectFrame } from "./LinearGraphRectFrame";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { InterpolationUtil } from "igniteui-react-core";
import { LinearGraphNeedleFrame } from "./LinearGraphNeedleFrame";
/**
 * @hidden
 */
export let LinearGraphScaleFrame = /*@__PURE__*/ (() => {
    class LinearGraphScaleFrame extends Base {
        constructor() {
            super();
            this.m = null;
            this.u = 0;
            this.r = 0;
            this.s = 0;
            this.t = 0;
            this.l = null;
            this.j = null;
            this.w = 0;
            this.v = 0;
            this.ad = null;
            this.x = 0;
            this.i = null;
            this.p = 0;
            this.o = 0;
            this.ac = null;
            this.q = 0;
            this.e = null;
            this.d = null;
            this.f = null;
            this.c = null;
            this.g = null;
            this.h = null;
            this.n = 0;
            this.ab = null;
            this.m = new List$1(LinearGraphRectFrame.$, 0);
            this.j = new Array(0);
            this.i = new Array(0);
            this.e = new Array(0);
            this.d = new Array(0);
            this.f = new Array(0);
            this.c = new Array(0);
            this.g = new Array(0);
            this.h = new Array(0);
            this.l = new LinearGraphRectFrame();
        }
        ae(a, b, c, d) {
            let e = new PathGeometry();
            let f = new PathFigure();
            let g = a.x;
            let h = a.y;
            let i, j, k, l;
            if (d == 1) {
                i = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + b * this.s, y: h };
                    return $ret;
                })());
                j = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + b * this.t, y: h };
                    return $ret;
                })());
                k = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + b * this.t, y: h + c };
                    return $ret;
                })());
                l = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + b * this.s, y: h + c };
                    return $ret;
                })());
            }
            else {
                i = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g, y: b * (1 - this.t) };
                    return $ret;
                })());
                j = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + c, y: b * (1 - this.t) };
                    return $ret;
                })());
                k = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + c, y: b * (1 - this.s) };
                    return $ret;
                })());
                l = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g, y: b * (1 - this.s) };
                    return $ret;
                })());
            }
            f._startPoint = i.c;
            f._segments.add(j);
            f._segments.add(k);
            f._segments.add(l);
            f._isClosed = true;
            e.c.add(f);
            return e;
        }
        y(a, b, c) {
            this.ad = BrushUtil.k(b.ad, a, c.ad, 0);
            this.ac = BrushUtil.k(b.ac, a, c.ac, 0);
            if (b.ab == null && c.ab == null) {
                this.ab = null;
            }
            else {
                this.ab = BrushUtil.k(b.ab, a, c.ab, 0);
            }
            this.u = b.u + (c.u - b.u) * a;
            this.r = b.r + (c.r - b.r) * a;
            this.s = b.s + (c.s - b.s) * a;
            this.t = b.t + (c.t - b.t) * a;
            this.n = b.n + (c.n - b.n) * a;
            this.w = b.w + (c.w - b.w) * a;
            this.v = b.v + (c.v - b.v) * a;
            this.p = b.p + (c.p - b.p) * a;
            this.o = b.o + (c.o - b.o) * a;
            this.x = b.x + (c.x - b.x) * a;
            this.q = b.q + (c.q - b.q) * a;
            this.j = this.a(a, this.j, b.j, c.j);
            this.i = this.a(a, this.i, b.i, c.i);
            this.e = this.a(a, this.e, b.e, c.e);
            this.f = this.a(a, this.f, b.f, c.f);
            this.c = this.a(a, this.c, b.c, c.c);
            this.g = this.a(a, this.g, b.g, c.g);
            this.h = this.a(a, this.h, b.h, c.h);
            this.d = this.b(a, this.d, b.d, c.d);
            this.aa(a, this.m, b.m, c.m);
            this.l = this.k(a, b.l, c.l);
        }
        a(a, b, c, d) {
            let e = Math.max(c.length, d.length);
            let f = Math.min(c.length, d.length);
            if (b.length != e) {
                b = new Array(e);
            }
            let g = 0;
            if (c.length > 0) {
                g = c[c.length - 1];
            }
            let h = 0;
            if (d.length > 0) {
                h = d[d.length - 1];
            }
            let i = c.length > d.length;
            let j = 0;
            for (j = 0; j < f; j++) {
                b[j] = c[j] + (d[j] - c[j]) * a;
            }
            let k;
            let l;
            for (j = f; j < e; j++) {
                if (i) {
                    k = c[j];
                    l = h;
                }
                else {
                    k = g;
                    l = d[j];
                }
                b[j] = k + (l - k) * a;
            }
            return b;
        }
        b(a, b, c, d) {
            let e = Math.max(c.length, d.length);
            let f = Math.min(c.length, d.length);
            if (b.length != e) {
                b = new Array(e);
            }
            let g = null;
            if (c.length > 0) {
                g = c[c.length - 1];
            }
            let h = null;
            if (d.length > 0) {
                h = d[d.length - 1];
            }
            let i = c.length > d.length;
            let j = 0;
            for (j = 0; j < f; j++) {
                b[j] = d[j];
            }
            let k;
            let l;
            for (j = f; j < e; j++) {
                if (i) {
                    k = c[j];
                    l = h;
                }
                else {
                    k = g;
                    l = d[j];
                }
                if (l != null) {
                    b[j] = l;
                }
                else {
                    b[j] = k;
                }
            }
            return b;
        }
        aa(a, b, c, d) {
            InterpolationUtil.c(LinearGraphRectFrame.$, b, a, c, d, () => new LinearGraphRectFrame(), LinearGraphRectFrame.a);
        }
        k(a, b, c) {
            let d = 1 - a;
            return LinearGraphRectFrame.a(a, d, b, c);
        }
        z(a, b, c, d) {
            InterpolationUtil.c(LinearGraphNeedleFrame.$, b, a, c, d, () => new LinearGraphNeedleFrame(), LinearGraphNeedleFrame.a);
        }
    }
    LinearGraphScaleFrame.$t = /*@__PURE__*/ markType(LinearGraphScaleFrame, 'LinearGraphScaleFrame');
    return LinearGraphScaleFrame;
})();
//# sourceMappingURL=LinearGraphScaleFrame.js.map

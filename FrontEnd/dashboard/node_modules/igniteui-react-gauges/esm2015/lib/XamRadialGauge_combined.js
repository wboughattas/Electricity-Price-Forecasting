/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Control } from "igniteui-react-core";
import { INotifyPropertyChanged_$type, Base, PropertyChangedEventArgs, runOn, delegateCombine, Point_$type, Number_$type, enumGetBox, Delegate_$type, typeCast, String_$type, Array_$type, delegateRemove, fromEn, fromEnum, markType, markDep, TypeRegistrar } from "igniteui-react-core";
import { DoubleAnimator } from "igniteui-react-core";
import { BrushCollection } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { SweepDirection_$type } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { RadialGaugeNeedleShape_$type } from "./RadialGaugeNeedleShape";
import { RadialGaugePivotShape_$type } from "./RadialGaugePivotShape";
import { RadialGaugeScaleOversweepShape_$type } from "./RadialGaugeScaleOversweepShape";
import { RadialGaugeBackingShape_$type } from "./RadialGaugeBackingShape";
import { RadialGaugeRangeCollection } from "./RadialGaugeRangeCollection";
import { RadialGaugeDuplicateLabelOmissionStrategy_$type } from "./RadialGaugeDuplicateLabelOmissionStrategy";
import { BindingFormatter } from "igniteui-react-core";
import { RadialGaugeScaler } from "./RadialGaugeScaler";
import { Rect } from "igniteui-react-core";
import { RadialGaugeFrame } from "./RadialGaugeFrame";
import { StackPool$1 } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { TextBlock } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { Stack$1 } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { GeometryUtil } from "igniteui-react-core";
import { FormatRadialGaugeLabelEventArgs } from "./FormatRadialGaugeLabelEventArgs";
import { AlignRadialGaugeLabelEventArgs } from "./AlignRadialGaugeLabelEventArgs";
import { DoubleValueChangedEventArgs } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { XamRadialGaugeRange } from "./XamRadialGaugeRange";
import { PathGeometry } from "igniteui-react-core";
import { PolygonUtil } from "igniteui-react-core";
import { TransformGroup } from "igniteui-react-core";
import { RotateTransform } from "igniteui-react-core";
import { RadialGaugeNeedleParameters } from "./RadialGaugeNeedleParameters";
import { RadialGaugeNeedlePreparer } from "./RadialGaugeNeedlePreparer";
import { PathFigure } from "igniteui-react-core";
import { Tuple$2 } from "igniteui-react-core";
import { RadialGaugeRangeFrame } from "./RadialGaugeRangeFrame";
import { ArcSegment } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { GaugeVisualData } from "./GaugeVisualData";
import { RectData } from "igniteui-react-core";
import { ScaleLabelVisualDataList } from "./ScaleLabelVisualDataList";
import { ScaleTickmarkVisualDataList } from "./ScaleTickmarkVisualDataList";
import { RangeVisualDataList } from "./RangeVisualDataList";
import { NeedleVisualData } from "./NeedleVisualData";
import { FontUtil } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { isNaN_, isInfinity, truncate } from "igniteui-react-core";
import { EventProxy } from "igniteui-react-core";
import { RenderingContext } from "igniteui-react-core";
import { Dictionary$2 } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { CanvasViewRenderer } from "igniteui-react-core";
import { ScaleLabelVisualData } from "./ScaleLabelVisualData";
import { ScaleTickmarkVisualData } from "./ScaleTickmarkVisualData";
import { RangeVisualData } from "./RangeVisualData";
import { PathVisualData } from "igniteui-react-core";
import { PointData } from "igniteui-react-core";
import { SizeData } from "igniteui-react-core";
import { AppearanceHelper } from "igniteui-react-core";
import { arrayCopy1 } from "igniteui-react-core";
/**
 * @hidden
 */
export let XamRadialGauge = /*@__PURE__*/ (() => {
    class XamRadialGauge extends Control {
        constructor() {
            super();
            this.propertyChanged = null;
            this._view = null;
            this.ay = null;
            this.bn = 0;
            this.bm = 100;
            this.a8 = false;
            this.formatLabel = null;
            this.aj = null;
            this.alignLabel = null;
            this.valueChanged = null;
            this.a7 = false;
            this.av = null;
            this.io = new Size(1, NaN, NaN);
            this.il = null;
            this.bj = null;
            this.bk = null;
            this.aq = null;
            this.ap = null;
            this.ao = null;
            this.bl = new Stack$1(TextBlock.$);
            this.bi = new List$1(Path.$, 0);
            this.bh = new List$1(Path.$, 0);
            this.bg = new List$1(Path.$, 0);
            this.bq = 0;
            this.a5 = null;
            this.a3 = null;
            this.a2 = null;
            this.a4 = null;
            this.bp = NaN;
            this.bo = 1;
            this.view = new XamRadialGaugeView(this);
            this.view.av();
            this.il = Rect.empty;
            this.aq = new RadialGaugeFrame();
            this.ap = new RadialGaugeFrame();
            this.ao = new RadialGaugeFrame();
            this.ranges = new RadialGaugeRangeCollection();
            this.a7 = true;
            this.ay = new DoubleAnimator(0, 1, this.dn);
            let a = this.ay;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.fn));
            this.ab = XamRadialGauge.$;
            this.a2 = ((() => {
                let $ret = new StackPool$1(TextBlock.$);
                $ret.b = runOn(this.view, this.view.an);
                $ret.c = runOn(this.view, this.view.ao);
                $ret.d = runOn(this.view, this.view.ap);
                $ret.j = runOn(this.view, this.view.be);
                return $ret;
            })());
            this.a5 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.ay);
                $ret.c = runOn(this.view, this.view.az);
                $ret.d = runOn(this.view, this.view.a0);
                $ret.j = runOn(this.view, this.view.b0);
                return $ret;
            })());
            this.a3 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.ay);
                $ret.c = runOn(this.view, this.view.az);
                $ret.d = runOn(this.view, this.view.a0);
                $ret.j = runOn(this.view, this.view.b0);
                return $ret;
            })());
            this.a4 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.a3);
                $ret.c = runOn(this.view, this.view.a4);
                $ret.d = runOn(this.view, this.view.a5);
                $ret.j = runOn(this.view, this.view.b1);
                return $ret;
            })());
            this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
        }
        fz(a) {
            this.f4(a);
        }
        f4(a) {
            let b = this.propertyChanged;
            if (b != null) {
                b(this, new PropertyChangedEventArgs(a));
            }
        }
        onDetachedFromUI() {
            this.view.au();
        }
        onAttachedToUI() {
            this.view.aq();
        }
        dd(a) {
            return this.av.h(a);
        }
        dl(a) {
            return this.av.j(a);
        }
        b5(a) {
            let b = this.im;
            let c = Math.min(b.width / 2, b.height / 2) * this.c0;
            let d = this.ij();
            let e = d.x;
            let f = d.y;
            let g = GeometryUtil.e({ $type: Point_$type, x: e, y: f }, a);
            if (this.av != null && g < this.av.i) {
                g += Math.PI * 2;
            }
            if (this.av != null && g > this.av.g) {
                g -= Math.PI * 2;
            }
            let h = this.dl(g);
            return h;
        }
        ik(a, b) {
            let c = this.dd(a);
            let d = Math.min(this.im.width / 2, this.im.height / 2) * this.c0 * b;
            let e = this.ij();
            let f = e.x + Math.cos(c) * d;
            let g = e.y + Math.sin(c) * d;
            return { $type: Point_$type, x: f, y: g };
        }
        h9(a, b) {
            if (b != null && b.count > 0) {
                return b.item(a % b.count);
            }
            else {
                return null;
            }
        }
        get view() {
            return this._view;
        }
        set view(a) {
            this._view = a;
        }
        fn(a, b) {
            this.dk = this.ay.o;
        }
        get bs() {
            return this.bn;
        }
        set bs(a) {
            this.bn = a;
        }
        get br() {
            return this.bm;
        }
        set br(a) {
            this.bm = a;
        }
        get cw() {
            return this.c(XamRadialGauge.hl);
        }
        set cw(a) {
            this.h(XamRadialGauge.hl, a);
        }
        refresh() {
            this.a7 = true;
            this.view.a7();
        }
        fy(a, b, c) {
            switch (a) {
                case XamRadialGauge.$$p[29]:
                case XamRadialGauge.$$p[32]:
                case XamRadialGauge.$$p[33]:
                case XamRadialGauge.$$p[35]:
                case XamRadialGauge.$$p[0]:
                case XamRadialGauge.$$p[4]:
                case XamRadialGauge.$$p[48]:
                case XamRadialGauge.$$p[56]:
                case XamRadialGauge.$$p[22]:
                    this.view.ar(a, b, c);
                    break;
                case XamRadialGauge.$$p[45]:
                    this.view.aw(b, c);
                    break;
                case XamRadialGauge.$$p[46]:
                    this.view.ax(b, c);
                    break;
                case "PixelScalingRatio":
                    if (isNaN_(DeviceUtils.a(this.cz))) {
                        this.bt = 1;
                    }
                    else {
                        this.bt = DeviceUtils.a(this.cz);
                    }
                    break;
                case "ActualPixelScalingRatio":
                    this.view.a1();
                    break;
            }
            switch (a) {
                case XamRadialGauge.$$p[17]:
                case XamRadialGauge.$$p[18]:
                    if (this.d9 != null) {
                        this.aj = new BindingFormatter();
                        this.aj.j = this.d9;
                        this.aj.d = this.ag;
                    }
                    else {
                        this.aj = null;
                    }
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[62]:
                    if (this.valueChanged != null) {
                        this.valueChanged(this, new DoubleValueChangedEventArgs(b, c));
                    }
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[0]:
                case XamRadialGauge.$$p[4]:
                case XamRadialGauge.$$p[7]:
                case XamRadialGauge.$$p[6]:
                case XamRadialGauge.$$p[2]:
                case XamRadialGauge.$$p[3]:
                case XamRadialGauge.$$p[5]:
                case XamRadialGauge.$$p[1]:
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[55]:
                case XamRadialGauge.$$p[53]:
                case XamRadialGauge.$$p[49]:
                case XamRadialGauge.$$p[51]:
                case XamRadialGauge.$$p[52]:
                    this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[21]:
                case XamRadialGauge.$$p[20]:
                    let d = this.cc;
                    let e = this.ca;
                    if (isInfinity(d) || isNaN_(d)) {
                        d = 0;
                    }
                    if (isInfinity(e) || isNaN_(e)) {
                        e = 100;
                    }
                    this.bs = Math.min(d, e);
                    this.br = Math.max(d, e);
                    this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[13]:
                case XamRadialGauge.$$p[54]:
                case XamRadialGauge.$$p[50]:
                case XamRadialGauge.$$p[16]:
                case XamRadialGauge.$$p[58]:
                case XamRadialGauge.$$p[57]:
                case XamRadialGauge.$$p[56]:
                case XamRadialGauge.$$p[48]:
                case XamRadialGauge.$$p[19]:
                case XamRadialGauge.$$p[23]:
                case XamRadialGauge.$$p[59]:
                case XamRadialGauge.$$p[26]:
                case XamRadialGauge.$$p[22]:
                case XamRadialGauge.$$p[25]:
                case XamRadialGauge.$$p[24]:
                case XamRadialGauge.$$p[8]:
                case XamRadialGauge.$$p[9]:
                case XamRadialGauge.$$p[44]:
                case XamRadialGauge.$$p[10]:
                    this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[42]:
                case XamRadialGauge.$$p[30]:
                case XamRadialGauge.$$p[29]:
                case XamRadialGauge.$$p[32]:
                case "NeedleStartWidth":
                case XamRadialGauge.$$p[31]:
                case XamRadialGauge.$$p[33]:
                case XamRadialGauge.$$p[35]:
                case XamRadialGauge.$$p[43]:
                case XamRadialGauge.$$p[37]:
                case XamRadialGauge.$$p[27]:
                case XamRadialGauge.$$p[28]:
                case XamRadialGauge.$$p[39]:
                case XamRadialGauge.$$p[40]:
                case XamRadialGauge.$$p[38]:
                case XamRadialGauge.$$p[34]:
                case XamRadialGauge.$$p[36]:
                case XamRadialGauge.$$p[41]:
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[60]:
                    this.ay.r = this.dn;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[61]:
                    this.ay.b = this.a0;
                    break;
                case "TransitionProgress":
                    if (this.dk >= 1) {
                        this.ay.w();
                        let f = this.ap;
                        this.ap = this.aq;
                        this.aq = f;
                        this.f1();
                        this.f2();
                        this.f3();
                        this.f9(this.ap);
                        this.ga(this.ap);
                        this.gb(this.ap);
                        this.view.ae();
                        return;
                    }
                    this.ao.e(this.dk, this.aq, this.ap);
                    this.f9(this.ao);
                    this.ga(this.ao);
                    this.gb(this.ao);
                    this.view.ae();
                    break;
                case XamRadialGauge.$$p[47]:
                    let g = b;
                    let h = c;
                    if (g != null) {
                        let i = g;
                        i.collectionChanged = delegateRemove(i.collectionChanged, runOn(this, this.f7));
                    }
                    if (h != null) {
                        let j = h;
                        j.collectionChanged = delegateCombine(j.collectionChanged, runOn(this, this.f7));
                    }
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[46]:
                case XamRadialGauge.$$p[45]:
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[11]:
                case XamRadialGauge.$$p[12]:
                    this.a7 = true;
                    this.view.bd();
                    this.view.a7();
                    break;
            }
            this.fz(a);
        }
        gd() {
            this.view.ba();
        }
        f7(a, b) {
            if (b.oldItems != null) {
                for (let c of fromEn(b.oldItems)) {
                    c.propertyChanged = delegateRemove(c.propertyChanged, runOn(this, this.f6));
                }
            }
            if (b.newItems != null) {
                for (let d of fromEn(b.newItems)) {
                    d.propertyChanged = delegateCombine(d.propertyChanged, runOn(this, this.f6));
                }
            }
            this.a7 = true;
            this.view.a7();
        }
        f6(a, b) {
            this.a7 = true;
            this.view.a7();
        }
        get im() {
            return this.il;
        }
        set im(a) {
            let b = this.il;
            this.il = a;
            if (!b.equals1(this.il)) {
                this.f0(b, this.il);
            }
        }
        f0(a, b) {
            this.a7 = true;
            this.view.a7();
        }
        bb() {
            return !isNaN_(this.bs) && !isNaN_(this.br) && !isNaN_(this.dm) && !this.im.isEmpty && this.view.n();
        }
        fo() {
            if (!this.bb()) {
                return;
            }
            if (this.a7) {
                if (this.a6) {
                    if (this.ay.g) {
                        this.ay.t();
                    }
                    let a = this.aq;
                    this.aq = this.ao;
                    this.ao = a;
                }
                else {
                    let b = this.aq;
                    this.aq = this.ap;
                    this.ap = b;
                }
            }
            else if (this.a6) {
                this.ao.e(this.dk, this.aq, this.ap);
                this.f9(this.ao);
                this.ga(this.ao);
                this.gb(this.ao);
            }
            if (this.a7) {
                this.f2();
                this.f3();
                this.f1();
            }
            if (this.a7 && this.be) {
                this.gc();
                this.ao.e(this.dk, this.aq, this.ap);
                this.f9(this.ao);
                this.ga(this.ao);
                this.gb(this.ao);
            }
            else {
                if (this.a7) {
                    this.f9(this.ap);
                    this.ga(this.ap);
                    this.gb(this.ap);
                }
            }
            this.a7 = false;
            this.view.ae();
        }
        gc() {
            this.bq = 0;
            this.ay.w();
            this.ay.v();
        }
        get be() {
            return this.dn > 0;
        }
        f9(a) {
            let b = this.im;
            let c = this.view.bv();
            let d = a.a;
            let e = Math.min(b.width / 2, b.height / 2) * a.d;
            let f = this.ij();
            let g = f.x;
            let h = f.y;
            let i = d.n(e, g, h);
            c.ak = i;
            c._fill = d.l;
            c._stroke = d.m;
            c.ac = d.h;
        }
        bc(a) {
            if (this.bj == null) {
                return false;
            }
            return PolygonUtil.a(this.bj, a);
        }
        needleContainsPoint(a, b) {
            if (this.bj == null) {
                return false;
            }
            return b ? PolygonUtil.a(this.bk, a) : PolygonUtil.a(this.bj, a);
        }
        ga(a) {
            let b = this.im;
            let c = a.b.ab;
            let d = a.b.aj;
            let e = a.b.ak;
            let f = a.b.ae;
            let g = a.b.ah;
            let h = a.b.ai;
            let i = a.b.aa;
            let j = this.view.bw();
            let k = this.view.bz();
            let l = this.view.bx();
            let m = a.b;
            let n = Math.min(b.width / 2, b.height / 2) * a.d;
            let o = this.ij();
            let p = o.x;
            let q = o.y;
            let r = m.am(n, p, q);
            let s = c * 180 / Math.PI;
            j.ak = r;
            let t = new TransformGroup();
            t.j.add(((() => {
                let $ret = new RotateTransform();
                $ret.k = p;
                $ret.l = q;
                $ret.j = s;
                return $ret;
            })()));
            j.j = t;
            j._fill = d;
            j._stroke = e;
            j.ac = f;
            k.ak = m.an(n, p, q);
            l.ak = m.al(n, p, q);
            k._fill = g;
            k._stroke = h;
            k.ac = i;
            l._fill = g;
            l._stroke = h;
            l.ac = i;
            let u = new List$1(Point_$type, 0);
            let v = Math.cos(c);
            let w = Math.sin(c);
            let x = m.af / 2;
            let y = { $type: Point_$type, x: m.ad * n, y: x * n };
            let z = { $type: Point_$type, x: m.ac * n, y: x * n };
            let aa = { $type: Point_$type, x: m.ac * n, y: -x * n };
            let ab = { $type: Point_$type, x: m.ad * n, y: -x * n };
            y = { $type: Point_$type, x: y.x * v - y.y * w + p, y: y.y * v + y.x * w + q };
            z = { $type: Point_$type, x: z.x * v - z.y * w + p, y: z.y * v + z.x * w + q };
            aa = { $type: Point_$type, x: aa.x * v - aa.y * w + p, y: aa.y * v + aa.x * w + q };
            ab = { $type: Point_$type, x: ab.x * v - ab.y * w + p, y: ab.y * v + ab.x * w + q };
            u.add(y);
            u.add(z);
            u.add(aa);
            u.add(ab);
            this.bj = u;
            x = (m.af / 2) * n;
            let ac = { $type: Point_$type, x: m.ad * n, y: x };
            let ad = { $type: Point_$type, x: m.ac * n, y: x };
            let ae = { $type: Point_$type, x: m.ac * n, y: -x };
            let af = { $type: Point_$type, x: m.ad * n, y: -x };
            ac = { $type: Point_$type, x: ac.x * v - ac.y * w + p, y: ac.y * v + ac.x * w + q };
            ad = { $type: Point_$type, x: ad.x * v - ad.y * w + p, y: ad.y * v + ad.x * w + q };
            ae = { $type: Point_$type, x: ae.x * v - ae.y * w + p, y: ae.y * v + ae.x * w + q };
            af = { $type: Point_$type, x: af.x * v - af.y * w + p, y: af.y * v + af.x * w + q };
            this.bk = new List$1(Point_$type, 0);
            this.bk.add(ac);
            this.bk.add(ad);
            this.bk.add(ae);
            this.bk.add(af);
        }
        ij() {
            let a = this.im;
            let b = isNaN_(this.b3) ? 0.5 : this.b3;
            let c = isNaN_(this.b4) ? 0.5 : this.b4;
            let d = a.left + b * a.width;
            let e = a.top + c * a.height;
            return { $type: Point_$type, x: d, y: e };
        }
        c2(a) {
            if (isInfinity(a)) {
                return NaN;
            }
            return a;
        }
        f2() {
            let a = this.ap;
            a.d = this.c0;
            let b = this.im;
            let c = this.av;
            let d = this.c4(this.dm, 0);
            let e = this.av.h(d);
            let f = new RadialGaugeNeedlePreparer();
            let g = new RadialGaugeNeedleParameters();
            g.b = this.ar;
            g.o = this.c2(this.cx);
            g.t = this.ib;
            g.u = this.ic;
            g.m = this.c2(this.cv);
            g.k = this.c2(this.cn);
            g.d = this.c2(this.cl);
            g.e = this.c2(this.cm);
            g.p = this.c2(this.ct);
            g.q = this.c2(this.cu);
            g.i = this.c2(this.cs);
            g.f = this.c2(this.cp);
            g.r = this.id;
            g.s = this.ie;
            g.c = this.as;
            g.h = this.c2(this.cq);
            g.n = this.c2(this.cw);
            g.l = this.c2(this.co);
            if (isNaN_(g.o)) {
                g.o = XamRadialGauge.cy;
            }
            if (isNaN_(g.h)) {
                g.h = XamRadialGauge.cr;
            }
            f.b = g;
            f.e(a.b);
            a.b.ab = e;
        }
        gb(a) {
            let b = this.im;
            let c = a.c;
            let d = c.c;
            let e = c.e;
            let f = c.g;
            let g = c.h;
            let h = c.f;
            let i = c.d;
            let j = c.l;
            let k = c.t;
            let l = c.q;
            let m = c.j;
            let n = c.i;
            let o = c.v;
            let p = c.u;
            let q = c.s;
            let r = c.p;
            let s = c.ab;
            let t = c.ac;
            let u = c.w;
            let v = c.aa;
            let w = c.n;
            let x = c.m;
            let y = c.o;
            let z = this.view.by();
            let aa = c.r;
            k = Math.max(0, k);
            l = Math.max(0, l);
            let ab = true;
            if (this.au == 1 || (this.au == 0 && this.am == 0)) {
                ab = false;
            }
            let ac = Math.min(b.width / 2, b.height / 2) * a.d;
            let ad = this.ij();
            let ae = ad.x;
            let af = ad.y;
            let ag = q;
            let ah = r;
            q -= aa;
            r += aa;
            let ai = false;
            if ((r - q) >= 2 * Math.PI) {
                ai = true;
                q = 0;
                r = Math.PI;
            }
            let aj = new PathGeometry();
            let ak = new PathFigure();
            let al = Math.cos(q);
            let am = Math.sin(q);
            let an = Math.cos(r);
            let ao = Math.sin(r);
            let ap = ae + (ac * k) * al;
            let aq = af + (ac * k) * am;
            let ar = ae + (ac * l) * al;
            let as = af + (ac * l) * am;
            let at = ae + (ac * k) * an;
            let au = af + (ac * k) * ao;
            let av = ae + (ac * l) * an;
            let aw = af + (ac * l) * ao;
            let ax = ai;
            if (aa != 0 && !ai && ab) {
                let ay = Math.cos(ag);
                let az = Math.sin(ag);
                let a0 = Math.cos(ah);
                let a1 = Math.sin(ah);
                let a2 = ae + (ac * k) * ay;
                let a3 = af + (ac * k) * az;
                let a4 = ae + (ac * l) * ay;
                let a5 = af + (ac * l) * az;
                let a6 = ae + (ac * k) * a0;
                let a7 = af + (ac * k) * a1;
                let a8 = ae + (ac * l) * a0;
                let a9 = af + (ac * l) * a1;
                let ba = aq;
                let bb = ar;
                if (a4 - a2 != 0) {
                    bb = ae;
                    let bc = (a5 - a3) / (a4 - a2);
                    ba = bc * (ae - ar) + as;
                }
                let bd = { $type: Point_$type, x: bb, y: ba };
                let be = GeometryUtil.i(bd, { $type: Point_$type, x: ar, y: as }, { $type: Point_$type, x: ae, y: af }, ac * k);
                let bf = au;
                let bg = av;
                if (a8 - a6 != 0) {
                    bg = ae;
                    let bh = (a9 - a7) / (a8 - a6);
                    bf = bh * (ae - av) + aw;
                }
                let bi = { $type: Point_$type, x: bg, y: bf };
                let bj = GeometryUtil.i(bi, { $type: Point_$type, x: av, y: aw }, { $type: Point_$type, x: ae, y: af }, ac * k);
                if (isNaN_(be.c.x) || isNaN_(be.c.y) || isNaN_(be.d.x) || isNaN_(be.d.y) || isNaN_(bj.c.x) || isNaN_(bj.c.y) || isNaN_(bj.d.x) || isNaN_(bj.d.y)) {
                    ai = true;
                    q = 0;
                    r = Math.PI;
                }
                else {
                    let bk;
                    let bl;
                    if ((Math.pow(be.c.x - ar, 2) + Math.pow(be.c.y - as, 2)) < (Math.pow(be.d.x - ar, 2) + Math.pow(be.d.y - as, 2))) {
                        bk = be.c;
                    }
                    else {
                        bk = be.d;
                    }
                    if ((Math.pow(bj.c.x - av, 2) + Math.pow(bj.c.y - aw, 2)) < (Math.pow(bj.d.x - av, 2) + Math.pow(bj.d.y - aw, 2))) {
                        bl = bj.c;
                    }
                    else {
                        bl = bj.d;
                    }
                    if ((Math.pow(bl.x - ar, 2) + Math.pow(bl.y - as, 2)) <= (Math.pow(bk.x - ar, 2) + Math.pow(bk.y - as, 2))) {
                        ai = true;
                        q = 0;
                        r = Math.PI;
                    }
                    else {
                        let bm = GeometryUtil.e({ $type: Point_$type, x: ae, y: af }, bk);
                        let bn = GeometryUtil.e({ $type: Point_$type, x: ae, y: af }, bl);
                        let bo = q;
                        let bp = r;
                        while (bo > Math.PI * 2) {
                            bo -= Math.PI * 2;
                        }
                        while (bp > Math.PI * 2) {
                            bp -= Math.PI * 2;
                        }
                        let bq = Math.min(Math.abs(bm - bo), Math.abs((Math.PI * 2 - bm) - bo));
                        let br = Math.min(Math.abs(bn - bp), Math.abs((Math.PI * 2 - bn) - bp));
                        if ((r - q) + bq + br >= 2 * Math.PI) {
                            ai = true;
                            q = 0;
                            r = Math.PI;
                        }
                        else {
                            ap = bk.x;
                            aq = bk.y;
                            at = bl.x;
                            au = bl.y;
                        }
                    }
                }
            }
            if (ai && !ax) {
                al = Math.cos(q);
                am = Math.sin(q);
                an = Math.cos(r);
                ao = Math.sin(r);
                ap = ae + (ac * k) * al;
                aq = af + (ac * k) * am;
                ar = ae + (ac * l) * al;
                as = af + (ac * l) * am;
                at = ae + (ac * k) * an;
                au = af + (ac * k) * ao;
                av = ae + (ac * l) * an;
                aw = af + (ac * l) * ao;
            }
            if (ai) {
                ak._startPoint = { $type: Point_$type, x: ar, y: as };
                ak._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: av, y: aw };
                    $ret.b = false;
                    $ret.d = 1;
                    $ret.f = new Size(1, ac * l, ac * l);
                    return $ret;
                })()));
                ak._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: ar, y: as };
                    $ret.b = false;
                    $ret.d = 1;
                    $ret.f = new Size(1, ac * l, ac * l);
                    return $ret;
                })()));
                let bs = new PathFigure();
                bs._startPoint = { $type: Point_$type, x: ap, y: aq };
                bs._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: at, y: au };
                    $ret.b = false;
                    $ret.d = 0;
                    $ret.f = new Size(1, ac * k, ac * k);
                    return $ret;
                })()));
                bs._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: ap, y: aq };
                    $ret.b = false;
                    $ret.d = 0;
                    $ret.f = new Size(1, ac * k, ac * k);
                    return $ret;
                })()));
                aj.c.add(ak);
                aj.c.add(bs);
            }
            else {
                ak._startPoint = { $type: Point_$type, x: ap, y: aq };
                ak._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: ar, y: as };
                    return $ret;
                })()));
                ak._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: av, y: aw };
                    $ret.b = (r - q) > Math.PI;
                    $ret.d = 1;
                    $ret.f = new Size(1, ac * l, ac * l);
                    return $ret;
                })()));
                ak._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: at, y: au };
                    return $ret;
                })()));
                ak._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: ap, y: aq };
                    $ret.b = (r - q) > Math.PI;
                    $ret.d = 0;
                    $ret.f = new Size(1, ac * k, ac * k);
                    return $ret;
                })()));
                aj.c.add(ak);
            }
            z.ak = aj;
            z._fill = s;
            let bt = this.a2;
            bt.f = true;
            for (let bu of fromEnum(this.bl)) {
                bt.n(bu);
            }
            this.bl.g();
            let bv = c.z;
            for (let bw = 0; bw < d.length; bw++) {
                let bx = ae + (ac * j) * Math.cos(d[bw]);
                let by = af + (ac * j) * Math.sin(d[bw]);
                let bz = bt.a();
                if (bz.ak != e[bw]) {
                    bz.ak = e[bw];
                }
                this.view.a9(bz, bv);
                let b0 = h[bw];
                let b1 = i[bw];
                let b2 = f[bw];
                let b3 = g[bw];
                this.view.a2(bz, bx + b2, by + b3);
                this.bl.h(bz);
            }
            bt.f = false;
            let b4 = this.a5;
            b4.f = true;
            for (let b5 = 0; b5 < this.bi.count; b5++) {
                b4.n(this.bi._inner[b5]);
            }
            this.bi.clear();
            for (let b6 = 0; b6 < m.length; b6++) {
                let b7 = ae + (ac * o) * Math.cos(m[b6]);
                let b8 = af + (ac * o) * Math.sin(m[b6]);
                let b9 = ae + (ac * p) * Math.cos(m[b6]);
                let ca = af + (ac * p) * Math.sin(m[b6]);
                let cb = b4.a();
                let cc = new PathGeometry();
                let cd = new PathFigure();
                cd._startPoint = { $type: Point_$type, x: b7, y: b8 };
                cd._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: b9, y: ca };
                    return $ret;
                })()));
                cc.c.add(cd);
                cb.ak = cc;
                cb._stroke = t;
                cb.ac = u;
                this.bi.add(cb);
            }
            b4.f = false;
            let ce = this.a3;
            ce.f = true;
            for (let cf = 0; cf < this.bg.count; cf++) {
                ce.n(this.bg._inner[cf]);
            }
            this.bg.clear();
            for (let cg = 0; cg < n.length; cg++) {
                let ch = ae + (ac * w) * Math.cos(n[cg]);
                let ci = af + (ac * w) * Math.sin(n[cg]);
                let cj = ae + (ac * x) * Math.cos(n[cg]);
                let ck = af + (ac * x) * Math.sin(n[cg]);
                let cl = ce.a();
                let cm = new PathGeometry();
                let cn = new PathFigure();
                cn._startPoint = { $type: Point_$type, x: ch, y: ci };
                cn._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: cj, y: ck };
                    return $ret;
                })()));
                cm.c.add(cn);
                cl.ak = cm;
                cl._stroke = v;
                cl.ac = y;
                this.bg.add(cl);
            }
            ce.f = false;
            let co = this.a4;
            co.f = true;
            for (let cp = this.bh.count - 1; cp >= 0; cp--) {
                co.n(this.bh._inner[cp]);
            }
            this.bh.clear();
            for (let cq = 0; cq < c.k.count; cq++) {
                let cr = c.k._inner[cq];
                let cs = co.a();
                cs.ak = cr.m(ac, ae, af);
                cs._fill = cr.k;
                cs._stroke = cr.l;
                cs.ac = cr.h;
                this.bh.add(cs);
            }
            this.view.a8(this.bh);
            co.f = false;
        }
        bf(a, b, c) {
            let d = c / 10000;
            if (isNaN_(d)) {
                d = 1E-05;
            }
            let e = Math.abs(a - b);
            if (e < d) {
                return true;
            }
            return false;
        }
        c3(a) {
            if (isInfinity(a)) {
                return NaN;
            }
            return a;
        }
        c1(a, b) {
            if (isInfinity(a)) {
                return b;
            }
            return a;
        }
        c4(a, b) {
            if (isInfinity(a) || isNaN_(a)) {
                return b;
            }
            return a;
        }
        f3() {
            let a = this.ap;
            a.d = this.c3(this.c0);
            if (isNaN_(a.d)) {
                a.d = 1;
            }
            let b = this.im;
            let c = this.av;
            let d = this.c3(this.b6);
            let e = this.c3(this.b9);
            let f = this.c3(this.ce);
            if (isNaN_(d)) {
                d = (this.br - this.bs) / 10;
            }
            if (isNaN_(e)) {
                e = d;
            }
            if (isNaN_(f)) {
                f = 3;
            }
            let g = new List$1(Tuple$2.$.specialize(Number_$type, Number_$type), 0);
            let h = c.i;
            let i = c.g;
            while (h >= Math.PI * 2) {
                h -= Math.PI * 2;
            }
            while (i >= Math.PI * 2) {
                i -= Math.PI * 2;
            }
            let j = Math.abs(i - h) < 0.0001;
            let k = this.an == 1 || this.an == 3;
            let l = this.an == 0 || this.an == 3;
            for (let m = this.bs; m <= this.br || this.bf(m, this.br, e); m += e) {
                if (j && this.bf(m, this.bs, e) && k) {
                    continue;
                }
                if (j && this.bf(m, this.br, e) && l) {
                    continue;
                }
                g.add(new Tuple$2(Number_$type, Number_$type, m, c.h(m)));
                if (e == 0) {
                    break;
                }
            }
            let n = new List$1(Number_$type, 0);
            let o = new List$1(Number_$type, 0);
            for (let p = this.bs; p <= this.br || this.bf(p, this.br, d); p += d) {
                n.add(c.h(p));
                for (let q = 0; q < f; q++) {
                    let r = (d / (f + 1)) * (q + 1);
                    if (r + p > this.br) {
                        continue;
                    }
                    o.add(c.h(r + p));
                }
                if (d == 0) {
                    break;
                }
            }
            if (a.c.c.length != g.count) {
                a.c.c = new Array(g.count);
                a.c.e = new Array(g.count);
                a.c.f = new Array(g.count);
                a.c.d = new Array(g.count);
                a.c.g = new Array(g.count);
                a.c.h = new Array(g.count);
            }
            if (a.c.j.length != n.count || a.c.i.length != o.count) {
                a.c.j = new Array(n.count);
                a.c.i = new Array(o.count);
            }
            let s = new FormatRadialGaugeLabelEventArgs();
            s.startAngle = this.av.i;
            s.endAngle = this.av.g;
            s.actualMinimumValue = this.bs;
            s.actualMaximumValue = this.br;
            let t = new AlignRadialGaugeLabelEventArgs();
            t.startAngle = s.startAngle;
            t.endAngle = s.endAngle;
            t.actualMinimumValue = s.actualMinimumValue;
            t.actualMaximumValue = s.actualMaximumValue;
            for (let u = 0; u < g.count; u++) {
                s.angle = g._inner[u].d;
                t.angle = s.angle;
                a.c.c[u] = g._inner[u].d;
                let v = g._inner[u].c;
                s.value = v;
                let w = v;
                if (this.aj == null) {
                    w = Math.round(v * 100) / 100;
                }
                s.label = (w).toString();
                if (this.aj != null) {
                    s.label = this.aj.i(w);
                }
                if (this.formatLabel != null) {
                    this.formatLabel(this, s);
                }
                t.value = s.value;
                t.label = s.label;
                let x = s.label;
                let y = this.view.b2(((() => {
                    let $ret = new TextBlock();
                    $ret.ak = x;
                    return $ret;
                })()));
                t.width = y.width;
                t.height = y.height;
                t.offsetX = -1 * (y.width / 2);
                t.offsetY = -1 * (y.height / 2);
                if (this.alignLabel != null) {
                    this.alignLabel(this, t);
                }
                a.c.f[u] = t.width;
                a.c.d[u] = t.height;
                a.c.g[u] = t.offsetX;
                a.c.h[u] = t.offsetY;
                a.c.e[u] = t.label;
            }
            for (let z = 0; z < n.count; z++) {
                a.c.j[z] = n._inner[z];
            }
            for (let aa = 0; aa < o.count; aa++) {
                a.c.i[aa] = o._inner[aa];
            }
            a.c.t = this.c4(this.db, 0.5);
            a.c.q = this.c4(this.c6, 0.57);
            a.c.l = this.c4(this.b7, 0.65);
            a.c.v = this.c4(this.dg, 0.5);
            a.c.u = this.c4(this.de, 0.57);
            a.c.n = this.c4(this.ch, 0.54);
            a.c.m = this.c4(this.cf, 0.57);
            a.c.s = c.i;
            a.c.p = c.g;
            let ab = this.c8;
            if (isNaN_((ab))) {
                ab = 2.8;
            }
            let ac = ab * Math.PI / 180;
            if (ac < 0) {
                ac = 0;
            }
            a.c.r = ac;
            a.c.ac = this.ih;
            a.c.z = this.h8;
            a.c.aa = this.ia;
            a.c.ab = this.ig;
            a.c.w = this.c3(this.di);
            a.c.o = this.c3(this.cj);
            if (isNaN_(a.c.w)) {
                a.c.w = XamRadialGauge.dj;
            }
            if (isNaN_(a.c.o)) {
                a.c.o = XamRadialGauge.ck;
            }
            a.c.k.clear();
            for (let ad = 0; ad < this.ranges.count; ad++) {
                let ae = this.ranges._inner[ad];
                let af = this.c3(Math.min(ae.o, ae.j));
                let ag = this.c3(Math.max(ae.o, ae.j));
                if (isNaN_(af) || isNaN_(ag)) {
                    continue;
                }
                let ah = c.h(af);
                let ai = c.h(ag);
                let aj = RadialGaugeScaler.k(ah, ai, this.ii);
                ah = aj.c;
                ai = aj.d;
                let ak = new RadialGaugeRangeFrame();
                ak.e = ah;
                ak.b = ai;
                ak.k = ae.ao != null ? ae.ao : this.h9(ad, this.ah);
                ak.l = ae.ap != null ? ae.ap : this.h9(ad, this.ai);
                ak.h = this.c4(ae.p, XamRadialGaugeRange.q);
                ak.f = this.c3(ae.l);
                if (isNaN_(ak.f)) {
                    ak.f = Math.max(0, this.db);
                }
                ak.c = this.c3(ae.k);
                if (isNaN_(ak.c)) {
                    ak.c = Math.max(0, this.db);
                }
                ak.g = this.c3(ae.n);
                if (isNaN_(ak.g)) {
                    ak.g = Math.max(0, this.c6);
                }
                ak.d = this.c3(ae.m);
                if (isNaN_(ak.d)) {
                    ak.d = Math.max(0, this.c6);
                }
                if (this.ii == 0) {
                    let al = ak.f;
                    ak.f = ak.c;
                    ak.c = al;
                    al = ak.g;
                    ak.g = ak.d;
                    ak.d = al;
                }
                a.c.k.add(ak);
            }
        }
        f1() {
            let a = this.ap;
            a.d = this.c0;
            let b = a.a;
            let c = this.h6;
            let d = this.h7;
            let e = this.c1(this.b1, XamRadialGauge.b2);
            let f = this.am;
            let g = this.by;
            let h = this.bw;
            if (isInfinity(h) || isNaN_(h)) {
                h = 0.12;
            }
            if (isInfinity(g) || isNaN_(g)) {
                g = 0.82;
            }
            let i = this.bu;
            if (isInfinity(i) || isNaN_(i)) {
                i = 4;
            }
            if (h > g) {
                let j = g;
                g = h;
                h = j;
            }
            let k = this.av;
            let l = k.i;
            let m = k.g;
            b.l = c;
            b.m = d;
            b.h = e;
            if (f == 0) {
                b.b = 0;
                b.g = 0;
                b.c = 0;
                b.d = 0;
                b.e = this.by;
            }
            else {
                b.b = i;
                let n = this.b0 * Math.PI / 180;
                if (n < 0) {
                    n = 0;
                }
                if ((Math.PI * 2) - (m - l) < n) {
                    b.f = 0;
                    b.b = 0;
                    b.g = 0;
                    b.c = 0;
                    b.d = 0;
                    b.e = g;
                }
                else {
                    b.f = n;
                    b.g = l;
                    b.c = m;
                    b.b = i;
                    b.d = h;
                    b.e = g;
                }
            }
        }
        get a6() {
            return this.ay.f();
        }
        get dk() {
            return this.bq;
        }
        set dk(a) {
            let b = this.bq;
            this.bq = a;
            this.fy("TransitionProgress", b, this.bq);
        }
        fr(a, b) {
            let c = this.b5(a);
            if (this.a9) {
                let d = this.dl(this.av.g - Math.PI * 2);
                switch (this.ii) {
                    case 1:
                        if (c < this.bs) {
                            c = c < d * 0.5 ? this.br : this.bs;
                        }
                        break;
                    case 0:
                        if (c > this.br) {
                            c = c < (d + this.br) * 0.5 ? this.br : this.bs;
                        }
                        break;
                }
            }
            if (c != this.dm) {
                this.dm = c;
            }
        }
        destroy() {
            this.provideContainer(null);
        }
        provideContainer(a) {
            this.view.as(a);
        }
        onMouseMove(a, b) {
            if (this.a8) {
                this.fr(a, b);
            }
        }
        onMouseDown(a, b = false) {
            if (this.ba && this.needleContainsPoint(a, b) && !this.a8) {
                this.a8 = true;
            }
        }
        onMouseUp(a) {
            if (this.a8) {
                this.a8 = false;
            }
        }
        containerResized() {
            this.view.at();
        }
        fs() {
            this.view.flush();
        }
        aw() {
            let a = new GaugeVisualData();
            a.viewport = new RectData(this.im.left, this.im.top, this.im.width, this.im.height);
            a.scaleLabels = new ScaleLabelVisualDataList();
            a.scaleTickmarks = new ScaleTickmarkVisualDataList();
            a.ranges = new RangeVisualDataList();
            a.needle = new NeedleVisualData();
            this.view.aj(a);
            return a;
        }
        d1() {
            let a = this.aw();
            a.scaleByViewport();
            return a.serialize();
        }
        a1() {
            return FontUtil.toFontInfo(this.view.z, this.d2);
        }
        get cz() {
            return this.bp;
        }
        set cz(a) {
            let b = this.bp;
            this.bp = a;
            this.fy("PixelScalingRatio", b, this.bp);
        }
        get bt() {
            return this.bo;
        }
        set bt(a) {
            let b = this.bo;
            this.bo = a;
            this.fy("ActualPixelScalingRatio", b, this.bo);
        }
    }
    XamRadialGauge.$t = /*@__PURE__*/ markType(XamRadialGauge, 'XamRadialGauge', Control.$, [INotifyPropertyChanged_$type]);
    XamRadialGauge.hl = /*@__PURE__*/ DependencyProperty.i("NeedleStartWidth", Number_$type, XamRadialGauge.$, /*@__PURE__*/ new PropertyMetadata(2, NaN, (a, b) => a.fy("NeedleStartWidth", b.oldValue, b.newValue)));
    XamRadialGauge.cy = /*@__PURE__*/ DeviceUtils.g(1);
    XamRadialGauge.cr = /*@__PURE__*/ DeviceUtils.g(1);
    XamRadialGauge.dj = /*@__PURE__*/ DeviceUtils.g(3);
    XamRadialGauge.ck = /*@__PURE__*/ DeviceUtils.g(2);
    XamRadialGauge.b2 = /*@__PURE__*/ DeviceUtils.g(12);
    XamRadialGauge.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, XamRadialGauge, 'fy', ['BackingBrush:h6:ge', [Brush.$, null], 'BackingCornerRadius:bu:gf', [1, 4], 'BackingInnerExtent:bw:gg', [1, 0.12], 'BackingOuterExtent:by:gh', [1, 0.82], 'BackingOutline:h7:gi', [Brush.$, null], 'BackingOversweep:b0:gj', [1, 3], 'BackingShape:am:gk', [RadialGaugeBackingShape_$type, /*@__PURE__*/ enumGetBox(RadialGaugeBackingShape_$type, 0)], 'BackingStrokeThickness:b1:gl', [1, XamRadialGauge.b2], 'CenterX:b3:gm', [1, 0.5], 'CenterY:b4:gn', [1, 0.5], 'DuplicateLabelOmissionStrategy:an:go', [RadialGaugeDuplicateLabelOmissionStrategy_$type, /*@__PURE__*/ enumGetBox(RadialGaugeDuplicateLabelOmissionStrategy_$type, 0)], 'FontBrush:h8:gp', [Brush.$, null], 'Font:d2:gq', [2, null], 'Interval:b6:gr', [1, NaN], 'IsNeedleDraggingConstrained:a9:gs', [0, true], 'IsNeedleDraggingEnabled:ba:gt', [0, false], 'LabelExtent:b7:gu', [1, 0.65], 'LabelFormat:d9:gv', [2, null], 'LabelFormatSpecifiers:ag:gw', [Array_$type, null], 'LabelInterval:b9:gx', [1, NaN], 'MaximumValue:ca:gy', [1, 100], 'MinimumValue:cc:gz', [1, 0], 'MinorTickBrush:ia:g0', [Brush.$, null], 'MinorTickCount:ce:g1', [1, 3], 'MinorTickEndExtent:cf:g2', [1, 0.57], 'MinorTickStartExtent:ch:g3', [1, 0.54], 'MinorTickStrokeThickness:cj:g4', [1, XamRadialGauge.ck], 'NeedleBaseFeatureExtent:cl:g5', [1, NaN], 'NeedleBaseFeatureWidthRatio:cm:g6', [1, NaN], 'NeedleBrush:ib:g7', [Brush.$, null], 'NeedleEndExtent:cn:g8', [1, NaN], 'NeedleEndWidthRatio:co:g9', [1, NaN], 'NeedleOutline:ic:ha', [Brush.$, null], 'NeedlePivotBrush:id:hb', [Brush.$, null], 'NeedlePivotInnerWidthRatio:cp:hc', [1, NaN], 'NeedlePivotOutline:ie:hd', [Brush.$, null], 'NeedlePivotShape:as:he', [RadialGaugePivotShape_$type, /*@__PURE__*/ enumGetBox(RadialGaugePivotShape_$type, 3)], 'NeedlePivotStrokeThickness:cq:hf', [1, XamRadialGauge.cr], 'NeedlePivotWidthRatio:cs:hg', [1, NaN], 'NeedlePointFeatureExtent:ct:hh', [1, NaN], 'NeedlePointFeatureWidthRatio:cu:hi', [1, NaN], 'NeedleShape:ar:hj', [RadialGaugeNeedleShape_$type, /*@__PURE__*/ enumGetBox(RadialGaugeNeedleShape_$type, 4)], 'NeedleStartExtent:cv:hk', [1, NaN], 'NeedleStrokeThickness:cx:hm', [1, XamRadialGauge.cy], 'RadiusMultiplier:c0:hn', [1, 1], 'RangeBrushes:ah:ho', [BrushCollection.$, null], 'RangeOutlines:ai:hp', [BrushCollection.$, null], 'Ranges::hq', [RadialGaugeRangeCollection.$, null], 'ScaleBrush:ig:hr', [Brush.$, null], 'ScaleEndAngle:c5:hs', [1, 45], 'ScaleEndExtent:c6:ht', [1, 0.57], 'ScaleOversweep:c8:hu', [1, 2.8], 'ScaleOversweepShape:au:hv', [RadialGaugeScaleOversweepShape_$type, /*@__PURE__*/ enumGetBox(RadialGaugeScaleOversweepShape_$type, 0)], 'ScaleStartAngle:da:hw', [1, 135], 'ScaleStartExtent:db:hx', [1, 0.5], 'ScaleSweepDirection:ii:hy', [SweepDirection_$type, /*@__PURE__*/ enumGetBox(SweepDirection_$type, 1)], 'TickBrush:ih:hz', [Brush.$, null], 'TickEndExtent:de:h0', [1, 0.57], 'TickStartExtent:dg:h1', [1, 0.5], 'TickStrokeThickness:di:h2', [1, XamRadialGauge.dj], 'TransitionDuration:dn:h3', [1, 0], 'TransitionEasingFunction:a0:h4', [Delegate_$type, null], 'Value:dm:h5', [1, 0]]);
    return XamRadialGauge;
})();
/**
 * @hidden
 */
export let XamRadialGaugeView = /*@__PURE__*/ (() => {
    class XamRadialGaugeView extends Base {
        constructor(a) {
            super();
            this.h = null;
            this.s = null;
            this.r = null;
            this.q = null;
            this.br = new Path();
            this.bt = new Path();
            this.bq = new Path();
            this.bs = new Path();
            this.bu = new Path();
            this.o = null;
            this.a = ["needle", "needlePivot", "backing", "scale", "tick", "minorTick", "label"];
            this.c = null;
            this.d = null;
            this.l = false;
            this.m = false;
            this.g = null;
            this.aa = null;
            this.k = null;
            this.z = null;
            this.i = null;
            this.bf = new Brush();
            this.bg = ((() => {
                let $ret = new Brush();
                $ret.fill = "black";
                return $ret;
            })());
            this.t = NaN;
            this.p = null;
            this.ac = -1;
            this.ab = -1;
            this.bk = null;
            this.bl = null;
            this.bm = null;
            this.bn = null;
            this.bh = null;
            this.bi = null;
            this.bo = null;
            this.bp = null;
            this.bj = null;
            this.e = null;
            this.f = null;
            this.u = 0;
            this.h = a;
            this.o = new Dictionary$2(String_$type, Dictionary$2.$.specialize(String_$type, String_$type), 0);
            this.q = new List$1(TextBlock.$, 0);
            this.r = new List$1(Path.$, 0);
            this.s = new List$1(Path.$, 0);
        }
        an(a) {
            a._visibility = 0;
        }
        ao(a) {
            a._visibility = 1;
        }
        ap(a) {
            this.q.remove(a);
        }
        be() {
            let a = new TextBlock();
            this.q.add(a);
            return a;
        }
        ay(a) {
            a._visibility = 0;
        }
        az(a) {
            a._visibility = 1;
        }
        a0(a) {
            this.r.remove(a);
        }
        b0() {
            let a = new Path();
            this.r.add(a);
            return a;
        }
        a3(a) {
            a._visibility = 0;
        }
        a4(a) {
            a._visibility = 1;
        }
        a5(a) {
            this.s.remove(a);
        }
        b1() {
            let a = new Path();
            this.s.add(a);
            return a;
        }
        n() {
            return true;
        }
        bw() {
            return this.br;
        }
        by() {
            return this.bt;
        }
        w(a) {
            let b = typeCast(TextBlock.$, a);
            if (b != null && b.ak != null) {
                return this.k.e(b) + 0;
            }
            return 0;
        }
        b2(a) {
            if (isNaN_(this.t)) {
                this.t = this.v(null);
            }
            let b = this.w(a);
            let c = this.t;
            return new Size(1, b, c);
        }
        al() {
            this.l = true;
            let a = ["#CED3D8", "#CED3D8", "#EBEDEF", "#FFC73C", "#617583", "rgba(100,107,114,.74)", "rgba(100,107,114,.74)"];
            let b = ["#B2B9C0", "#B2B9C0", "#B2B9C0", null, null, null, null];
            let c = ["background-color", "border-top-color"];
            let d = ((() => {
                let $ret = new List$1(Array_$type, 0);
                $ret.add(a);
                $ret.add(b);
                return $ret;
            })());
            this.o.clear();
            let e = this.a.length;
            for (let f = 0; f < e; f++) {
                let g = new Dictionary$2(String_$type, String_$type, 0);
                let h = this.a[f];
                let i = new Array(c.length);
                arrayCopy1(c, 0, i, 0, c.length);
                this.b("ui-radialgauge-" + h, i);
                for (let j = 0; j < i.length; j++) {
                    g.item(c[j], (i[j] == null) ? d._inner[j][f] : i[j]);
                }
                this.o.item(h, g);
            }
            this.bc();
            let k;
            let l;
            let m = BrushUtil.e("radialgauge-range", this.z, k, l);
            k = m.p2;
            l = m.p3;
            this.c = k;
            this.d = l;
            if (this.e == null) {
                this.h.ah = this.c;
            }
            if (this.f == null) {
                this.h.ai = this.d;
            }
            this.l = false;
        }
        aq() {
            this.am();
            if (this.g != null) {
                this.g.ap(this.z.rootWrapper, "");
            }
        }
        au() {
            if (this.g != null) {
                this.g.bb(this.z.rootWrapper, "");
            }
        }
        bc() {
            this.l = true;
            let a = this.a.length;
            for (let b = 0; b < a; b++) {
                let c = this.a[b];
                this.bb(c, this.o.item(c));
            }
            this.l = false;
        }
        bb(a, b) {
            let c = null;
            let d = null;
            let e = b.count;
            for (let f of fromEnum(b.keys)) {
                switch (f) {
                    case "background-color":
                        c = new Brush();
                        if (b.item(f) != null) {
                            c._fill = b.item(f);
                        }
                        break;
                    case "border-top-color":
                        d = new Brush();
                        if (b.item(f) != null) {
                            d._fill = b.item(f);
                        }
                        break;
                }
            }
            switch (a) {
                case "needle":
                    if (this.bk == null) {
                        this.h.ib = c;
                    }
                    if (this.bl == null) {
                        this.h.ic = d;
                    }
                    break;
                case "needlePivot":
                    if (this.bm == null) {
                        this.h.id = c;
                    }
                    if (this.bn == null) {
                        this.h.ie = d;
                    }
                    break;
                case "backing":
                    if (this.bh == null) {
                        this.h.h6 = c;
                    }
                    if (this.bi == null) {
                        this.h.h7 = d;
                    }
                    break;
                case "scale":
                    if (this.bo == null) {
                        this.h.ig = c;
                    }
                    break;
                case "tick":
                    if (this.bp == null) {
                        this.h.ih = c;
                    }
                    break;
                case "minorTick":
                    if (this.bj == null) {
                        this.h.ia = c;
                    }
                    break;
                case "label":
                    this.bg = c;
                    break;
            }
        }
        b(a, b) {
            this.z.startCSSQuery();
            for (let c = 0; c < b.length; c++) {
                b[c] = this.z.getCssDefaultPropertyValue(a, b[c]);
            }
            this.z.endCSSQuery();
            return b;
        }
        static y(a, b) {
            let c = a == null ? 0 : a.length;
            if (c < 1) {
                return b;
            }
            let d = a.split('.');
            let e = (d[0].length > 0) ? parseInt(d[0]) : 0;
            if (d.length != 2) {
                return e;
            }
            c = d[1].length;
            let f = parseInt(d[1]);
            while (c-- > 0) {
                f /= 10;
            }
            return f + e;
        }
        av() {
            this.l = true;
            this.h.ib = ((() => {
                let $ret = new Brush();
                $ret.fill = "#CED3D8";
                return $ret;
            })());
            this.h.ic = ((() => {
                let $ret = new Brush();
                $ret.fill = "#B2B9C0";
                return $ret;
            })());
            this.h.ih = ((() => {
                let $ret = new Brush();
                $ret.fill = "#617583";
                return $ret;
            })());
            this.h.ig = ((() => {
                let $ret = new Brush();
                $ret.fill = "#FFC73C";
                return $ret;
            })());
            this.h.h6 = ((() => {
                let $ret = new Brush();
                $ret.fill = "#EBEDEF";
                return $ret;
            })());
            this.h.h7 = ((() => {
                let $ret = new Brush();
                $ret.fill = "#B2B9C0";
                return $ret;
            })());
            this.h.id = ((() => {
                let $ret = new Brush();
                $ret.fill = "#CED3D8";
                return $ret;
            })());
            this.h.ie = ((() => {
                let $ret = new Brush();
                $ret.fill = "#B2B9C0";
                return $ret;
            })());
            this.h.ia = ((() => {
                let $ret = new Brush();
                $ret.fill = "rgba(100,107,114,.74)";
                return $ret;
            })());
            this.l = false;
            this.am();
        }
        am() {
            let a = this.h.cz;
            let b = this.h.bt;
            if (!isNaN_(a) && a != 0) {
                return;
            }
            if (window.devicePixelRatio != undefined && window.devicePixelRatio != b) {
                this.h.bt = window.devicePixelRatio;
            }
        }
        a7() {
            if (!this.m) {
                this.m = true;
                if (this.z != null) {
                    this.z.setTimeout(runOn(this, this.ad), 0);
                }
                else {
                    window.setTimeout(runOn(this, this.ad), 0);
                }
            }
        }
        ad() {
            if (this.m) {
                this.m = false;
                this.h.fo();
            }
        }
        flush() {
            if (this.m) {
                this.ad();
            }
        }
        a2(a, b, c) {
            a.n = b;
            a.o = c;
        }
        as(a) {
            if (a == null) {
                this.aa = null;
                this.z = null;
                this.k = null;
                this.af();
                return;
            }
            this.u = (isNaN_(this.h.cz) ? this.h.bt : this.h.cz);
            let b = a;
            this.z = b;
            this.h.ay.u(this.z);
            this.z.rootWrapper.addClass("ui-radialgauge-container");
            let c = this.u;
            let d = Math.round(b.rootWrapper.width());
            let e = Math.round(b.rootWrapper.height());
            let f = d * c;
            let g = e * c;
            this.z.rootWrapper.setStyleProperty("position", "relative");
            let h = this.z.createElement("canvas");
            h.setStyleProperty("position", "absolute");
            this.z.append(h);
            this.ac = truncate(Math.round(f));
            this.ab = truncate(Math.round(g));
            h.setAttribute("width", f.toString());
            h.setAttribute("height", g.toString());
            h.setStyleProperty("width", d.toString() + "px");
            h.setStyleProperty("height", e.toString() + "px");
            this.h.im = new Rect(0, 0, 0, d, e);
            this.aa = h;
            let i = this.z.get2DCanvasContext(this.aa);
            this.k = new RenderingContext(new CanvasViewRenderer(), i);
            this.al();
            this.bd();
            this.k.ac(this.i);
            this.af();
            if (TypeRegistrar.isRegistered("CanvasGestureDOMEventProxy")) {
                this.g = typeCast(EventProxy.$, TypeRegistrar.create("CanvasGestureDOMEventProxy", this.z.rootWrapper, this.z, false));
            }
            if (this.g != null) {
                let j = this.g;
                j.onContactStarted = delegateCombine(j.onContactStarted, runOn(this, this.ai));
                let k = this.g;
                k.onContactMoved = delegateCombine(k.onContactMoved, runOn(this, this.ah));
                let l = this.g;
                l.onContactCompleted = delegateCombine(l.onContactCompleted, runOn(this, this.ag));
                this.g.ak = (m) => this.h.ba && (this.h.a8 || this.h.bc(m));
            }
            this.a6();
        }
        ag(a, b) {
            if (this.h != null) {
                this.h.onMouseUp(a);
            }
        }
        ah(a, b) {
            if (this.h != null) {
                this.h.onMouseMove(a, b);
            }
        }
        ai(a, b) {
            if (this.h != null) {
                this.h.onMouseDown(a);
            }
        }
        af() {
            if (this.g != null) {
                let a = this.g;
                a.onContactStarted = delegateRemove(a.onContactStarted, runOn(this, this.ai));
                let b = this.g;
                b.onContactMoved = delegateRemove(b.onContactMoved, runOn(this, this.ah));
                let c = this.g;
                c.onContactCompleted = delegateRemove(c.onContactCompleted, runOn(this, this.ag));
                this.g.ak = null;
                this.g.aq();
            }
        }
        a9(a, b) {
            if (b != null) {
                a.am = b;
            }
            else {
                a.am = this.bg;
            }
        }
        ba() {
            this.al();
            this.bd();
            this.a7();
        }
        bd() {
            this.i = FontUtil.getFont(this.z);
            if (this.h.d2 != null) {
                this.i = this.h.a1();
            }
            this.t = this.v(this.i);
            this.bf = new Brush();
            this.bf._fill = this.z.rootWrapper.getStyleProperty("color");
            if (this.k != null) {
                this.k.ac(this.i);
            }
        }
        ae() {
            this.a6();
        }
        a6() {
            let a = this.h.im.width;
            let b = this.h.im.height;
            let c = Math.round(a * this.u);
            let d = Math.round(b * this.u);
            if (this.ac != c || this.ab != d) {
                this.aa.setAttribute("width", c.toString());
                this.aa.setAttribute("height", d.toString());
                this.aa.setStyleProperty("width", a.toString() + "px");
                this.aa.setStyleProperty("height", b.toString() + "px");
                this.ac = truncate(Math.round(c));
                this.ab = truncate(Math.round(d));
            }
            if (this.k.d && this.u != 1) {
                this.k.z();
                this.k.aa(this.u, this.u);
            }
            this.k.k(this.h.im.left, this.h.im.top, this.h.im.width, this.h.im.height);
            this.k.s(this.bq);
            this.k.s(this.bt);
            if (this.p != null) {
                for (let e = 0; e < this.p.count; e++) {
                    this.k.s(this.p._inner[e]);
                }
            }
            for (let f = 0; f < this.q.count; f++) {
                this.k.ac(this.i);
                this.k.w(this.q._inner[f]);
            }
            for (let g = 0; g < this.r.count; g++) {
                this.k.s(this.r._inner[g]);
            }
            this.k.z();
            this.k.j(this.br.j);
            this.k.s(this.bu);
            this.k.s(this.br);
            this.k.s(this.bs);
            this.k.y();
            if (this.k.d && this.u != 1) {
                this.k.y();
            }
        }
        v(a) {
            return FontUtil.getCurrentFontHeight(this.z, a);
        }
        a8(a) {
            this.p = a;
        }
        bv() {
            return this.bq;
        }
        bz() {
            return this.bu;
        }
        bx() {
            return this.bs;
        }
        at() {
            this.am();
            let a = Math.round(this.z.rootWrapper.width());
            let b = Math.round(this.z.rootWrapper.height());
            this.h.im = new Rect(0, 0, 0, a, b);
            if (this.g != null) {
                this.g.bf = this.h.im;
            }
        }
        j(a, b) {
            return FontUtil.getFontInfo(this.z, a, b);
        }
        aj(a) {
            a.scalePath = new PathVisualData(1, "Scale", this.bt);
            a.needlePath = new PathVisualData(1, "Needle", this.br);
            let b = this.br.j.j._inner[0].j;
            a.needle.angle = b;
            a.backingPath = new PathVisualData(1, "Backing", this.bq);
            a.overlayPath = new PathVisualData(1, "Overlay", this.bs);
            a.underlayPath = new PathVisualData(1, "Underlay", this.bu);
            let c = this.i;
            for (let d of fromEnum(this.q)) {
                if (d._visibility == 0) {
                    let e = this.j(d, c);
                    let f = new ScaleLabelVisualData();
                    f.labelValue = d.ak;
                    f.labelPosition = PointData.b({ $type: Point_$type, x: d.n, y: d.o });
                    f.labelSize = SizeData.b(this.b2(d));
                    f.appearance = AppearanceHelper.c(d, e);
                    a.scaleLabels.add(f);
                }
            }
            for (let g of fromEnum(this.r)) {
                if (g._visibility == 0) {
                    let h = new ScaleTickmarkVisualData();
                    h.tickPath = new PathVisualData(1, "tickmarks", g);
                    a.scaleTickmarks.add(h);
                }
            }
            for (let i of fromEnum(this.s)) {
                if (i._visibility == 0) {
                    let j = new RangeVisualData();
                    let k = new PathVisualData(1, "range", i);
                    j.rangePath = k;
                    a.ranges.add(j);
                }
            }
        }
        ar(a, b, c) {
            let d = b;
            let e = c;
            if (!this.l) {
                switch (a) {
                    case XamRadialGauge.$$p[29]:
                        this.bk = e;
                        break;
                    case XamRadialGauge.$$p[32]:
                        this.bl = e;
                        break;
                    case XamRadialGauge.$$p[33]:
                        this.bm = e;
                        break;
                    case XamRadialGauge.$$p[35]:
                        this.bn = e;
                        break;
                    case XamRadialGauge.$$p[0]:
                        this.bh = e;
                        break;
                    case XamRadialGauge.$$p[4]:
                        this.bi = e;
                        break;
                    case XamRadialGauge.$$p[48]:
                        this.bo = e;
                        break;
                    case XamRadialGauge.$$p[56]:
                        this.bp = e;
                        break;
                    case XamRadialGauge.$$p[22]:
                        this.bj = e;
                        break;
                }
                if (e == null) {
                    this.bc();
                }
            }
        }
        aw(a, b) {
            if (!this.l) {
                this.e = b;
                if (this.e == null) {
                    this.h.ah = this.c;
                }
            }
        }
        ax(a, b) {
            if (!this.l) {
                this.f = b;
                if (this.f == null) {
                    this.h.ai = this.d;
                }
            }
        }
        a1() {
            this.u = this.h.bt;
        }
    }
    XamRadialGaugeView.$t = /*@__PURE__*/ markType(XamRadialGaugeView, 'XamRadialGaugeView');
    return XamRadialGaugeView;
})();
//# sourceMappingURL=XamRadialGauge_combined.js.map

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { GeometryUtil } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let BackingFrame = /*@__PURE__*/ (() => {
    class BackingFrame extends Base {
        constructor() {
            super();
            this.l = null;
            this.m = null;
            this.h = 0;
            this.g = 0;
            this.c = 0;
            this.f = 0;
            this.e = 0;
            this.d = 0;
            this.b = 0;
        }
        k(a, b, c) {
            this.h = b.h + (c.h - b.h) * a;
            this.l = BrushUtil.k(b.l, a, c.l, 0);
            this.m = BrushUtil.k(b.m, a, c.m, 0);
            this.g = b.g + (c.g - b.g) * a;
            this.c = b.c + (c.c - b.c) * a;
            this.e = b.e + (c.e - b.e) * a;
            this.d = b.d + (c.d - b.d) * a;
            this.b = b.b + (c.b - b.b) * a;
            this.f = b.f + (c.f - b.f) * a;
        }
        i(a, b, c, d) {
            a._startPoint = { $type: Point_$type, x: b * this.e + c, y: 0 + d };
            let e = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: -1 * b * this.e + c, y: 0 + d };
                $ret.b = false;
                $ret.d = 1;
                $ret.f = new Size(1, b * this.e, b * this.e);
                return $ret;
            })());
            let f = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: b * this.e + c, y: 0 + d };
                $ret.b = false;
                $ret.d = 1;
                $ret.f = new Size(1, b * this.e, b * this.e);
                return $ret;
            })());
            a._segments.add(e);
            a._segments.add(f);
            a._isClosed = true;
        }
        n(a, b, c) {
            let d = new PathGeometry();
            let e = new PathFigure();
            if (this.g == this.c) {
                this.i(e, a, b, c);
            }
            else {
                let f = this.e;
                let g = this.d;
                let h = this.g;
                let i = this.c;
                let j = this.f;
                let k = h;
                let l = i;
                h -= j;
                i += j;
                if ((i - h) > 2 * Math.PI) {
                    this.i(e, a, b, c);
                }
                else {
                    this.j(e, a, b, c);
                }
            }
            e._isClosed = true;
            d.c.add(e);
            return d;
        }
        a(a, b) {
            return Math.abs(a - b) < 1E-05;
        }
        j(a, b, c, d) {
            let e = this.e;
            let f = this.d;
            let g = this.g;
            let h = this.c;
            let i = this.f;
            let j = g;
            let k = h;
            g -= i;
            h += i;
            let l = Math.sin(g);
            let m = Math.cos(g);
            let n = Math.sin(h);
            let o = Math.cos(h);
            let p = this.b;
            let q = b * e;
            let r = b * f;
            if (p * 2 > (q - r)) {
                p = (q - r) / 2;
            }
            let s = p / (b - p);
            let t = Math.atan(s);
            let u = q - p;
            let v = r + p;
            let w = Math.sin(g - t);
            let x = Math.sin(g + t);
            let y = Math.cos(g - t);
            let z = Math.cos(g + t);
            let aa = Math.sin(h - t);
            let ab = Math.sin(h + t);
            let ac = Math.cos(h - t);
            let ad = Math.cos(h + t);
            let ae = Math.sin(j);
            let af = Math.sin(k);
            let ag = Math.cos(j);
            let ah = Math.cos(k);
            a._startPoint = { $type: Point_$type, x: m * u + c, y: l * u + d };
            let ai = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: z * q + c, y: x * q + d };
                $ret.b = (t * 2) > Math.PI;
                $ret.d = 1;
                $ret.f = new Size(1, p, p);
                return $ret;
            })());
            let aj = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: ac * q + c, y: aa * q + d };
                $ret.b = ((h - t) - (g + t)) > Math.PI;
                $ret.d = 1;
                $ret.f = new Size(1, q, q);
                return $ret;
            })());
            let ak = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: o * u + c, y: n * u + d };
                $ret.b = (t * 2) > Math.PI;
                $ret.d = 1;
                $ret.f = new Size(1, p, p);
                return $ret;
            })());
            let al = { $type: Point_$type, x: ah * q + c, y: af * q + d };
            let am = { $type: Point_$type, x: ah * r + c, y: af * r + d };
            let an = { $type: Point_$type, x: o * q + c, y: n * q + d };
            let ao = { $type: Point_$type, x: o * r + c, y: n * r + d };
            let ap = an.y;
            let aq = an.x;
            if (al.x - am.x != 0) {
                aq = c;
                let ar = (al.y - am.y) / (al.x - am.x);
                ap = ar * (c - an.x) + an.y;
            }
            ao = { $type: Point_$type, x: c, y: ap };
            if (this.a(ao.x, an.x) && this.a(ao.y, an.y)) {
                ao = am;
            }
            let as = GeometryUtil.i(ao, an, { $type: Point_$type, x: c, y: d }, r);
            let at = { $type: Point_$type, x: ag * q + c, y: ae * q + d };
            let au = { $type: Point_$type, x: ag * r + c, y: ae * r + d };
            let av = { $type: Point_$type, x: m * q + c, y: l * q + d };
            let aw = { $type: Point_$type, x: m * r + c, y: l * r + d };
            let ax = av.y;
            let ay = av.x;
            if (at.x - au.x != 0) {
                ay = c;
                let az = (at.y - au.y) / (at.x - au.x);
                ax = az * (c - av.x) + av.y;
            }
            aw = { $type: Point_$type, x: ay, y: ax };
            if (this.a(aw.x, av.x) && this.a(aw.y, av.y)) {
                aw = au;
            }
            let a0 = GeometryUtil.i(aw, av, { $type: Point_$type, x: c, y: d }, r);
            if (isNaN_(as.c.x) || isNaN_(as.c.y) || isNaN_(as.d.x) || isNaN_(as.d.y) || isNaN_(a0.c.x) || isNaN_(a0.c.y) || isNaN_(a0.d.x) || isNaN_(a0.d.y)) {
                a._startPoint = { $type: Point_$type, x: m * q + c, y: l * q + d };
                a._segments.add(aj);
                let a1 = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: m * q + c, y: l * q + d };
                    return $ret;
                })());
                a._segments.add(a1);
            }
            else {
                let a2;
                let a3;
                if ((Math.pow(as.c.x - an.x, 2) + Math.pow(as.c.y - an.y, 2)) < (Math.pow(as.d.x - an.x, 2) + Math.pow(as.d.y - an.y, 2))) {
                    a2 = as.c;
                }
                else {
                    a2 = as.d;
                }
                if ((Math.pow(a0.c.x - av.x, 2) + Math.pow(a0.c.y - av.y, 2)) < (Math.pow(a0.d.x - av.x, 2) + Math.pow(a0.d.y - av.y, 2))) {
                    a3 = a0.c;
                }
                else {
                    a3 = a0.d;
                }
                if ((Math.pow(a3.x - an.x, 2) + Math.pow(a3.y - an.y, 2)) <= (Math.pow(a2.x - an.x, 2) + Math.pow(a2.y - an.y, 2))) {
                    a._startPoint = { $type: Point_$type, x: m * q + c, y: l * q + d };
                    a._segments.add(aj);
                    let a4 = ((() => {
                        let $ret = new LineSegment(1);
                        $ret.c = { $type: Point_$type, x: m * q + c, y: l * q + d };
                        return $ret;
                    })());
                    a._segments.add(a4);
                }
                else {
                    a._segments.add(ai);
                    a._segments.add(aj);
                    a._segments.add(ak);
                    let a5 = ((() => {
                        let $ret = new LineSegment(1);
                        $ret.c = a2;
                        return $ret;
                    })());
                    a._segments.add(a5);
                    let a6 = GeometryUtil.e({ $type: Point_$type, x: c, y: d }, a2);
                    let a7 = GeometryUtil.e({ $type: Point_$type, x: c, y: d }, a3);
                    while (a7 < a6) {
                        a7 += 2 * Math.PI;
                    }
                    let a8 = ((() => {
                        let $ret = new ArcSegment();
                        $ret.e = a3;
                        $ret.b = a7 - a6 > Math.PI;
                        $ret.d = 1;
                        $ret.f = new Size(1, r, r);
                        return $ret;
                    })());
                    a._segments.add(a8);
                    let a9 = ((() => {
                        let $ret = new LineSegment(1);
                        $ret.c = { $type: Point_$type, x: m * u + c, y: l * u + d };
                        return $ret;
                    })());
                    a._segments.add(a9);
                }
            }
        }
    }
    BackingFrame.$t = /*@__PURE__*/ markType(BackingFrame, 'BackingFrame');
    return BackingFrame;
})();
//# sourceMappingURL=BackingFrame.js.map

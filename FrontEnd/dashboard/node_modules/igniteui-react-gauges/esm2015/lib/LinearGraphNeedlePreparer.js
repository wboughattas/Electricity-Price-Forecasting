/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let LinearGraphNeedlePreparer = /*@__PURE__*/ (() => {
    class LinearGraphNeedlePreparer extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        c(a) {
            this.d(a);
        }
        d(a) {
            this.f(a);
            let b = this.a();
            a.n = b.u;
            a.m = b.q;
            a.q = 0;
            if (!isNaN_(b.t)) {
                a.q = Math.max(a.q, b.t);
            }
            if (!isNaN_(b.p)) {
                a.q = Math.max(a.q, b.p);
            }
            let c = 7;
            let d = new Array(c);
            let e = new Array(c + 1);
            this.e(a, d, e, b);
            for (let f = 0; f < c; f++) {
                let g = d[f].f;
                g.add(e[f]);
                g.add(e[f + 1]);
            }
        }
        e(a, b, c, d) {
            let e = d.q;
            let f = d.u;
            let g = d.r;
            let h = d.v;
            if (d.d == 0) {
                e = 1 - e;
                f = 1 - f;
                g = 1 - g;
                h = 1 - h;
                b[0] = a.i;
                b[1] = a.j;
                b[2] = a.d;
                b[3] = a.g;
                b[4] = a.f;
                b[5] = a.h;
                b[6] = a.e;
                c[0] = { $type: Point_$type, x: (-1) * d.t, y: f };
                c[1] = { $type: Point_$type, x: d.t, y: f };
                c[2] = { $type: Point_$type, x: d.w, y: h };
                c[3] = { $type: Point_$type, x: d.s, y: g };
                c[4] = { $type: Point_$type, x: d.p, y: e };
                c[5] = { $type: Point_$type, x: (-1) * d.p, y: e };
                c[6] = { $type: Point_$type, x: (-1) * d.s, y: g };
                c[7] = { $type: Point_$type, x: (-1) * d.w, y: h };
            }
            else {
                b[0] = a.i;
                b[1] = a.j;
                b[2] = a.d;
                b[3] = a.g;
                b[4] = a.f;
                b[5] = a.h;
                b[6] = a.e;
                c[0] = { $type: Point_$type, x: f, y: (-1) * d.t };
                c[1] = { $type: Point_$type, x: f, y: d.t };
                c[2] = { $type: Point_$type, x: h, y: d.w };
                c[3] = { $type: Point_$type, x: g, y: d.s };
                c[4] = { $type: Point_$type, x: e, y: d.p };
                c[5] = { $type: Point_$type, x: e, y: (-1) * d.p };
                c[6] = { $type: Point_$type, x: g, y: (-1) * d.s };
                c[7] = { $type: Point_$type, x: h, y: (-1) * d.w };
            }
        }
        a() {
            let a = this.b;
            let b = 0.85;
            let c = 0.25;
            let d = 0.45;
            let e = a.o;
            let f = 0.5;
            let g = a.q;
            let h = a.u;
            let i = a.r;
            let j = a.v;
            let k = a.p;
            let l = a.t;
            let m = a.s;
            let n = a.w;
            if (isNaN_(g)) {
                g = c;
            }
            if (isNaN_(h)) {
                h = b;
            }
            if (isNaN_(i)) {
                if (a.c == 3) {
                    i = d;
                }
                else {
                    i = c;
                }
            }
            if (isNaN_(j)) {
                j = b;
            }
            if (isNaN_(l)) {
                l = e;
            }
            if (isNaN_(k)) {
                if (a.c == 4) {
                    k = l * f;
                }
                else {
                    k = e;
                }
            }
            if (isNaN_(m)) {
                m = e;
            }
            if (isNaN_(n)) {
                n = e;
            }
            switch (a.c) {
                case 2:
                case 1:
                case 4:
                    j = h;
                    i = g;
                    break;
            }
            if (a.c == 3) {
                k = 0;
                m = l;
                n = l;
                j = h;
            }
            if (a.c == 2) {
                k = 0;
                m = 0;
                n = l;
            }
            if (a.c == 4) {
                m = k;
                n = l;
            }
            if (a.c == 1) {
                let o = Math.max(k, l);
                k = o;
                l = o;
                m = o;
                n = o;
            }
            a.q = g;
            a.u = h;
            a.r = i;
            a.v = j;
            a.p = k;
            a.t = l;
            a.s = m;
            a.w = n;
            return a;
        }
        f(a) {
            a.f.k();
            a.g.k();
            a.d.k();
            a.j.k();
            a.i.k();
            a.k.k();
            a.e.k();
            a.h.k();
            a.b.k();
            a.c.k();
        }
    }
    LinearGraphNeedlePreparer.$t = /*@__PURE__*/ markType(LinearGraphNeedlePreparer, 'LinearGraphNeedlePreparer');
    return LinearGraphNeedlePreparer;
})();
//# sourceMappingURL=LinearGraphNeedlePreparer.js.map

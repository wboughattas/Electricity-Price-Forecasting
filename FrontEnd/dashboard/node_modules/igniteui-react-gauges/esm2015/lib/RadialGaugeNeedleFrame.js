/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { MorphSegment } from "./MorphSegment";
import { BrushUtil } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
/**
 * @hidden
 */
export let RadialGaugeNeedleFrame = /*@__PURE__*/ (() => {
    class RadialGaugeNeedleFrame extends Base {
        constructor() {
            super();
            this.ad = 0;
            this.ac = 0;
            this.af = 0;
            this.ab = 0;
            this.aj = null;
            this.ak = null;
            this.aa = 0;
            this.ae = 0;
            this.ai = null;
            this.ah = null;
            this.d = null;
            this.b = null;
            this.t = null;
            this.e = null;
            this.f = null;
            this.x = null;
            this.v = null;
            this.w = null;
            this.z = null;
            this.y = null;
            this.u = null;
            this.h = null;
            this.g = null;
            this.c = null;
            this.s = null;
            this.a = null;
            this.q = null;
            this.r = null;
            this.i = null;
            this.l = null;
            this.m = null;
            this.p = null;
            this.j = null;
            this.k = null;
            this.n = null;
            this.o = null;
            this.d = new MorphSegment();
            this.b = new MorphSegment();
            this.t = new MorphSegment();
            this.e = new MorphSegment();
            this.f = new MorphSegment();
            this.x = new MorphSegment();
            this.v = new MorphSegment();
            this.w = new MorphSegment();
            this.z = new MorphSegment();
            this.y = new MorphSegment();
            this.u = new MorphSegment();
            this.h = new MorphSegment();
            this.g = new MorphSegment();
            this.c = new MorphSegment();
            this.s = new MorphSegment();
            this.a = new MorphSegment();
            this.q = new MorphSegment();
            this.r = new MorphSegment();
            this.i = new MorphSegment();
            this.l = new MorphSegment();
            this.m = new MorphSegment();
            this.p = new MorphSegment();
            this.j = new MorphSegment();
            this.k = new MorphSegment();
            this.n = new MorphSegment();
            this.o = new MorphSegment();
        }
        ag(a, b, c) {
            this.ad = b.ad + (c.ad - b.ad) * a;
            this.ac = b.ac + (c.ac - b.ac) * a;
            this.af = b.af + (c.af - b.af) * a;
            this.ab = b.ab + (c.ab - b.ab) * a;
            this.aj = BrushUtil.k(b.aj, a, c.aj, 0);
            this.ak = BrushUtil.k(b.ak, a, c.ak, 0);
            this.ae = b.ae + (c.ae - b.ae) * a;
            this.aa = b.aa + (c.aa - b.aa) * a;
            this.ah = BrushUtil.k(b.ah, a, c.ah, 0);
            this.ai = BrushUtil.k(b.ai, a, c.ai, 0);
            this.d.j(a, b.d, c.d);
            this.b.j(a, b.b, c.b);
            this.t.j(a, b.t, c.t);
            this.e.j(a, b.e, c.e);
            this.f.j(a, b.f, c.f);
            this.x.j(a, b.x, c.x);
            this.v.j(a, b.v, c.v);
            this.w.j(a, b.w, c.w);
            this.z.j(a, b.z, c.z);
            this.y.j(a, b.y, c.y);
            this.u.j(a, b.u, c.u);
            this.h.j(a, b.h, c.h);
            this.g.j(a, b.g, c.g);
            this.c.j(a, b.c, c.c);
            this.s.j(a, b.s, c.s);
            this.a.j(a, b.a, c.a);
            this.q.j(a, b.q, c.q);
            this.r.j(a, b.r, c.r);
            this.i.j(a, b.i, c.i);
            this.l.j(a, b.l, c.l);
            this.m.j(a, b.m, c.m);
            this.p.j(a, b.p, c.p);
            this.j.j(a, b.j, c.j);
            this.k.j(a, b.k, c.k);
            this.n.j(a, b.n, c.n);
            this.o.j(a, b.o, c.o);
        }
        am(a, b, c) {
            let d = new PathGeometry();
            let e = new PathFigure();
            let f = { $type: Point_$type, x: NaN, y: NaN };
            f = this.d.l(f, e, a, b, c);
            f = this.b.l(f, e, a, b, c);
            f = this.t.l(f, e, a, b, c);
            f = this.e.l(f, e, a, b, c);
            f = this.f.l(f, e, a, b, c);
            f = this.x.l(f, e, a, b, c);
            f = this.v.l(f, e, a, b, c);
            f = this.w.l(f, e, a, b, c);
            f = this.z.l(f, e, a, b, c);
            f = this.y.l(f, e, a, b, c);
            f = this.u.l(f, e, a, b, c);
            f = this.h.l(f, e, a, b, c);
            f = this.g.l(f, e, a, b, c);
            f = this.c.l(f, e, a, b, c);
            f = this.s.l(f, e, a, b, c);
            f = this.a.l(f, e, a, b, c);
            e._isClosed = true;
            d.c.add(e);
            let g = new PathFigure();
            if (this.q.f.count > 0 || this.r.f.count > 0) {
                f = this.q.l(f, g, a, b, c);
                f = this.r.l(f, g, a, b, c);
                g._isClosed = true;
                d.c.add(g);
            }
            return d;
        }
        an(a, b, c) {
            let d = new PathGeometry();
            let e = { $type: Point_$type, x: NaN, y: NaN };
            let f = new PathFigure();
            if (this.m.f.count > 0 || this.p.f.count > 0) {
                e = this.m.l(e, f, a, b, c);
                e = this.p.l(e, f, a, b, c);
                f._isClosed = true;
                d.c.add(f);
            }
            let g = new PathFigure();
            if (this.n.f.count > 0 || this.o.f.count > 0) {
                e = this.n.l(e, g, a, b, c);
                e = this.o.l(e, g, a, b, c);
                g._isClosed = true;
                d.c.add(g);
            }
            return d;
        }
        al(a, b, c) {
            let d = new PathGeometry();
            let e = { $type: Point_$type, x: NaN, y: NaN };
            let f = new PathFigure();
            if (this.i.f.count > 0 || this.l.f.count > 0) {
                e = this.i.l(e, f, a, b, c);
                e = this.l.l(e, f, a, b, c);
                f._isClosed = true;
                d.c.add(f);
            }
            let g = new PathFigure();
            if (this.j.f.count > 0 || this.k.f.count > 0) {
                e = this.j.l(e, g, a, b, c);
                e = this.k.l(e, g, a, b, c);
                g._isClosed = true;
                d.c.add(g);
            }
            return d;
        }
    }
    RadialGaugeNeedleFrame.$t = /*@__PURE__*/ markType(RadialGaugeNeedleFrame, 'RadialGaugeNeedleFrame');
    return RadialGaugeNeedleFrame;
})();
//# sourceMappingURL=RadialGaugeNeedleFrame.js.map

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import * as tslib_1 from "tslib";
import { Base, Point_$type, markType } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { PathSegment } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { Tuple$2 } from "igniteui-react-core";
import { PolyLineSegment } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
/**
 * @hidden
 */
var RadialGaugeRangeFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    tslib_1.__extends(RadialGaugeRangeFrame, _super);
    function RadialGaugeRangeFrame() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.f = 0;
        _this.g = 0;
        _this.e = 0;
        _this.b = 0;
        _this.c = 0;
        _this.d = 0;
        _this.k = null;
        _this.l = null;
        _this.h = 0;
        return _this;
    }
    RadialGaugeRangeFrame.a = function (a, b, c, d) {
        var e = new RadialGaugeRangeFrame();
        e.k = BrushUtil.k(c.k, a, d.k, 0);
        e.l = BrushUtil.k(c.l, a, d.l, 0);
        e.h = b * c.h + a * d.h;
        e.f = b * c.f + a * d.f;
        e.g = b * c.g + a * d.g;
        e.e = b * c.e + a * d.e;
        e.b = b * c.b + a * d.b;
        e.c = b * c.c + a * d.c;
        e.d = b * c.d + a * d.d;
        return e;
    };
    RadialGaugeRangeFrame.prototype.m = function (a, b, c) {
        var d = new PathGeometry();
        var e = new PathFigure();
        var f = 4;
        var g = 1 / a;
        var h = false;
        if (Math.abs(this.g - this.d) < g) {
            h = true;
        }
        var i = false;
        if (Math.abs(this.f - this.c) < g) {
            i = true;
        }
        var j = false;
        if ((this.b - this.e) >= 2 * Math.PI) {
            j = true;
        }
        if (i && h && j) {
            var k = this.i(0, Math.PI, this.g, a, b, c, true);
            e._startPoint = k.c;
            var l = this.i(Math.PI, 0, this.g, a, b, c, true);
            var m = new PathFigure();
            var n = this.i(0, Math.PI, this.f, a, b, c, false);
            m._startPoint = n.c;
            var o = this.i(Math.PI, 0, this.f, a, b, c, false);
            e._segments.add(k.d);
            e._segments.add(l.d);
            m._segments.add(n.d);
            m._segments.add(o.d);
            d.c.add(e);
            d.c.add(m);
            return d;
        }
        var p = null;
        if (h) {
            var q = this.i(this.e, this.b, Math.max(0, this.g), a, b, c, true);
            e._startPoint = q.c;
            p = q.d;
        }
        else {
            var r = this.j(this.e, this.b, this.g, this.d, a, b, c, true, f);
            e._startPoint = r.c;
            p = r.d;
        }
        var s = null;
        var t = new LineSegment(1);
        if (i) {
            var u = this.i(this.e, this.b, Math.max(0, this.f), a, b, c, false);
            s = u.d;
            t.c = u.c;
        }
        else {
            var v = this.j(this.e, this.b, this.f, this.c, a, b, c, false, f);
            s = v.d;
            t.c = v.c;
        }
        e._segments.add(p);
        e._segments.add(t);
        e._segments.add(s);
        e._isFilled = true;
        e._isClosed = true;
        d.c.add(e);
        return d;
    };
    RadialGaugeRangeFrame.prototype.j = function (a, b, c, d, e, f, g, h, i) {
        var j = new PolyLineSegment();
        var k = e * c;
        var l = e * d;
        var m = Math.max(k, l);
        var n = m + m;
        var o = Math.asin(i / n) * 2;
        var p;
        var q;
        var r;
        var s = l - k;
        var t = Math.abs(b - a);
        var u = j._points;
        if (h) {
            var v = void 0;
            for (v = a; v < b; v += o) {
                r = (v - a) / t;
                q = k + r * s;
                p = { $type: Point_$type, x: f + Math.cos(v) * q, y: g + Math.sin(v) * q };
                u.add(p);
            }
            v = b;
            r = (v - a) / t;
            q = k + r * s;
            p = { $type: Point_$type, x: f + Math.cos(v) * q, y: g + Math.sin(v) * q };
            u.add(p);
        }
        else {
            var w = void 0;
            for (w = b; w > a; w -= o) {
                r = (w - b) / t;
                q = l + r * s;
                p = { $type: Point_$type, x: f + Math.cos(w) * q, y: g + Math.sin(w) * q };
                u.add(p);
            }
            w = a;
            r = (w - b) / t;
            q = l + r * s;
            p = { $type: Point_$type, x: f + Math.cos(w) * q, y: g + Math.sin(w) * q };
            u.add(p);
        }
        return new Tuple$2(Point_$type, PathSegment.$, u._inner[0], j);
    };
    RadialGaugeRangeFrame.prototype.i = function (a, b, c, d, e, f, g) {
        var h = c * d;
        var i = new ArcSegment();
        i.d = g ? 1 : 0;
        i.b = b - a > Math.PI;
        i.f = new Size(1, h, h);
        var j = g ? b : a;
        var k = g ? a : b;
        i.e = { $type: Point_$type, x: e + Math.cos(j) * h, y: f + Math.sin(j) * h };
        var l = { $type: Point_$type, x: e + Math.cos(k) * h, y: f + Math.sin(k) * h };
        return new Tuple$2(Point_$type, PathSegment.$, l, i);
    };
    RadialGaugeRangeFrame.$t = markType(RadialGaugeRangeFrame, 'RadialGaugeRangeFrame');
    return RadialGaugeRangeFrame;
}(Base));
export { RadialGaugeRangeFrame };
//# sourceMappingURL=RadialGaugeRangeFrame.js.map

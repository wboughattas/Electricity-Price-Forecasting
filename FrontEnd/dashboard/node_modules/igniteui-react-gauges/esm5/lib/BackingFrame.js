/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import * as tslib_1 from "tslib";
import { Base, Point_$type, markType } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { GeometryUtil } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
var BackingFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    tslib_1.__extends(BackingFrame, _super);
    function BackingFrame() {
        var _this = _super.call(this) || this;
        _this.l = null;
        _this.m = null;
        _this.h = 0;
        _this.g = 0;
        _this.c = 0;
        _this.f = 0;
        _this.e = 0;
        _this.d = 0;
        _this.b = 0;
        return _this;
    }
    BackingFrame.prototype.k = function (a, b, c) {
        this.h = b.h + (c.h - b.h) * a;
        this.l = BrushUtil.k(b.l, a, c.l, 0);
        this.m = BrushUtil.k(b.m, a, c.m, 0);
        this.g = b.g + (c.g - b.g) * a;
        this.c = b.c + (c.c - b.c) * a;
        this.e = b.e + (c.e - b.e) * a;
        this.d = b.d + (c.d - b.d) * a;
        this.b = b.b + (c.b - b.b) * a;
        this.f = b.f + (c.f - b.f) * a;
    };
    BackingFrame.prototype.i = function (a, b, c, d) {
        var _this = this;
        a._startPoint = { $type: Point_$type, x: b * this.e + c, y: 0 + d };
        var e = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: -1 * b * _this.e + c, y: 0 + d };
            $ret.b = false;
            $ret.d = 1;
            $ret.f = new Size(1, b * _this.e, b * _this.e);
            return $ret;
        })());
        var f = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: b * _this.e + c, y: 0 + d };
            $ret.b = false;
            $ret.d = 1;
            $ret.f = new Size(1, b * _this.e, b * _this.e);
            return $ret;
        })());
        a._segments.add(e);
        a._segments.add(f);
        a._isClosed = true;
    };
    BackingFrame.prototype.n = function (a, b, c) {
        var d = new PathGeometry();
        var e = new PathFigure();
        if (this.g == this.c) {
            this.i(e, a, b, c);
        }
        else {
            var f = this.e;
            var g = this.d;
            var h = this.g;
            var i = this.c;
            var j = this.f;
            var k = h;
            var l = i;
            h -= j;
            i += j;
            if ((i - h) > 2 * Math.PI) {
                this.i(e, a, b, c);
            }
            else {
                this.j(e, a, b, c);
            }
        }
        e._isClosed = true;
        d.c.add(e);
        return d;
    };
    BackingFrame.prototype.a = function (a, b) {
        return Math.abs(a - b) < 1E-05;
    };
    BackingFrame.prototype.j = function (a, b, c, d) {
        var e = this.e;
        var f = this.d;
        var g = this.g;
        var h = this.c;
        var i = this.f;
        var j = g;
        var k = h;
        g -= i;
        h += i;
        var l = Math.sin(g);
        var m = Math.cos(g);
        var n = Math.sin(h);
        var o = Math.cos(h);
        var p = this.b;
        var q = b * e;
        var r = b * f;
        if (p * 2 > (q - r)) {
            p = (q - r) / 2;
        }
        var s = p / (b - p);
        var t = Math.atan(s);
        var u = q - p;
        var v = r + p;
        var w = Math.sin(g - t);
        var x = Math.sin(g + t);
        var y = Math.cos(g - t);
        var z = Math.cos(g + t);
        var aa = Math.sin(h - t);
        var ab = Math.sin(h + t);
        var ac = Math.cos(h - t);
        var ad = Math.cos(h + t);
        var ae = Math.sin(j);
        var af = Math.sin(k);
        var ag = Math.cos(j);
        var ah = Math.cos(k);
        a._startPoint = { $type: Point_$type, x: m * u + c, y: l * u + d };
        var ai = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: z * q + c, y: x * q + d };
            $ret.b = (t * 2) > Math.PI;
            $ret.d = 1;
            $ret.f = new Size(1, p, p);
            return $ret;
        })());
        var aj = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: ac * q + c, y: aa * q + d };
            $ret.b = ((h - t) - (g + t)) > Math.PI;
            $ret.d = 1;
            $ret.f = new Size(1, q, q);
            return $ret;
        })());
        var ak = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: o * u + c, y: n * u + d };
            $ret.b = (t * 2) > Math.PI;
            $ret.d = 1;
            $ret.f = new Size(1, p, p);
            return $ret;
        })());
        var al = { $type: Point_$type, x: ah * q + c, y: af * q + d };
        var am = { $type: Point_$type, x: ah * r + c, y: af * r + d };
        var an = { $type: Point_$type, x: o * q + c, y: n * q + d };
        var ao = { $type: Point_$type, x: o * r + c, y: n * r + d };
        var ap = an.y;
        var aq = an.x;
        if (al.x - am.x != 0) {
            aq = c;
            var ar = (al.y - am.y) / (al.x - am.x);
            ap = ar * (c - an.x) + an.y;
        }
        ao = { $type: Point_$type, x: c, y: ap };
        if (this.a(ao.x, an.x) && this.a(ao.y, an.y)) {
            ao = am;
        }
        var as = GeometryUtil.i(ao, an, { $type: Point_$type, x: c, y: d }, r);
        var at = { $type: Point_$type, x: ag * q + c, y: ae * q + d };
        var au = { $type: Point_$type, x: ag * r + c, y: ae * r + d };
        var av = { $type: Point_$type, x: m * q + c, y: l * q + d };
        var aw = { $type: Point_$type, x: m * r + c, y: l * r + d };
        var ax = av.y;
        var ay = av.x;
        if (at.x - au.x != 0) {
            ay = c;
            var az = (at.y - au.y) / (at.x - au.x);
            ax = az * (c - av.x) + av.y;
        }
        aw = { $type: Point_$type, x: ay, y: ax };
        if (this.a(aw.x, av.x) && this.a(aw.y, av.y)) {
            aw = au;
        }
        var a0 = GeometryUtil.i(aw, av, { $type: Point_$type, x: c, y: d }, r);
        if (isNaN_(as.c.x) || isNaN_(as.c.y) || isNaN_(as.d.x) || isNaN_(as.d.y) || isNaN_(a0.c.x) || isNaN_(a0.c.y) || isNaN_(a0.d.x) || isNaN_(a0.d.y)) {
            a._startPoint = { $type: Point_$type, x: m * q + c, y: l * q + d };
            a._segments.add(aj);
            var a1 = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: m * q + c, y: l * q + d };
                return $ret;
            })());
            a._segments.add(a1);
        }
        else {
            var a2_1;
            var a3_1;
            if ((Math.pow(as.c.x - an.x, 2) + Math.pow(as.c.y - an.y, 2)) < (Math.pow(as.d.x - an.x, 2) + Math.pow(as.d.y - an.y, 2))) {
                a2_1 = as.c;
            }
            else {
                a2_1 = as.d;
            }
            if ((Math.pow(a0.c.x - av.x, 2) + Math.pow(a0.c.y - av.y, 2)) < (Math.pow(a0.d.x - av.x, 2) + Math.pow(a0.d.y - av.y, 2))) {
                a3_1 = a0.c;
            }
            else {
                a3_1 = a0.d;
            }
            if ((Math.pow(a3_1.x - an.x, 2) + Math.pow(a3_1.y - an.y, 2)) <= (Math.pow(a2_1.x - an.x, 2) + Math.pow(a2_1.y - an.y, 2))) {
                a._startPoint = { $type: Point_$type, x: m * q + c, y: l * q + d };
                a._segments.add(aj);
                var a4 = ((function () {
                    var $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: m * q + c, y: l * q + d };
                    return $ret;
                })());
                a._segments.add(a4);
            }
            else {
                a._segments.add(ai);
                a._segments.add(aj);
                a._segments.add(ak);
                var a5 = ((function () {
                    var $ret = new LineSegment(1);
                    $ret.c = a2_1;
                    return $ret;
                })());
                a._segments.add(a5);
                var a6_1 = GeometryUtil.e({ $type: Point_$type, x: c, y: d }, a2_1);
                var a7_1 = GeometryUtil.e({ $type: Point_$type, x: c, y: d }, a3_1);
                while (a7_1 < a6_1) {
                    a7_1 += 2 * Math.PI;
                }
                var a8 = ((function () {
                    var $ret = new ArcSegment();
                    $ret.e = a3_1;
                    $ret.b = a7_1 - a6_1 > Math.PI;
                    $ret.d = 1;
                    $ret.f = new Size(1, r, r);
                    return $ret;
                })());
                a._segments.add(a8);
                var a9 = ((function () {
                    var $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: m * u + c, y: l * u + d };
                    return $ret;
                })());
                a._segments.add(a9);
            }
        }
    };
    BackingFrame.$t = markType(BackingFrame, 'BackingFrame');
    return BackingFrame;
}(Base));
export { BackingFrame };
//# sourceMappingURL=BackingFrame.js.map

import { __extends, __values } from 'tslib';
import { Component, createElement } from 'react';
import { createPortal } from 'react-dom';
import { PathGeometry, PathFigure, LineSegment, Point_$type, BrushUtil, markType, Base, List$1, GeometryUtil, ArcSegment, Size, PolyLineSegment, InterpolationUtil, markEnum, PropertyChangedEventArgs, DependencyObject, INotifyPropertyChanged_$type, markDep, DependencyProperty, PropertyMetadata, Brush, ObservableCollection$1, EventArgs, fromEnum, StringBuilder, PointData, SizeData, String_$type, typeCast, TextBlock, Path, delegateCombine, runOn, Rect, DoubleAnimator, StackPool$1, RectData, AppearanceHelper, PathVisualData, GetPointsSettings, PolygonUtil, isNaN_, Number_$type, Tuple$2, DeviceUtils, delegateRemove, BindingFormatter, fromEn, FontUtil, Control, Array_$type, enumGetBox, BrushCollection, Dictionary$2, CanvasGestureDOMEventProxy, intDivide, arrayCopy1, RenderingContext, CanvasViewRenderer, TypeRegistrar, EventProxy, truncate, stringIsNullOrEmpty, NamePatcher, isValidProp, getModifiedProps, brushToString, stringToBrush, toSpinal, initializePropertiesFromCss, SyncableObservableCollection$2, IgCollection, ContentChildrenManager, ReactRenderer, CollectionAdapter, NotifyCollectionChangedAction, ReactWrapper, IgrDataContext, ensureEnum, fromBrushCollection, toBrushCollection, ensureBool, arrayFindByName, toPoint, IgrNumberFormatSpecifierModule, IgrDVInteractivityModule, DoubleValueChangedEventArgs, IgrDoubleValueChangedEventArgs, isInfinity, MathUtil, PathSegment, Stack$1, TransformGroup, RotateTransform, SweepDirection_$type, Delegate_$type, fromPoint } from 'igniteui-react-core';

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphBackingFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphBackingFrame, _super);
    function LinearGraphBackingFrame() {
        var _this = _super.call(this) || this;
        _this.e = null;
        _this.f = null;
        _this.c = 0;
        _this.b = 0;
        _this.a = 0;
        return _this;
    }
    LinearGraphBackingFrame.prototype.g = function (a, b, c) {
        var _this = this;
        var d = new PathGeometry();
        var e = new PathFigure();
        var f, g, h, i;
        if (c == 1) {
            f = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: a * _this.a, y: 0 };
                return $ret;
            })());
            g = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: a * _this.b, y: 0 };
                return $ret;
            })());
            h = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: a * _this.b, y: b };
                return $ret;
            })());
            i = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: a * _this.a, y: b };
                return $ret;
            })());
        }
        else {
            f = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: 0, y: a * (1 - _this.b) };
                return $ret;
            })());
            g = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: b, y: a * (1 - _this.b) };
                return $ret;
            })());
            h = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: b, y: a * (1 - _this.a) };
                return $ret;
            })());
            i = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: 0, y: a * (1 - _this.a) };
                return $ret;
            })());
        }
        e._startPoint = f.c;
        e._segments.add(g);
        e._segments.add(h);
        e._segments.add(i);
        e._isClosed = true;
        d.c.add(e);
        return d;
    };
    LinearGraphBackingFrame.prototype.d = function (a, b, c) {
        this.c = b.c + (c.c - b.c) * a;
        this.e = BrushUtil.k(b.e, a, c.e, 0);
        this.f = BrushUtil.k(b.f, a, c.f, 0);
        this.b = b.b + (c.b - b.b) * a;
        this.a = b.a + (c.a - b.a) * a;
    };
    LinearGraphBackingFrame.$t = markType(LinearGraphBackingFrame, 'LinearGraphBackingFrame');
    return LinearGraphBackingFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphRectFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphRectFrame, _super);
    function LinearGraphRectFrame() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.e = 0;
        _this.f = 0;
        _this.b = 0;
        _this.c = 0;
        _this.g = 0;
        _this.d = 0;
        _this.i = null;
        _this.j = null;
        _this.h = 0;
        return _this;
    }
    LinearGraphRectFrame.prototype.k = function (a, b, c, d) {
        var _this = this;
        var e = new PathGeometry();
        var f = new PathFigure();
        var g, h, i, j;
        if (d == 1) {
            g = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: a.x + b * _this.b, y: c - _this.d };
                return $ret;
            })());
            h = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: a.x + b * _this.c, y: c - _this.d };
                return $ret;
            })());
            i = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: a.x + b * _this.f, y: c - _this.g };
                return $ret;
            })());
            j = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: a.x + b * _this.e, y: c - _this.g };
                return $ret;
            })());
        }
        else {
            g = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: _this.g, y: b * (1 - _this.f) };
                return $ret;
            })());
            h = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: _this.d, y: b * (1 - _this.c) };
                return $ret;
            })());
            i = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: _this.d, y: b * (1 - _this.b) };
                return $ret;
            })());
            j = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: _this.g, y: b * (1 - _this.e) };
                return $ret;
            })());
        }
        f._startPoint = g.c;
        f._segments.add(h);
        f._segments.add(i);
        f._segments.add(j);
        f._isClosed = true;
        e.c.add(f);
        return e;
    };
    LinearGraphRectFrame.a = function (a, b, c, d) {
        var e = new LinearGraphRectFrame();
        e.i = BrushUtil.k(c.i, a, d.i, 0);
        e.j = BrushUtil.k(c.j, a, d.j, 0);
        e.h = b * c.h + a * d.h;
        e.e = b * c.e + a * d.e;
        e.f = b * c.f + a * d.f;
        e.g = b * c.g + a * d.g;
        e.d = b * c.d + a * d.d;
        e.b = b * c.b + a * d.b;
        e.c = b * c.c + a * d.c;
        return e;
    };
    LinearGraphRectFrame.$t = markType(LinearGraphRectFrame, 'LinearGraphRectFrame');
    return LinearGraphRectFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphFrame, _super);
    function LinearGraphFrame() {
        var _this = _super.call(this) || this;
        _this.a = null;
        _this.b = null;
        _this.a = new LinearGraphBackingFrame();
        _this.b = new LinearGraphRectFrame();
        return _this;
    }
    LinearGraphFrame.prototype.d = function (a, b, c) {
        this.b = LinearGraphRectFrame.a(a, 1 - a, b.b, c.b);
        this.c.y(a, b.c, c.c);
        this.a.d(a, b.a, c.a);
    };
    LinearGraphFrame.$t = markType(LinearGraphFrame, 'LinearGraphFrame');
    return LinearGraphFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var MorphSegment = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(MorphSegment, _super);
    function MorphSegment() {
        var _this = _super.call(this) || this;
        _this.f = null;
        _this.g = null;
        _this.b = false;
        _this.h = 0;
        _this.e = false;
        _this.a = false;
        _this.d = false;
        _this.c = false;
        _this.f = new List$1(Point_$type, 0);
        _this.g = new List$1(Point_$type, 0);
        return _this;
    }
    MorphSegment.prototype.i = function (a) {
        this.g.clear();
        var b = 20;
        if (this.b) {
            var c = void 0;
            var d = void 0;
            var e = void 0;
            if (this.f.count == 0) {
                d = { $type: Point_$type, x: 0, y: 0 };
                e = { $type: Point_$type, x: 0, y: 0 };
            }
            else {
                d = this.f._inner[0];
                e = this.f._inner[1];
            }
            var f = GeometryUtil.l(d, e, this.h, !this.c, this.d);
            var g = GeometryUtil.e(f, d);
            var h = GeometryUtil.e(f, e);
            while (this.c && h < g) {
                h += Math.PI * 2;
            }
            while (!this.c && h > g) {
                h -= Math.PI * 2;
            }
            var i = 0;
            for (var j = 0; j < b; j++) {
                c = j / b;
                if (this.c) {
                    i = g + (h - g) * c;
                }
                else {
                    i = g - (g - h) * c;
                }
                this.g.add({ $type: Point_$type, x: f.x + Math.cos(i) * this.h, y: f.y + Math.sin(i) * this.h });
            }
        }
        else {
            var k = void 0;
            var l = void 0;
            var m = void 0;
            if (this.f.count == 0) {
                l = { $type: Point_$type, x: 0, y: 0 };
                m = { $type: Point_$type, x: 0, y: 0 };
            }
            else {
                l = this.f._inner[0];
                m = this.f._inner[1];
            }
            var n = l.x;
            var o = l.y;
            var p = m.x;
            var q = m.y;
            for (var r = 0; r < b; r++) {
                k = r / b;
                this.g.add({ $type: Point_$type, x: n + (p - n) * k, y: o + (q - o) * k });
            }
        }
        this.a = true;
    };
    MorphSegment.prototype.l = function (a, b, c, d, e) {
        var f = this;
        var g = null;
        var h = f.f;
        var i = h.count;
        if (i == 0) {
            return a;
        }
        if (b._segments.count == 0) {
            var j = h._inner[0];
            b._startPoint = { $type: Point_$type, x: d + c * j.x, y: e + c * j.y };
        }
        if (f.b) {
            if (i > 1) {
                var k = new ArcSegment();
                g = k;
                var l = h._inner[1];
                k.e = { $type: Point_$type, x: d + c * l.x, y: e + c * l.y };
                k.b = f.d;
                k.d = f.c ? 1 : 0;
                k.f = new Size(1, f.h * c, f.h * c);
                a = k.e;
            }
        }
        else {
            var m = new PolyLineSegment();
            g = m;
            if (i > 1) {
                var n = void 0;
                var o = m._points;
                for (var p = 1; p < i; p++) {
                    n = h._inner[p];
                    o.add({ $type: Point_$type, x: d + c * n.x, y: e + c * n.y });
                }
                a = m._points._inner[m._points.count - 1];
            }
        }
        b._segments.add(g);
        return a;
    };
    MorphSegment.prototype.j = function (a, b, c) {
        var d = this;
        var e = b.f;
        var f = false;
        var g = c.f;
        var h = false;
        if (e.count == 0 && g.count == 0) {
            return;
        }
        d.b = false;
        d.e = false;
        d.a = false;
        d.d = false;
        d.c = false;
        if (b.e) {
            f = true;
        }
        if (c.e) {
            h = true;
        }
        if (b.b != c.b || b.e || c.e || b.d != c.d || b.c != c.c) {
            f = true;
            h = true;
            d.e = true;
        }
        if (f && !b.e) {
            if (!b.a) {
                b.i(c.h);
            }
            e = b.g;
        }
        if (h && !c.e) {
            if (!c.a) {
                c.i(b.h);
            }
            g = c.g;
        }
        if (b.e) {
            e = b.g;
        }
        if (c.e) {
            g = c.g;
        }
        d.g.clear();
        if (b.b && c.b) {
            d.b = true;
        }
        InterpolationUtil.b(d.f, a, e, g);
        if (d.e) {
            var i = void 0;
            var j = d.f.count;
            for (var k = 0; k < j; k++) {
                i = d.f._inner[k];
                d.g.add({ $type: Point_$type, x: i.x, y: i.y });
            }
            d.a = true;
        }
        if (b.d == c.d) {
            d.d = c.d;
        }
        if (b.c == c.c) {
            d.c = c.c;
        }
        if (d.b) {
            d.h = b.h + (c.h - b.h) * a;
        }
    };
    MorphSegment.prototype.k = function () {
        this.f.clear();
        this.g.clear();
        this.e = false;
        this.a = false;
        this.b = false;
    };
    MorphSegment.$t = markType(MorphSegment, 'MorphSegment');
    return MorphSegment;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphNeedleFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphNeedleFrame, _super);
    function LinearGraphNeedleFrame() {
        var _this = _super.call(this) || this;
        _this.n = 0;
        _this.m = 0;
        _this.q = 0;
        _this.p = 0;
        _this.l = 0;
        _this.r = null;
        _this.s = null;
        _this.o = 0;
        _this.f = null;
        _this.g = null;
        _this.d = null;
        _this.j = null;
        _this.i = null;
        _this.k = null;
        _this.e = null;
        _this.h = null;
        _this.b = null;
        _this.c = null;
        _this.f = new MorphSegment();
        _this.g = new MorphSegment();
        _this.d = new MorphSegment();
        _this.j = new MorphSegment();
        _this.i = new MorphSegment();
        _this.k = new MorphSegment();
        _this.e = new MorphSegment();
        _this.h = new MorphSegment();
        _this.b = new MorphSegment();
        _this.c = new MorphSegment();
        return _this;
    }
    LinearGraphNeedleFrame.a = function (a, b, c, d) {
        var e = new LinearGraphNeedleFrame();
        e.n = c.n + (d.n - c.n) * a;
        e.m = c.m + (d.m - c.m) * a;
        e.q = c.q + (d.q - c.q) * a;
        e.l = c.l + (d.l - c.l) * a;
        e.p = c.p + (d.p - c.p) * a;
        e.r = BrushUtil.k(c.r, a, d.r, 0);
        e.s = BrushUtil.k(c.s, a, d.s, 0);
        e.o = c.o + (d.o - c.o) * a;
        e.f.j(a, c.f, d.f);
        e.g.j(a, c.g, d.g);
        e.d.j(a, c.d, d.d);
        e.j.j(a, c.j, d.j);
        e.i.j(a, c.i, d.i);
        e.k.j(a, c.k, d.k);
        e.e.j(a, c.e, d.e);
        e.h.j(a, c.h, d.h);
        e.b.j(a, c.b, d.b);
        e.c.j(a, c.c, d.c);
        return e;
    };
    LinearGraphNeedleFrame.prototype.t = function (a, b, c) {
        var d = new PathGeometry();
        var e = new PathFigure();
        var f = { $type: Point_$type, x: NaN, y: NaN };
        f = this.i.l(f, e, a, b, c);
        f = this.j.l(f, e, a, b, c);
        f = this.d.l(f, e, a, b, c);
        f = this.g.l(f, e, a, b, c);
        f = this.f.l(f, e, a, b, c);
        f = this.h.l(f, e, a, b, c);
        f = this.e.l(f, e, a, b, c);
        e._isClosed = true;
        d.c.add(e);
        var g = new PathFigure();
        if (this.b.f.count > 0 || this.c.f.count > 0) {
            f = this.b.l(f, g, a, b, c);
            f = this.c.l(f, g, a, b, c);
            g._isClosed = true;
            d.c.add(g);
        }
        return d;
    };
    LinearGraphNeedleFrame.$t = markType(LinearGraphNeedleFrame, 'LinearGraphNeedleFrame');
    return LinearGraphNeedleFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphScaleFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphScaleFrame, _super);
    function LinearGraphScaleFrame() {
        var _this = _super.call(this) || this;
        _this.m = null;
        _this.u = 0;
        _this.r = 0;
        _this.s = 0;
        _this.t = 0;
        _this.l = null;
        _this.j = null;
        _this.w = 0;
        _this.v = 0;
        _this.ad = null;
        _this.x = 0;
        _this.i = null;
        _this.p = 0;
        _this.o = 0;
        _this.ac = null;
        _this.q = 0;
        _this.e = null;
        _this.d = null;
        _this.f = null;
        _this.c = null;
        _this.g = null;
        _this.h = null;
        _this.n = 0;
        _this.ab = null;
        _this.m = new List$1(LinearGraphRectFrame.$, 0);
        _this.j = new Array(0);
        _this.i = new Array(0);
        _this.e = new Array(0);
        _this.d = new Array(0);
        _this.f = new Array(0);
        _this.c = new Array(0);
        _this.g = new Array(0);
        _this.h = new Array(0);
        _this.l = new LinearGraphRectFrame();
        return _this;
    }
    LinearGraphScaleFrame.prototype.ae = function (a, b, c, d) {
        var _this = this;
        var e = new PathGeometry();
        var f = new PathFigure();
        var g = a.x;
        var h = a.y;
        var i, j, k, l;
        if (d == 1) {
            i = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: g + b * _this.s, y: h };
                return $ret;
            })());
            j = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: g + b * _this.t, y: h };
                return $ret;
            })());
            k = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: g + b * _this.t, y: h + c };
                return $ret;
            })());
            l = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: g + b * _this.s, y: h + c };
                return $ret;
            })());
        }
        else {
            i = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: g, y: b * (1 - _this.t) };
                return $ret;
            })());
            j = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: g + c, y: b * (1 - _this.t) };
                return $ret;
            })());
            k = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: g + c, y: b * (1 - _this.s) };
                return $ret;
            })());
            l = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: g, y: b * (1 - _this.s) };
                return $ret;
            })());
        }
        f._startPoint = i.c;
        f._segments.add(j);
        f._segments.add(k);
        f._segments.add(l);
        f._isClosed = true;
        e.c.add(f);
        return e;
    };
    LinearGraphScaleFrame.prototype.y = function (a, b, c) {
        this.ad = BrushUtil.k(b.ad, a, c.ad, 0);
        this.ac = BrushUtil.k(b.ac, a, c.ac, 0);
        if (b.ab == null && c.ab == null) {
            this.ab = null;
        }
        else {
            this.ab = BrushUtil.k(b.ab, a, c.ab, 0);
        }
        this.u = b.u + (c.u - b.u) * a;
        this.r = b.r + (c.r - b.r) * a;
        this.s = b.s + (c.s - b.s) * a;
        this.t = b.t + (c.t - b.t) * a;
        this.n = b.n + (c.n - b.n) * a;
        this.w = b.w + (c.w - b.w) * a;
        this.v = b.v + (c.v - b.v) * a;
        this.p = b.p + (c.p - b.p) * a;
        this.o = b.o + (c.o - b.o) * a;
        this.x = b.x + (c.x - b.x) * a;
        this.q = b.q + (c.q - b.q) * a;
        this.j = this.a(a, this.j, b.j, c.j);
        this.i = this.a(a, this.i, b.i, c.i);
        this.e = this.a(a, this.e, b.e, c.e);
        this.f = this.a(a, this.f, b.f, c.f);
        this.c = this.a(a, this.c, b.c, c.c);
        this.g = this.a(a, this.g, b.g, c.g);
        this.h = this.a(a, this.h, b.h, c.h);
        this.d = this.b(a, this.d, b.d, c.d);
        this.aa(a, this.m, b.m, c.m);
        this.l = this.k(a, b.l, c.l);
    };
    LinearGraphScaleFrame.prototype.a = function (a, b, c, d) {
        var e = Math.max(c.length, d.length);
        var f = Math.min(c.length, d.length);
        if (b.length != e) {
            b = new Array(e);
        }
        var g = 0;
        if (c.length > 0) {
            g = c[c.length - 1];
        }
        var h = 0;
        if (d.length > 0) {
            h = d[d.length - 1];
        }
        var i = c.length > d.length;
        var j = 0;
        for (j = 0; j < f; j++) {
            b[j] = c[j] + (d[j] - c[j]) * a;
        }
        var k;
        var l;
        for (j = f; j < e; j++) {
            if (i) {
                k = c[j];
                l = h;
            }
            else {
                k = g;
                l = d[j];
            }
            b[j] = k + (l - k) * a;
        }
        return b;
    };
    LinearGraphScaleFrame.prototype.b = function (a, b, c, d) {
        var e = Math.max(c.length, d.length);
        var f = Math.min(c.length, d.length);
        if (b.length != e) {
            b = new Array(e);
        }
        var g = null;
        if (c.length > 0) {
            g = c[c.length - 1];
        }
        var h = null;
        if (d.length > 0) {
            h = d[d.length - 1];
        }
        var i = c.length > d.length;
        var j = 0;
        for (j = 0; j < f; j++) {
            b[j] = d[j];
        }
        var k;
        var l;
        for (j = f; j < e; j++) {
            if (i) {
                k = c[j];
                l = h;
            }
            else {
                k = g;
                l = d[j];
            }
            if (l != null) {
                b[j] = l;
            }
            else {
                b[j] = k;
            }
        }
        return b;
    };
    LinearGraphScaleFrame.prototype.aa = function (a, b, c, d) {
        InterpolationUtil.c(LinearGraphRectFrame.$, b, a, c, d, function () { return new LinearGraphRectFrame(); }, LinearGraphRectFrame.a);
    };
    LinearGraphScaleFrame.prototype.k = function (a, b, c) {
        var d = 1 - a;
        return LinearGraphRectFrame.a(a, d, b, c);
    };
    LinearGraphScaleFrame.prototype.z = function (a, b, c, d) {
        InterpolationUtil.c(LinearGraphNeedleFrame.$, b, a, c, d, function () { return new LinearGraphNeedleFrame(); }, LinearGraphNeedleFrame.a);
    };
    LinearGraphScaleFrame.$t = markType(LinearGraphScaleFrame, 'LinearGraphScaleFrame');
    return LinearGraphScaleFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var BulletGraphScaleFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(BulletGraphScaleFrame, _super);
    function BulletGraphScaleFrame() {
        var _this = _super.call(this) || this;
        _this.af = null;
        _this.af = new LinearGraphRectFrame();
        return _this;
    }
    BulletGraphScaleFrame.prototype.y = function (a, b, c) {
        _super.prototype.y.call(this, a, b, c);
        this.af = LinearGraphRectFrame.a(a, 1 - a, b.af, c.af);
    };
    BulletGraphScaleFrame.$t = markType(BulletGraphScaleFrame, 'BulletGraphScaleFrame', LinearGraphScaleFrame.$);
    return BulletGraphScaleFrame;
}(LinearGraphScaleFrame));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var BulletGraphFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(BulletGraphFrame, _super);
    function BulletGraphFrame() {
        var _this = _super.call(this) || this;
        _this._c = null;
        _this.c = new BulletGraphScaleFrame();
        return _this;
    }
    BulletGraphFrame.prototype.get_c = function () {
        return this._c;
    };
    BulletGraphFrame.prototype.set_c = function (a) {
        this._c = a;
    };
    Object.defineProperty(BulletGraphFrame.prototype, "c", {
        get: function () {
            return this.get_c();
        },
        set: function (a) {
            this.set_c(a);
        },
        enumerable: true,
        configurable: true
    });
    BulletGraphFrame.$t = markType(BulletGraphFrame, 'BulletGraphFrame', LinearGraphFrame.$);
    return BulletGraphFrame;
}(LinearGraphFrame));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphScaler = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphScaler, _super);
    function LinearGraphScaler(a, b, c, d, e) {
        var _this = _super.call(this) || this;
        _this.f = 0;
        _this.e = 0;
        _this.d = 0;
        _this.c = 0;
        _this.a = false;
        _this.g = 0;
        _this.b = 0;
        _this.f = c;
        _this.e = d;
        _this.a = e;
        _this.d = a;
        _this.c = b;
        _this.g = c;
        _this.b = d;
        return _this;
    }
    Object.defineProperty(LinearGraphScaler.prototype, "j", {
        get: function () {
            return this.g;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphScaler.prototype, "h", {
        get: function () {
            return this.b;
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphScaler.prototype.i = function (a) {
        var b = (a - this.d) / (this.c - this.d);
        if (this.a) {
            b = 1 - b;
        }
        var c = this.g + (this.b - this.g) * b;
        c = Math.round(c * 100) / 100;
        return c;
    };
    LinearGraphScaler.prototype.k = function (a) {
        var b = (a - this.g) / (this.b - this.g);
        if (this.a) {
            b = 1 - b;
        }
        var c = this.d + (this.c - this.d) * b;
        return c;
    };
    LinearGraphScaler.$t = markType(LinearGraphScaler, 'LinearGraphScaler');
    return LinearGraphScaler;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Describes the orientation of a linear scale.
 */
var LinearScaleOrientation = /*@__PURE__*/ (function (LinearScaleOrientation) {
    /**
     * The scale has a horizontal orientation.
     */
    LinearScaleOrientation[LinearScaleOrientation["Horizontal"] = 0] = "Horizontal";
    /**
     * The scale has a vertical orientation.
     */
    LinearScaleOrientation[LinearScaleOrientation["Vertical"] = 1] = "Vertical";
    return LinearScaleOrientation;
})({});
/**
 * @hidden
 */
var LinearScaleOrientation_$type = /*@__PURE__*/ markEnum('LinearScaleOrientation', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var XamLinearGraphRange = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(XamLinearGraphRange, _super);
    function XamLinearGraphRange() {
        var _this = _super.call(this) || this;
        _this.propertyChanged = null;
        return _this;
    }
    XamLinearGraphRange.prototype.ac = function (a, b, c) {
    };
    XamLinearGraphRange.prototype.ab = function (a, b, c) {
        this.ac(a, b, c);
        if (this.propertyChanged != null) {
            this.propertyChanged(this, new PropertyChangedEventArgs(a));
        }
    };
    XamLinearGraphRange.$t = markType(XamLinearGraphRange, 'XamLinearGraphRange', DependencyObject.$, [INotifyPropertyChanged_$type]);
    XamLinearGraphRange.$$p = markDep(DependencyProperty, PropertyMetadata, XamLinearGraphRange, 'ab', ['Brush:an:ad', [Brush.$, null], 'EndValue:j:ae', [1, NaN], 'InnerEndExtent:k:af', [1, NaN], 'InnerStartExtent:l:ag', [1, NaN], 'Name:u:ah', [2, null], 'OuterEndExtent:m:ai', [1, NaN], 'OuterStartExtent:n:aj', [1, NaN], 'Outline:ao:ak', [Brush.$, null], 'StartValue:o:al', [1, NaN], 'StrokeThickness:p:am', [1, 1]]);
    return XamLinearGraphRange;
}(DependencyObject));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphRangeCollection = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphRangeCollection, _super);
    function LinearGraphRangeCollection() {
        return _super.call(this, XamLinearGraphRange.$, 0) || this;
    }
    LinearGraphRangeCollection.$t = markType(LinearGraphRangeCollection, 'LinearGraphRangeCollection', ObservableCollection$1.$.specialize(XamLinearGraphRange.$));
    return LinearGraphRangeCollection;
}(ObservableCollection$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var FormatLinearGraphLabelEventArgs = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(FormatLinearGraphLabelEventArgs, _super);
    function FormatLinearGraphLabelEventArgs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.actualMinimumValue = 0;
        _this.actualMaximumValue = 0;
        _this.value = 0;
        _this.label = null;
        return _this;
    }
    FormatLinearGraphLabelEventArgs.$t = markType(FormatLinearGraphLabelEventArgs, 'FormatLinearGraphLabelEventArgs', EventArgs.$);
    return FormatLinearGraphLabelEventArgs;
}(EventArgs));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var AlignLinearGraphLabelEventArgs = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(AlignLinearGraphLabelEventArgs, _super);
    function AlignLinearGraphLabelEventArgs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = 0;
        _this.height = 0;
        _this.offsetX = 0;
        _this.offsetY = 0;
        return _this;
    }
    AlignLinearGraphLabelEventArgs.$t = markType(AlignLinearGraphLabelEventArgs, 'AlignLinearGraphLabelEventArgs', FormatLinearGraphLabelEventArgs.$);
    return AlignLinearGraphLabelEventArgs;
}(FormatLinearGraphLabelEventArgs));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphVisualData, _super);
    function LinearGraphVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._scalePath = null;
        _this._backingPath = null;
        _this._underlayPath = null;
        _this._overlayPath = null;
        _this._scale = null;
        _this._scaleLabels = null;
        _this._scaleTickmarks = null;
        _this._ranges = null;
        _this._toolTip = null;
        _this._name = null;
        _this._viewport = null;
        return _this;
    }
    Object.defineProperty(LinearGraphVisualData.prototype, "scalePath", {
        get: function () {
            return this._scalePath;
        },
        set: function (a) {
            this._scalePath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "backingPath", {
        get: function () {
            return this._backingPath;
        },
        set: function (a) {
            this._backingPath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "underlayPath", {
        get: function () {
            return this._underlayPath;
        },
        set: function (a) {
            this._underlayPath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "overlayPath", {
        get: function () {
            return this._overlayPath;
        },
        set: function (a) {
            this._overlayPath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "scale", {
        get: function () {
            return this._scale;
        },
        set: function (a) {
            this._scale = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "scaleLabels", {
        get: function () {
            return this._scaleLabels;
        },
        set: function (a) {
            this._scaleLabels = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "scaleTickmarks", {
        get: function () {
            return this._scaleTickmarks;
        },
        set: function (a) {
            this._scaleTickmarks = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "ranges", {
        get: function () {
            return this._ranges;
        },
        set: function (a) {
            this._ranges = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "toolTip", {
        get: function () {
            return this._toolTip;
        },
        set: function (a) {
            this._toolTip = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphVisualData.prototype, "name", {
        get: function () {
            return this._name;
        },
        set: function (a) {
            this._name = a;
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphVisualData.prototype.scaleByViewport = function () {
        var e_1, _a, e_2, _b, e_3, _c;
        if (this.scalePath != null) {
            this.scalePath.scaleByViewport(this.viewport);
        }
        if (this.backingPath != null) {
            this.backingPath.scaleByViewport(this.viewport);
        }
        if (this.underlayPath != null) {
            this.underlayPath.scaleByViewport(this.viewport);
        }
        if (this.overlayPath != null) {
            this.overlayPath.scaleByViewport(this.viewport);
        }
        if (this.scaleLabels != null) {
            try {
                for (var _d = __values(fromEnum(this.scaleLabels)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var a = _e.value;
                    a.scaleByViewport(this.viewport);
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return))
                        _a.call(_d);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        }
        if (this.scaleTickmarks != null) {
            try {
                for (var _f = __values(fromEnum(this.scaleTickmarks)), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var b = _g.value;
                    if (b.tickPath != null) {
                        b.tickPath.scaleByViewport(this.viewport);
                    }
                }
            }
            catch (e_2_1) {
                e_2 = { error: e_2_1 };
            }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return))
                        _b.call(_f);
                }
                finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
        }
        if (this.ranges != null) {
            try {
                for (var _h = __values(fromEnum(this.ranges)), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var c = _j.value;
                    if (c.rangePath != null) {
                        c.rangePath.scaleByViewport(this.viewport);
                    }
                }
            }
            catch (e_3_1) {
                e_3 = { error: e_3_1 };
            }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return))
                        _c.call(_h);
                }
                finally {
                    if (e_3)
                        throw e_3.error;
                }
            }
        }
    };
    LinearGraphVisualData.prototype.serialize = function () {
        var e_4, _a, e_5, _b, e_6, _c;
        var a = new StringBuilder(0);
        var b = true;
        a.u("{");
        if (this.scalePath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("scalePath: ");
            a.u(this.scalePath.serialize());
        }
        if (this.backingPath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("backingPath: ");
            a.u(this.backingPath.serialize());
        }
        if (this.underlayPath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("underlayPath: ");
            a.u(this.underlayPath.serialize());
        }
        if (this.overlayPath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("overlayPath: ");
            a.u(this.overlayPath.serialize());
        }
        if (this.scaleLabels != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            var c = true;
            a.l("scaleLabels: [");
            try {
                for (var _d = __values(fromEnum(this.scaleLabels)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var d = _e.value;
                    if (c) {
                        c = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(d.serialize());
                }
            }
            catch (e_4_1) {
                e_4 = { error: e_4_1 };
            }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return))
                        _a.call(_d);
                }
                finally {
                    if (e_4)
                        throw e_4.error;
                }
            }
            a.u("]");
        }
        if (this.scaleTickmarks != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            var e = true;
            a.l("scaleTickmarks: [");
            try {
                for (var _f = __values(fromEnum(this.scaleTickmarks)), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var f = _g.value;
                    if (e) {
                        e = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(f.serialize());
                }
            }
            catch (e_5_1) {
                e_5 = { error: e_5_1 };
            }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return))
                        _b.call(_f);
                }
                finally {
                    if (e_5)
                        throw e_5.error;
                }
            }
            a.u("]");
        }
        if (this.ranges != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            var g = true;
            a.l("ranges: [");
            try {
                for (var _h = __values(fromEnum(this.ranges)), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var h = _j.value;
                    if (g) {
                        g = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(h.serialize());
                }
            }
            catch (e_6_1) {
                e_6 = { error: e_6_1 };
            }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return))
                        _c.call(_h);
                }
                finally {
                    if (e_6)
                        throw e_6.error;
                }
            }
            a.u("]");
        }
        if (this.name != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("name: '");
            a.l(this.name);
            a.u("'");
        }
        if (this.toolTip != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("toolTip: ");
            a.l(this.toolTip.serialize());
        }
        if (b) {
            b = false;
        }
        else {
            a.l(", ");
        }
        a.l("viewport: {");
        a.l("left: " + this.viewport.left + ", top: " + this.viewport.top + ", width: " + this.viewport.width + ", height: " + this.viewport.height);
        a.u("}");
        a.l("}");
        return a.toString();
    };
    Object.defineProperty(LinearGraphVisualData.prototype, "viewport", {
        get: function () {
            return this._viewport;
        },
        set: function (a) {
            this._viewport = a;
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphVisualData.$t = markType(LinearGraphVisualData, 'LinearGraphVisualData');
    return LinearGraphVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var BulletGraphVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(BulletGraphVisualData, _super);
    function BulletGraphVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._targetValuePath = null;
        _this._valuePath = null;
        _this._scaleBackgroundPath = null;
        _this._targetValue = null;
        _this._value = null;
        return _this;
    }
    Object.defineProperty(BulletGraphVisualData.prototype, "targetValuePath", {
        get: function () {
            return this._targetValuePath;
        },
        set: function (a) {
            this._targetValuePath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BulletGraphVisualData.prototype, "valuePath", {
        get: function () {
            return this._valuePath;
        },
        set: function (a) {
            this._valuePath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BulletGraphVisualData.prototype, "scaleBackgroundPath", {
        get: function () {
            return this._scaleBackgroundPath;
        },
        set: function (a) {
            this._scaleBackgroundPath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BulletGraphVisualData.prototype, "targetValue", {
        get: function () {
            return this._targetValue;
        },
        set: function (a) {
            this._targetValue = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BulletGraphVisualData.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (a) {
            this._value = a;
        },
        enumerable: true,
        configurable: true
    });
    BulletGraphVisualData.prototype.scaleByViewport = function () {
        _super.prototype.scaleByViewport.call(this);
        if (this.targetValuePath != null) {
            this.targetValuePath.scaleByViewport(this.viewport);
        }
        if (this.valuePath != null) {
            this.valuePath.scaleByViewport(this.viewport);
        }
        if (this.scaleBackgroundPath != null) {
            this.scaleBackgroundPath.scaleByViewport(this.viewport);
        }
    };
    BulletGraphVisualData.prototype.serialize = function () {
        var a = _super.prototype.serialize.call(this);
        var b = new StringBuilder(0);
        var c = a.length == 0;
        if (this.targetValuePath != null) {
            if (c) {
                c = false;
            }
            else {
                b.l(", ");
            }
            b.l("targetValuePath: ");
            b.u(this.targetValuePath.serialize());
        }
        if (this.targetValue != null) {
            if (c) {
                c = false;
            }
            else {
                b.l(", ");
            }
            b.l("targetValue: ");
            b.u(this.targetValue.serialize());
        }
        if (this.valuePath != null) {
            if (c) {
                c = false;
            }
            else {
                b.l(", ");
            }
            b.l("valuePath: ");
            b.u(this.valuePath.serialize());
        }
        if (this.value != null) {
            if (c) {
                c = false;
            }
            else {
                b.l(", ");
            }
            b.l("value: ");
            b.u(this.value.serialize());
        }
        if (this.scaleBackgroundPath != null) {
            if (c) {
                c = false;
            }
            else {
                b.l(", ");
            }
            b.l("scaleBackgroundPath: ");
            b.u(this.scaleBackgroundPath.serialize());
        }
        if (c) {
            return a;
        }
        b.l("}");
        return a.substr(0, a.length - 1) + b.toString();
    };
    BulletGraphVisualData.$t = markType(BulletGraphVisualData, 'BulletGraphVisualData', LinearGraphVisualData.$);
    return BulletGraphVisualData;
}(LinearGraphVisualData));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var ToolTipInfo = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ToolTipInfo, _super);
    function ToolTipInfo() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.c = null;
        _this.b = 0;
        _this.d = null;
        _this.a = null;
        return _this;
    }
    ToolTipInfo.$t = markType(ToolTipInfo, 'ToolTipInfo');
    return ToolTipInfo;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphScaleLabelVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphScaleLabelVisualData, _super);
    function LinearGraphScaleLabelVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._labelValue = null;
        _this._labelSize = null;
        _this._labelPosition = null;
        _this._appearance = null;
        return _this;
    }
    Object.defineProperty(LinearGraphScaleLabelVisualData.prototype, "labelValue", {
        get: function () {
            return this._labelValue;
        },
        set: function (a) {
            this._labelValue = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphScaleLabelVisualData.prototype, "labelSize", {
        get: function () {
            return this._labelSize;
        },
        set: function (a) {
            this._labelSize = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphScaleLabelVisualData.prototype, "labelPosition", {
        get: function () {
            return this._labelPosition;
        },
        set: function (a) {
            this._labelPosition = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphScaleLabelVisualData.prototype, "appearance", {
        get: function () {
            return this._appearance;
        },
        set: function (a) {
            this._appearance = a;
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphScaleLabelVisualData.prototype.scaleByViewport = function (a) {
        this.labelPosition = new PointData((this.labelPosition.x - a.left) / a.width, (this.labelPosition.y - a.top) / a.height);
        this.labelSize = new SizeData((this.labelSize.width) / a.width, (this.labelSize.height) / a.height);
    };
    LinearGraphScaleLabelVisualData.prototype.serialize = function () {
        return "{ labelValue: '" + this.labelValue + "', labelSize: { width: " + this.labelSize.width + ", height: " + this.labelSize.height + "}, labelPosition: { x: " + this.labelPosition.x + ", y: " + this.labelPosition.y + "}, appearance: " + this.appearance.serialize() + "}";
    };
    LinearGraphScaleLabelVisualData.$t = markType(LinearGraphScaleLabelVisualData, 'LinearGraphScaleLabelVisualData');
    return LinearGraphScaleLabelVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphScaleLabelVisualDataList = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphScaleLabelVisualDataList, _super);
    function LinearGraphScaleLabelVisualDataList() {
        return _super.call(this, LinearGraphScaleLabelVisualData.$, 0) || this;
    }
    LinearGraphScaleLabelVisualDataList.$t = markType(LinearGraphScaleLabelVisualDataList, 'LinearGraphScaleLabelVisualDataList', List$1.$.specialize(LinearGraphScaleLabelVisualData.$));
    return LinearGraphScaleLabelVisualDataList;
}(List$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphScaleTickmarkVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphScaleTickmarkVisualData, _super);
    function LinearGraphScaleTickmarkVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._tickPath = null;
        return _this;
    }
    Object.defineProperty(LinearGraphScaleTickmarkVisualData.prototype, "tickPath", {
        get: function () {
            return this._tickPath;
        },
        set: function (a) {
            this._tickPath = a;
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphScaleTickmarkVisualData.prototype.serialize = function () {
        return "{ tickPath: " + this.tickPath.serialize() + "}";
    };
    LinearGraphScaleTickmarkVisualData.$t = markType(LinearGraphScaleTickmarkVisualData, 'LinearGraphScaleTickmarkVisualData');
    return LinearGraphScaleTickmarkVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphScaleTickmarkVisualDataList = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphScaleTickmarkVisualDataList, _super);
    function LinearGraphScaleTickmarkVisualDataList() {
        return _super.call(this, LinearGraphScaleTickmarkVisualData.$, 0) || this;
    }
    LinearGraphScaleTickmarkVisualDataList.$t = markType(LinearGraphScaleTickmarkVisualDataList, 'LinearGraphScaleTickmarkVisualDataList', List$1.$.specialize(LinearGraphScaleTickmarkVisualData.$));
    return LinearGraphScaleTickmarkVisualDataList;
}(List$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var ToolTipItemVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ToolTipItemVisualData, _super);
    function ToolTipItemVisualData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolTipItemVisualData.$t = markType(ToolTipItemVisualData, 'ToolTipItemVisualData');
    return ToolTipItemVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphRangeVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphRangeVisualData, _super);
    function LinearGraphRangeVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._rangePath = null;
        return _this;
    }
    Object.defineProperty(LinearGraphRangeVisualData.prototype, "rangePath", {
        get: function () {
            return this._rangePath;
        },
        set: function (a) {
            this._rangePath = a;
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphRangeVisualData.prototype.serialize = function () {
        return "{ rangePath: " + this.rangePath.serialize() + ", type: '" + this.type + "'}";
    };
    LinearGraphRangeVisualData.prototype.get_type = function () {
        return "range";
    };
    Object.defineProperty(LinearGraphRangeVisualData.prototype, "type", {
        get: function () {
            return this.get_type();
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphRangeVisualData.$t = markType(LinearGraphRangeVisualData, 'LinearGraphRangeVisualData', ToolTipItemVisualData.$);
    return LinearGraphRangeVisualData;
}(ToolTipItemVisualData));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphRangeVisualDataList = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphRangeVisualDataList, _super);
    function LinearGraphRangeVisualDataList() {
        return _super.call(this, LinearGraphRangeVisualData.$, 0) || this;
    }
    LinearGraphRangeVisualDataList.$t = markType(LinearGraphRangeVisualDataList, 'LinearGraphRangeVisualDataList', List$1.$.specialize(LinearGraphRangeVisualData.$));
    return LinearGraphRangeVisualDataList;
}(List$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var ValueVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ValueVisualData, _super);
    function ValueVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = 0;
        return _this;
    }
    Object.defineProperty(ValueVisualData.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (a) {
            this._value = a;
        },
        enumerable: true,
        configurable: true
    });
    ValueVisualData.prototype.serialize = function () {
        return "{ value: " + this.value.toString() + ", type: '" + this.type + "'}";
    };
    ValueVisualData.prototype.get_type = function () {
        return "value";
    };
    Object.defineProperty(ValueVisualData.prototype, "type", {
        get: function () {
            return this.get_type();
        },
        enumerable: true,
        configurable: true
    });
    ValueVisualData.$t = markType(ValueVisualData, 'ValueVisualData', ToolTipItemVisualData.$);
    return ValueVisualData;
}(ToolTipItemVisualData));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var BulletGraphTargetValueVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(BulletGraphTargetValueVisualData, _super);
    function BulletGraphTargetValueVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = 0;
        return _this;
    }
    Object.defineProperty(BulletGraphTargetValueVisualData.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (a) {
            this._value = a;
        },
        enumerable: true,
        configurable: true
    });
    BulletGraphTargetValueVisualData.prototype.serialize = function () {
        return "{ value: " + this.value.toString() + ", type: '" + this.type + "'}";
    };
    BulletGraphTargetValueVisualData.prototype.get_type = function () {
        return "targetValue";
    };
    Object.defineProperty(BulletGraphTargetValueVisualData.prototype, "type", {
        get: function () {
            return this.get_type();
        },
        enumerable: true,
        configurable: true
    });
    BulletGraphTargetValueVisualData.$t = markType(BulletGraphTargetValueVisualData, 'BulletGraphTargetValueVisualData', ToolTipItemVisualData.$);
    return BulletGraphTargetValueVisualData;
}(ToolTipItemVisualData));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphToolTipVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphToolTipVisualData, _super);
    function LinearGraphToolTipVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._item = null;
        _this._outline = null;
        _this._itemBrush = null;
        _this._thickness = 0;
        return _this;
    }
    Object.defineProperty(LinearGraphToolTipVisualData.prototype, "item", {
        get: function () {
            return this._item;
        },
        set: function (a) {
            this._item = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphToolTipVisualData.prototype, "outline", {
        get: function () {
            return this._outline;
        },
        set: function (a) {
            this._outline = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphToolTipVisualData.prototype, "itemBrush", {
        get: function () {
            return this._itemBrush;
        },
        set: function (a) {
            this._itemBrush = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphToolTipVisualData.prototype, "thickness", {
        get: function () {
            return this._thickness;
        },
        set: function (a) {
            this._thickness = a;
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphToolTipVisualData.prototype.serialize = function () {
        var a = new StringBuilder(0);
        a.l("{ item: ");
        if (this.item != null) {
            a.l(this.item.serialize());
        }
        a.l(", ");
        a.l("outline: ");
        a.l(this.outline.serialize());
        a.l(", ");
        a.l("itemBrush: ");
        a.l(this.itemBrush.serialize());
        a.l(", ");
        a.l("thickness: ");
        a.l(this.thickness.toString());
        a.l("}");
        return a.toString();
    };
    LinearGraphToolTipVisualData.$t = markType(LinearGraphToolTipVisualData, 'LinearGraphToolTipVisualData');
    return LinearGraphToolTipVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphTooltipDataContext = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphTooltipDataContext, _super);
    function LinearGraphTooltipDataContext() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propertyChanged = null;
        return _this;
    }
    Object.defineProperty(LinearGraphTooltipDataContext.prototype, "item", {
        get: function () {
            return this.c(LinearGraphTooltipDataContext.itemProperty);
        },
        set: function (a) {
            this.h(LinearGraphTooltipDataContext.itemProperty, a);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphTooltipDataContext.prototype, "itemName", {
        get: function () {
            return this.c(LinearGraphTooltipDataContext.itemNameProperty);
        },
        set: function (a) {
            this.h(LinearGraphTooltipDataContext.itemNameProperty, a);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphTooltipDataContext.prototype, "brush", {
        get: function () {
            return this.c(LinearGraphTooltipDataContext.itemBrushProperty);
        },
        set: function (a) {
            this.h(LinearGraphTooltipDataContext.itemBrushProperty, a);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphTooltipDataContext.prototype, "label", {
        get: function () {
            return this.c(LinearGraphTooltipDataContext.labelProperty);
        },
        set: function (a) {
            this.h(LinearGraphTooltipDataContext.labelProperty, a);
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphTooltipDataContext.prototype.p = function (a, b, c) {
        if (this.propertyChanged != null) {
            this.propertyChanged(this, new PropertyChangedEventArgs(a));
        }
    };
    LinearGraphTooltipDataContext.$t = markType(LinearGraphTooltipDataContext, 'LinearGraphTooltipDataContext', DependencyObject.$, [INotifyPropertyChanged_$type]);
    LinearGraphTooltipDataContext.labelProperty = DependencyProperty.i("Label", String_$type, LinearGraphTooltipDataContext.$, new PropertyMetadata(2, null, function (a, b) { return (typeCast(LinearGraphTooltipDataContext.$, a)).p("Label", b.oldValue, b.newValue); }));
    LinearGraphTooltipDataContext.itemProperty = DependencyProperty.i("Item", Base.$, LinearGraphTooltipDataContext.$, new PropertyMetadata(2, null, function (a, b) { return (typeCast(LinearGraphTooltipDataContext.$, a)).p("Item", b.oldValue, b.newValue); }));
    LinearGraphTooltipDataContext.itemNameProperty = DependencyProperty.i("ItemName", Base.$, LinearGraphTooltipDataContext.$, new PropertyMetadata(2, null, function (a, b) { return (typeCast(LinearGraphTooltipDataContext.$, a)).p("ItemName", b.oldValue, b.newValue); }));
    LinearGraphTooltipDataContext.itemBrushProperty = DependencyProperty.i("ItemBrush", Brush.$, LinearGraphTooltipDataContext.$, new PropertyMetadata(2, null, function (a, b) { return (typeCast(LinearGraphTooltipDataContext.$, a)).p("ItemBrush", b.oldValue, b.newValue); }));
    LinearGraphTooltipDataContext.$$p = markDep(DependencyProperty, PropertyMetadata, LinearGraphTooltipDataContext, 'p', ['Outline', [Brush.$, null], 'Thickness', [1, 0]]);
    return LinearGraphTooltipDataContext;
}(DependencyObject));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var XamBulletGraph = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(XamBulletGraph, _super);
    function XamBulletGraph() {
        var _this = _super.call(this) || this;
        _this.propertyChanged = null;
        _this.av = null;
        _this.bj = 0;
        _this.formatLabel = null;
        _this.alignLabel = null;
        _this.an = null;
        _this.am = null;
        _this.al = null;
        _this.aq = null;
        _this.au = null;
        _this.bg = 0;
        _this.bf = 100;
        _this.aj = null;
        _this.a8 = false;
        _this.a0 = null;
        _this.ay = null;
        _this.ax = null;
        _this.a1 = null;
        _this.az = null;
        _this._view = null;
        _this.ht = null;
        _this.hs = null;
        _this.hr = null;
        _this.bi = NaN;
        _this.bh = 1;
        _this.ba = new List$1(TextBlock.$, 0);
        _this.bd = new List$1(TextBlock.$, 0);
        _this.bc = new List$1(Path.$, 0);
        _this.bb = new List$1(Path.$, 0);
        _this.a3 = false;
        _this.bi = NaN;
        _this.bh = 1;
        _this.au = new XamLinearGraphRange();
        var a = _this.au;
        a.propertyChanged = delegateCombine(a.propertyChanged, runOn(_this, _this.ff));
        _this.view = new XamBulletGraphView(_this);
        _this.view.a9();
        _this.ht = Rect.empty;
        _this.hs = Rect.empty;
        _this.hr = Rect.empty;
        _this.an = new BulletGraphFrame();
        _this.am = new BulletGraphFrame();
        _this.al = new BulletGraphFrame();
        _this.ranges = new LinearGraphRangeCollection();
        _this.a3 = true;
        _this.av = new DoubleAnimator(0, 1, _this.cy);
        var b = _this.av;
        b.propertyChanged = delegateCombine(b.propertyChanged, runOn(_this, _this.ev));
        _this.ab = XamBulletGraph.$;
        _this.az = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.bj);
            $ret.c = runOn(_this.view, _this.view.bk);
            $ret.d = runOn(_this.view, _this.view.bl);
            $ret.j = runOn(_this.view, _this.view.cq);
            return $ret;
        })());
        _this.a0 = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.bc);
            $ret.c = runOn(_this.view, _this.view.bd);
            $ret.d = runOn(_this.view, _this.view.be);
            $ret.j = runOn(_this.view, _this.view.cp);
            return $ret;
        })());
        _this.ay = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.bc);
            $ret.c = runOn(_this.view, _this.view.bd);
            $ret.d = runOn(_this.view, _this.view.be);
            $ret.j = runOn(_this.view, _this.view.cp);
            return $ret;
        })());
        _this.ax = ((function () {
            var $ret = new StackPool$1(TextBlock.$);
            $ret.b = runOn(_this.view, _this.view.a1);
            $ret.c = runOn(_this.view, _this.view.a2);
            $ret.d = runOn(_this.view, _this.view.a3);
            $ret.j = runOn(_this.view, _this.view.b0);
            return $ret;
        })());
        _this.a1 = ((function () {
            var $ret = new StackPool$1(TextBlock.$);
            $ret.b = runOn(_this.view, _this.view.bt);
            $ret.c = runOn(_this.view, _this.view.bu);
            $ret.d = runOn(_this.view, _this.view.bv);
            $ret.j = runOn(_this.view, _this.view.b1);
            return $ret;
        })());
        return _this;
    }
    XamBulletGraph.prototype.e6 = function (a) {
        this.fd(a);
    };
    XamBulletGraph.prototype.fd = function (a) {
        var b = this.propertyChanged;
        if (b != null) {
            b(this, new PropertyChangedEventArgs(a));
        }
    };
    XamBulletGraph.prototype.onDetachedFromUI = function () {
        this.view.a8();
    };
    XamBulletGraph.prototype.onAttachedToUI = function () {
        this.view.a4();
    };
    XamBulletGraph.prototype.ev = function (a, b) {
        this.cq = this.av.o;
    };
    Object.defineProperty(XamBulletGraph.prototype, "a2", {
        get: function () {
            return this.av.f();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "cq", {
        get: function () {
            return this.bj;
        },
        set: function (a) {
            var b = this.bj;
            this.bj = a;
            this.e5("TransitionProgress", b, this.bj);
        },
        enumerable: true,
        configurable: true
    });
    XamBulletGraph.prototype.fq = function () {
        this.bj = 0;
        this.av.w();
        this.av.v();
    };
    Object.defineProperty(XamBulletGraph.prototype, "a7", {
        get: function () {
            return this.cy > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "hj", {
        get: function () {
            return this.c(XamBulletGraph.gl);
        },
        set: function (a) {
            this.h(XamBulletGraph.gl, a);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "hk", {
        get: function () {
            return this.c(XamBulletGraph.gm);
        },
        set: function (a) {
            this.h(XamBulletGraph.gm, a);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "b8", {
        get: function () {
            return this.c(XamBulletGraph.gn);
        },
        set: function (a) {
            this.h(XamBulletGraph.gn, a);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "bl", {
        get: function () {
            return this.bg;
        },
        set: function (a) {
            this.bg = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "bk", {
        get: function () {
            return this.bf;
        },
        set: function (a) {
            this.bf = a;
        },
        enumerable: true,
        configurable: true
    });
    XamBulletGraph.prototype.br = function (a) {
        var b = 0;
        var c = a.x;
        if (this.ar == 1) {
            b = a.y;
            c = this.hw.height;
        }
        return this.aq.k(c - b);
    };
    XamBulletGraph.prototype.as = function () {
        var _this = this;
        var a = new BulletGraphVisualData();
        a.viewport = new RectData(this.hw.left, this.hw.top, this.hw.width, this.hw.height);
        a.scaleLabels = new LinearGraphScaleLabelVisualDataList();
        a.scaleTickmarks = new LinearGraphScaleTickmarkVisualDataList();
        a.ranges = new LinearGraphRangeVisualDataList();
        a.value = ((function () {
            var $ret = new ValueVisualData();
            $ret.value = _this.cr;
            return $ret;
        })());
        a.targetValue = ((function () {
            var $ret = new BulletGraphTargetValueVisualData();
            $ret.value = _this.ce;
            return $ret;
        })());
        this.view.aw(a);
        var b = this.view.l();
        if (b != null) {
            var c_1;
            switch (b.c) {
                case "range":
                    c_1 = a.ranges._inner[b.b];
                    break;
                case "value":
                    c_1 = a.value;
                    break;
                default:
                    c_1 = a.targetValue;
                    break;
            }
            a.toolTip = ((function () {
                var $ret = new LinearGraphToolTipVisualData();
                $ret.item = c_1;
                $ret.itemBrush = AppearanceHelper.b(b.a.brush);
                $ret.outline = AppearanceHelper.b(b.a.outline);
                $ret.thickness = b.a.thickness;
                return $ret;
            })());
        }
        return a;
    };
    XamBulletGraph.prototype.c6 = function () {
        var a = this.as();
        a.scaleByViewport();
        return a.serialize();
    };
    XamBulletGraph.prototype.destroy = function () {
        this.provideContainer(null);
    };
    XamBulletGraph.prototype.provideContainer = function (a) {
        this.view.a6(a);
    };
    XamBulletGraph.prototype.onMouseOver = function (a, b, c) {
        if (this.a8) {
            this.fp(a, null);
        }
    };
    XamBulletGraph.prototype.onMouseLeave = function () {
        if (this.a8) {
            this.fp({ $type: Point_$type, x: -10000, y: -10000 }, null);
        }
    };
    XamBulletGraph.prototype.containerResized = function () {
        this.view.a7();
    };
    XamBulletGraph.prototype.fr = function () {
        this.view.bs();
    };
    XamBulletGraph.prototype.ez = function () {
        this.view.flush();
    };
    XamBulletGraph.prototype.be = function (a) {
        var b = new List$1(Point_$type, 0);
        for (var c = 0; c < a.count; c++) {
            b.add({ $type: Point_$type, x: a._inner[c].x, y: a._inner[c].y });
        }
        return b;
    };
    XamBulletGraph.prototype.fp = function (a, b) {
        var c = new PathVisualData(1, "targetValue", this.view.cn());
        var d = c.getPoints(new GetPointsSettings());
        if (d.count > 0) {
            var e = PolygonUtil.a(this.be(d._inner[0]), a);
            if (e == true) {
                this.view.br(a, b, -1, "targetvalue");
                return;
            }
        }
        var f = new PathVisualData(1, "value", this.view.co());
        var g = f.getPoints(new GetPointsSettings());
        if (g.count > 0) {
            var h = PolygonUtil.a(this.be(g._inner[0]), a);
            if (h == true) {
                this.view.br(a, b, -1, "value");
                return;
            }
        }
        for (var i = 0; i < this.bb.count; i++) {
            var j = new PathVisualData(1, "range", this.bb._inner[i]);
            var k = j.getPoints(new GetPointsSettings());
            if (k.count > 0) {
                var l = PolygonUtil.a(this.be(k._inner[0]), a);
                if (l == true) {
                    this.view.br(a, b, i, "range");
                    return;
                }
            }
        }
        this.view.az();
    };
    XamBulletGraph.prototype.fi = function () {
        if (!this.a3) {
            return;
        }
        var a = this.am.c;
        if (this.ar == 0) {
            var b = 0;
            for (var c = 0; c < a.c.length; c++) {
                b = Math.max(b, a.c[c]);
            }
            var d = this.hw.height >= b ? this.hw.height - b : this.hw.height;
            this.hv = new Rect(0, 0, 0, this.hw.width, d);
        }
        else {
            var e = 0;
            for (var f = 0; f < a.f.length; f++) {
                e = Math.max(e, a.f[f]);
            }
            var g = this.hw.width >= e ? this.hw.width - e : this.hw.width;
            this.hv = new Rect(0, e, 0, g, this.hw.height);
        }
    };
    Object.defineProperty(XamBulletGraph.prototype, "view", {
        get: function () {
            return this._view;
        },
        set: function (a) {
            this._view = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "hw", {
        get: function () {
            return this.ht;
        },
        set: function (a) {
            var b = this.ht;
            this.ht = a;
            if (!b.equals1(this.ht)) {
                this.e7(b, this.ht);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "hv", {
        get: function () {
            return this.hs;
        },
        set: function (a) {
            this.hs = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "hu", {
        get: function () {
            return this.hr;
        },
        set: function (a) {
            this.hr = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "b5", {
        get: function () {
            return this.bi;
        },
        set: function (a) {
            var b = this.bi;
            this.bi = a;
            this.e5("PixelScalingRatio", b, this.bi);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamBulletGraph.prototype, "bm", {
        get: function () {
            return this.bh;
        },
        set: function (a) {
            var b = this.bh;
            this.bh = a;
            this.e5("ActualPixelScalingRatio", b, this.bh);
        },
        enumerable: true,
        configurable: true
    });
    XamBulletGraph.prototype.a5 = function () {
        return !isNaN_(this.bl) && !isNaN_(this.bk) && !this.hw.isEmpty && this.view.s();
    };
    XamBulletGraph.prototype.ew = function () {
        if (!this.a5()) {
            return;
        }
        var a = this.cc();
        this.aq = new LinearGraphScaler(this.bl, this.bk, a, a + this.cb(), this.a4);
        if (this.a3) {
            if (this.a2) {
                if (this.av.g) {
                    this.av.t();
                }
                var b = this.an;
                this.an = this.al;
                this.al = b;
            }
            else {
                var c = this.an;
                this.an = this.am;
                this.am = c;
            }
        }
        else if (this.a2) {
            this.al.d(this.cq, this.an, this.am);
            this.fj(this.al);
            this.fl(this.al);
            this.fm(this.al);
            this.fo(this.al);
        }
        if (this.a3) {
            this.e9();
            this.fi();
            this.fb();
            this.fc();
            this.fa();
            this.e8();
        }
        if (this.a3 && this.a7) {
            this.fq();
            this.al.d(this.cq, this.an, this.am);
            this.fj(this.al);
            this.fl(this.al);
            this.fm(this.al);
            this.fo(this.al);
            this.fn(this.al);
            this.fk(this.al);
        }
        else {
            if (this.a3) {
                this.fj(this.am);
                this.fl(this.am);
                this.fm(this.am);
                this.fo(this.am);
                this.fn(this.am);
                this.fk(this.am);
            }
        }
        this.a3 = false;
        this.view.as();
    };
    XamBulletGraph.prototype.fa = function () {
        var a = this.am;
        var b = a.c;
        var c = this.aq;
        var d = this.bz;
        var e = this.hv;
        if (isNaN_(d)) {
            d = 3;
        }
        b.u = this.cd;
        b.r = this.ca;
        b.s = 0;
        b.t = 1;
        b.m.clear();
        for (var f = 0; f < this.ranges.count; f++) {
            var g = this.ranges._inner[f];
            if (g.j <= this.bl || g.o > this.bk) {
                continue;
            }
            var h = g.o;
            var i = g.j;
            if (h < this.bl) {
                h = this.bl;
            }
            if (i > this.bk) {
                i = this.bk;
            }
            var j = new LinearGraphRectFrame();
            j.i = g.an != null ? g.an : this.hh(f, this.ah);
            j.j = g.ao != null ? g.ao : this.hh(f, this.ai);
            j.h = g.p;
            j.g = c.i(h);
            j.d = c.i(i);
            j.e = g.l;
            j.b = g.k;
            j.f = g.n;
            j.c = g.m;
            if (isNaN_(j.e)) {
                j.e = this.b6;
            }
            j.b = g.k;
            if (isNaN_(j.b)) {
                j.b = this.b6;
            }
            j.f = g.n;
            if (isNaN_(j.f)) {
                j.f = this.b7;
            }
            j.c = g.m;
            if (isNaN_(j.c)) {
                j.c = this.b7;
            }
            b.m.add(j);
        }
        b.l.i = this.hj;
        b.l.j = this.hk;
        b.l.h = this.b8;
        b.l.g = c.i(this.bl);
        b.l.d = c.i(this.bk);
        b.l.e = this.b6;
        b.l.b = this.b6;
        b.l.f = this.b7;
        b.l.c = this.b7;
        b.ab = this.hg;
        b.ad = this.hn;
        b.x = this.cp;
        b.w = this.cn;
        b.v = this.cj;
        b.ac = this.hi;
        b.q = this.b4;
        b.p = this.b2;
        b.o = this.b0;
        var k = this.bs;
        if (isNaN_(k)) {
            k = (this.bk - this.bl) / 10;
        }
        if (k == 0) {
            k = this.bk - this.bl;
        }
        var l = new List$1(Number_$type, 0);
        var m = new List$1(Number_$type, 0);
        if (k > 0) {
            var n = this.bl + this.cl;
            var o = this.bk - this.cm;
            var p = 100000;
            var q = Math.abs(o - n) / p;
            if (k >= q) {
                for (var r = n; r <= o || this.a9(r, o, k); r = r + k) {
                    l.add(c.i(r));
                    for (var s = 0; s < d; s++) {
                        var t = (k / (d + 1)) * (s + 1);
                        if (t + r > o) {
                            continue;
                        }
                        m.add(c.i(t + r));
                    }
                }
            }
        }
        if (b.j.length != l.count || b.i.length != m.count) {
            b.j = new Array(l.count);
            b.i = new Array(m.count);
        }
        for (var u = 0; u < l.count; u++) {
            b.j[u] = l._inner[u];
        }
        for (var v = 0; v < m.count; v++) {
            b.i[v] = m._inner[v];
        }
    };
    XamBulletGraph.prototype.hx = function () {
        var a = this.bs;
        var b = this.bu;
        if (isNaN_(a)) {
            a = (this.bk - this.bl) / 10;
        }
        if (isNaN_(b)) {
            b = a;
        }
        if (b == 0) {
            b = this.bk - this.bl;
        }
        var c = new List$1(Number_$type, 0);
        if (b > 0) {
            var d = this.bv + this.bl;
            var e = this.bk - this.bw;
            var f = 100000;
            var g = Math.abs(e - d) / f;
            if (b >= g) {
                for (var h = d; h <= e || this.a9(h, e, a); h += b) {
                    c.add(h);
                }
            }
        }
        var i = new Array(c.count);
        var j = new Array(c.count);
        var _loop_1 = function (k) {
            var l = c._inner[k];
            if (this_1.formatLabel == null && this_1.aj == null) {
                l = (Math.round(l * 100) / 100);
            }
            var m = l.toString();
            if (this_1.aj != null) {
                m = this_1.aj.i(l);
            }
            var n = new FormatLinearGraphLabelEventArgs();
            n.value = l;
            n.label = m;
            if (this_1.formatLabel != null) {
                this_1.formatLabel(this_1, n);
            }
            m = n.label;
            var o = this_1.view.cr(((function () {
                var $ret = new TextBlock();
                $ret.ak = m;
                return $ret;
            })()));
            i[k] = o.width;
            j[k] = o.height;
        };
        var this_1 = this;
        for (var k = 0; k < c.count; k++) {
            _loop_1(k);
        }
        var p = 0;
        var q = 0;
        var r = 1 - this.ca + this.cd;
        if (this.ar == 0) {
            for (var s = 0; s < j.length; s++) {
                q = Math.max(q, j[s]);
            }
            for (var t = 0; t < i.length; t++) {
                p += i[t];
            }
            if (i.length > 0) {
                p += i[0] / 2;
            }
            if (i.length > 1) {
                p += i[i.length - 1] / 2;
            }
            if (i.length > 0) {
                p += (i.length - 1) * 5;
            }
            if (r > 0) {
                p = p / Math.abs(1 - r);
            }
        }
        else {
            for (var u = 0; u < i.length; u++) {
                p = Math.max(p, i[u]);
            }
            for (var v = 0; v < j.length; v++) {
                q += j[v];
            }
            if (j.length > 0) {
                q -= j[0] / 2;
            }
            if (j.length > 1) {
                q -= j[j.length - 1] / 2;
            }
            if (r > 0) {
                q = q / Math.abs(1 - r);
            }
            if (j.length > 0) {
                q += (j.length - 1) * 5;
            }
        }
        return new Size(1, p, q);
    };
    XamBulletGraph.prototype.e9 = function () {
        var a = this.am;
        var b = a.c;
        var c = this.aq;
        var d = this.bs;
        var e = this.bu;
        var f = this.bz;
        if (isNaN_(d)) {
            d = (this.bk - this.bl) / 10;
        }
        if (isNaN_(e)) {
            e = d;
        }
        if (e == 0) {
            e = this.bk - this.bl;
        }
        var g = new List$1(Tuple$2.$.specialize(Number_$type, Number_$type), 0);
        if (e > 0) {
            var h = this.bv + this.bl;
            var i = this.bk - this.bw;
            var j = 100000;
            var k = Math.abs(i - h) / j;
            if (e >= k) {
                for (var l = h; l <= i || this.a9(l, i, e); l = l + e) {
                    g.add(new Tuple$2(Number_$type, Number_$type, l, c.i(l)));
                }
            }
        }
        if (b.d.length != g.count) {
            b.e = new Array(g.count);
            b.d = new Array(g.count);
            b.f = new Array(g.count);
            b.c = new Array(g.count);
            b.g = new Array(g.count);
            b.h = new Array(g.count);
        }
        b.n = this.bt;
        var m = new FormatLinearGraphLabelEventArgs();
        m.actualMinimumValue = this.bl;
        m.actualMaximumValue = this.bk;
        var n = new AlignLinearGraphLabelEventArgs();
        n.actualMinimumValue = this.bl;
        n.actualMaximumValue = this.bk;
        var _loop_2 = function (o) {
            var p = g._inner[o].c;
            if (this_2.formatLabel == null) {
                p = (Math.round(p * 100) / 100);
            }
            var q = (p).toString();
            if (this_2.aj != null) {
                q = this_2.aj.i(p);
            }
            m.value = p;
            n.value = p;
            m.label = q;
            if (this_2.formatLabel != null) {
                this_2.formatLabel(this_2, m);
            }
            q = m.label;
            n.label = q;
            var r = this_2.view.cr(((function () {
                var $ret = new TextBlock();
                $ret.ak = q;
                return $ret;
            })()));
            n.width = r.width;
            n.height = r.height;
            if (this_2.ar == 0) {
                n.offsetX = -1 * (r.width / 2);
                n.offsetY = -1 * (r.height);
            }
            else {
                n.offsetX = -1 * r.width;
                n.offsetY = -1 * (r.height / 2);
            }
            if (this_2.alignLabel != null) {
                this_2.alignLabel(this_2, n);
            }
            b.f[o] = n.width;
            b.c[o] = n.height;
            b.g[o] = n.offsetX;
            ;
            b.h[o] = n.offsetY;
            b.d[o] = q;
            b.e[o] = g._inner[o].d;
        };
        var this_2 = this;
        for (var o = 0; o < g.count; o++) {
            _loop_2(o);
        }
    };
    XamBulletGraph.prototype.a9 = function (a, b, c) {
        var d = c / 10000;
        if (isNaN_(d)) {
            d = 1E-05;
        }
        var e = Math.abs(a - b);
        if (e < d) {
            return true;
        }
        return false;
    };
    XamBulletGraph.prototype.e8 = function () {
        var a = this.am;
        var b = a.a;
        b.e = this.he;
        b.f = this.hf;
        b.c = this.bp;
        b.a = this.bn;
        b.b = this.bo;
    };
    XamBulletGraph.prototype.fb = function () {
        var a = this.am;
        var b = a.b;
        var c = this.aq;
        b.e = this.cg;
        b.b = this.cg;
        b.f = this.ch;
        b.c = this.ch;
        b.i = this.hl;
        b.j = this.hm;
        b.h = this.ci;
        if (isNaN_(this.ce)) {
            return;
        }
        var d = c.i(this.ce);
        var e = (this.cf / 2);
        b.g = d - e;
        b.d = d + e;
    };
    XamBulletGraph.prototype.fc = function () {
        var a = this.am.c;
        var b = this.aq;
        var c = this.cr;
        if (isNaN_(c)) {
            return;
        }
        var d = this.bl;
        if (isNaN_(d)) {
            d = this.bl;
        }
        var e = this.cr;
        var f = new LinearGraphRectFrame();
        f.i = this.ho;
        f.j = this.hp;
        f.h = this.cu;
        f.g = b.i(d);
        f.d = b.i(e);
        f.e = this.cs;
        f.b = this.cs;
        f.f = this.ct;
        f.c = this.ct;
        a.af = f;
    };
    XamBulletGraph.prototype.hh = function (a, b) {
        if (b != null && b.count > 0) {
            return b.item(a % b.count);
        }
        else {
            return null;
        }
    };
    XamBulletGraph.prototype.fn = function (a) {
        var b = this.hv;
        var c = a.c;
        var d = this.a0;
        var e = c.j;
        var f = c.w;
        var g = c.v;
        var h = c.ad;
        var i = c.x;
        var j = this.ay;
        var k = c.i;
        var l = c.p;
        var m = c.o;
        var n = c.ac;
        var o = c.q;
        d.f = true;
        for (var p = 0; p < this.bc.count; p++) {
            d.n(this.bc._inner[p]);
        }
        this.bc.clear();
        var q = this.b9();
        var r = this.cw();
        var _loop_3 = function (s) {
            var t = void 0, u = void 0, v, w;
            if (this_3.ar == 1) {
                t = b.left + q * f;
                u = r - e[s];
                v = b.left + q * g;
                w = u;
            }
            else {
                t = b.left + e[s];
                u = q * (1 - f);
                v = t;
                w = q * (1 - g);
            }
            var x = d.a();
            var y = new PathGeometry();
            var z = new PathFigure();
            z._startPoint = { $type: Point_$type, x: t, y: u };
            z._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: v, y: w };
                return $ret;
            })()));
            y.c.add(z);
            x.ak = y;
            x._stroke = h;
            x.ac = i;
            this_3.bc.add(x);
        };
        var this_3 = this;
        for (var s = 0; s < e.length; s++) {
            _loop_3(s);
        }
        var _loop_4 = function (aa) {
            var ab = void 0, ac = void 0, ad, ae;
            if (this_4.ar == 1) {
                ab = b.left + q * l;
                ac = r - k[aa];
                ad = b.left + q * m;
                ae = ac;
            }
            else {
                ab = k[aa];
                ac = q * (1 - l);
                ad = ab;
                ae = q * (1 - m);
            }
            var af = d.a();
            var ag = new PathGeometry();
            var ah = new PathFigure();
            ah._startPoint = { $type: Point_$type, x: ab, y: ac };
            ah._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: ad, y: ae };
                return $ret;
            })()));
            ag.c.add(ah);
            af.ak = ag;
            af._stroke = n;
            af.ac = o;
            this_4.bc.add(af);
        };
        var this_4 = this;
        for (var aa = 0; aa < k.length; aa++) {
            _loop_4(aa);
        }
        d.f = false;
    };
    XamBulletGraph.prototype.fk = function (a) {
        var b = this.hv;
        var c = a.c;
        var d = c.e;
        var e = c.d;
        var f = c.g;
        var g = c.h;
        var h = c.f;
        var i = c.c;
        var j = c.n;
        var k = this.ax;
        k.f = true;
        for (var l = 0; l < this.ba.count; l++) {
            k.n(this.ba._inner[l]);
        }
        this.ba.clear();
        var m = c.ab;
        var n = this.cv();
        var o = this.cw();
        for (var p = 0; p < e.length; p++) {
            var q = void 0, r = void 0;
            if (this.ar == 1) {
                q = b.left + n * j;
                r = b.top + o - d[p];
            }
            else {
                q = b.left + d[p];
                r = b.top + n * (1 - j);
            }
            var s = k.a();
            s.ak = e[p];
            this.view.bq(s, m);
            var t = h[p];
            var u = i[p];
            var v = f[p];
            var w = g[p];
            this.view.bh(s, q + v, r + w);
            this.ba.add(s);
        }
        k.f = false;
    };
    XamBulletGraph.prototype.fl = function (a) {
        var b = a.c;
        var c = this.az;
        c.f = true;
        for (var d = 0; d < this.bb.count; d++) {
            c.n(this.bb._inner[d]);
        }
        this.bb.clear();
        var e = this.b9();
        var f = this.cw();
        var g = this.hq();
        var h = this.view.cm();
        h.ak = b.ae(g, e, f, this.ar);
        for (var i = 0; i < b.m.count; i++) {
            var j = b.m._inner[i];
            var k = c.a();
            k.ak = j.k(g, e, f, this.ar);
            k._fill = j.i;
            k._stroke = j.j;
            k.ac = j.h;
            this.bb.add(k);
        }
        this.view.bp(this.bb);
        c.f = false;
        var l = this.view.cl();
        l.ak = b.l.k(g, e, f, this.ar);
        l._fill = b.l.i;
        l._stroke = b.l.j;
        l.ac = b.l.h;
    };
    XamBulletGraph.prototype.fj = function (a) {
        var b = this.hu;
        var c = this.view.ck();
        var d = a.a;
        var e = this.ar == 0 ? b.height : b.width;
        var f = this.ar == 0 ? b.width : b.height;
        var g = d.g(e, f, this.ar);
        c.ak = g;
        c._fill = d.e;
        c._stroke = d.f;
        c.ac = d.c;
    };
    XamBulletGraph.prototype.fm = function (a) {
        var b = this.view.cn();
        if (isNaN_(this.ce) || this.ce < this.bl || this.ce > this.bk) {
            b.ak = null;
            return;
        }
        var c = a.b;
        var d = this.b9();
        var e = this.cw();
        var f = this.hq();
        var g = c.k(f, d, e, this.ar);
        b.ak = g;
        b._fill = c.i;
        b._stroke = c.j;
        b.ac = c.h;
    };
    XamBulletGraph.prototype.fo = function (a) {
        var b = this.view.co();
        var c = this.cr;
        if (c <= this.bl || c > this.bk || isNaN_(c)) {
            b.ak = null;
            return;
        }
        var d = a.c;
        var e = this.b9();
        var f = this.cw();
        var g = this.hq();
        var h = d.af;
        b.ak = h.k(g, e, f, this.ar);
        b._fill = h.i;
        b._stroke = h.j;
        b.ac = h.h;
    };
    XamBulletGraph.prototype.e7 = function (a, b) {
        this.a3 = true;
        this.view.bo();
    };
    XamBulletGraph.prototype.e2 = function (a, b) {
        this.a3 = true;
        this.view.bo();
    };
    XamBulletGraph.prototype.b9 = function () {
        if (this.ar == 0) {
            return this.a6 ? this.hw.height : this.hv.height;
        }
        return this.a6 ? this.hw.width : this.hv.width;
    };
    XamBulletGraph.prototype.cb = function () {
        if (this.ar == 0) {
            return this.hw.width * (this.ca - this.cd);
        }
        return this.hw.height * (this.ca - this.cd);
    };
    XamBulletGraph.prototype.cv = function () {
        if (this.ar == 0) {
            return this.hw.height;
        }
        return this.hw.width;
    };
    XamBulletGraph.prototype.cw = function () {
        if (this.ar == 0) {
            return this.hw.width;
        }
        return this.hw.height;
    };
    XamBulletGraph.prototype.cc = function () {
        var a = this.cd;
        if (this.ar == 0) {
            if (this.a4) {
                a = 1 - this.ca;
            }
            return this.hw.left + this.hw.width * a;
        }
        if (this.a4) {
            a = 1 - this.ca;
        }
        return this.hw.top + this.hw.height * a;
    };
    XamBulletGraph.prototype.hq = function () {
        var a = this.hv.left;
        if (this.a6) {
            a = 0;
        }
        var b = this.cd;
        if (this.ar == 0) {
            if (this.a4) {
                b = 1 - this.ca;
            }
            return { $type: Point_$type, x: a + this.hv.width * b, y: this.hv.top };
        }
        if (!this.a4) {
            b = 1 - this.ca;
        }
        return { $type: Point_$type, x: a, y: this.hv.top + this.hv.height * b };
    };
    XamBulletGraph.prototype.e5 = function (a, b, c) {
        switch (a) {
            case XamBulletGraph.$$p[48]:
            case XamBulletGraph.$$p[33]:
            case XamBulletGraph.$$p[37]:
            case XamBulletGraph.$$p[0]:
            case XamBulletGraph.$$p[3]:
            case XamBulletGraph.$$p[52]:
            case XamBulletGraph.$$p[40]:
            case XamBulletGraph.$$p[18]:
                this.view.a5(a, b, c);
                break;
            case XamBulletGraph.$$p[24]:
                this.view.ba(b, c);
                break;
            case XamBulletGraph.$$p[27]:
                this.view.bb(b, c);
                break;
        }
        switch (a) {
            case XamBulletGraph.$$p[10]:
            case XamBulletGraph.$$p[11]:
                if (this.dd != null) {
                    this.aj = new BindingFormatter();
                    this.aj.j = this.dd;
                    this.aj.d = this.ag;
                }
                else {
                    this.aj = null;
                }
                this.a3 = true;
                this.view.bo();
                break;
            case XamBulletGraph.$$p[47]:
                this.av.r = this.cy;
                this.view.bo();
                break;
            case "TransitionProgress":
                if (this.cq >= 1) {
                    this.av.w();
                    var d = this.am;
                    this.am = this.an;
                    this.an = d;
                    this.e9();
                    this.fb();
                    this.fc();
                    this.fa();
                    this.e8();
                    this.fj(this.am);
                    this.fl(this.am);
                    this.fm(this.am);
                    this.fo(this.am);
                    this.fn(this.am);
                    this.fk(this.am);
                }
                this.al.d(this.cq, this.an, this.am);
                this.fj(this.al);
                this.fl(this.al);
                this.fm(this.al);
                this.fo(this.al);
                this.fn(this.al);
                this.fk(this.al);
                this.view.as();
                break;
            case XamBulletGraph.$$p[53]:
            case XamBulletGraph.$$p[49]:
            case XamBulletGraph.$$p[51]:
            case XamBulletGraph.$$p[48]:
            case XamBulletGraph.$$p[52]:
            case XamBulletGraph.$$p[54]:
            case XamBulletGraph.$$p[33]:
            case XamBulletGraph.$$p[37]:
            case XamBulletGraph.$$p[39]:
            case XamBulletGraph.$$p[32]:
            case XamBulletGraph.$$p[34]:
            case XamBulletGraph.$$p[36]:
            case XamBulletGraph.$$p[0]:
            case XamBulletGraph.$$p[3]:
            case XamBulletGraph.$$p[40]:
            case XamBulletGraph.$$p[18]:
            case XamBulletGraph.$$p[24]:
            case XamBulletGraph.$$p[27]:
            case XamBulletGraph.$$p[16]:
            case XamBulletGraph.$$p[38]:
            case XamBulletGraph.$$p[35]:
            case XamBulletGraph.$$p[25]:
            case XamBulletGraph.$$p[26]:
            case XamBulletGraph.$$p[4]:
            case XamBulletGraph.$$p[1]:
            case XamBulletGraph.$$p[2]:
            case XamBulletGraph.$$p[7]:
            case XamBulletGraph.$$p[12]:
            case XamBulletGraph.$$p[9]:
            case XamBulletGraph.$$p[13]:
            case XamBulletGraph.$$p[14]:
            case XamBulletGraph.$$p[42]:
            case XamBulletGraph.$$p[43]:
            case XamBulletGraph.$$p[44]:
            case XamBulletGraph.$$p[41]:
            case XamBulletGraph.$$p[45]:
            case XamBulletGraph.$$p[21]:
            case XamBulletGraph.$$p[20]:
            case XamBulletGraph.$$p[19]:
            case XamBulletGraph.$$p[22]:
            case "ScaleBackgroundBrush":
            case "ScaleBackgroundOutline":
            case "ScaleBackgroundThickness":
                this.a3 = true;
                this.view.bo();
                break;
            case XamBulletGraph.$$p[28]:
                var e = b;
                var f = c;
                if (e != null) {
                    var g = e;
                    g.collectionChanged = delegateRemove(g.collectionChanged, runOn(this, this.fg));
                }
                if (f != null) {
                    var h = f;
                    h.collectionChanged = delegateCombine(h.collectionChanged, runOn(this, this.fg));
                }
                this.a3 = true;
                this.view.bo();
                break;
            case XamBulletGraph.$$p[23]:
            case XamBulletGraph.$$p[8]:
            case XamBulletGraph.$$p[17]:
            case XamBulletGraph.$$p[15]:
            case XamBulletGraph.$$p[29]:
            case XamBulletGraph.$$p[30]:
                this.bl = Math.min(this.by, this.bx);
                this.bk = Math.max(this.by, this.bx);
                var i = this.cc();
                this.aq = new LinearGraphScaler(this.bl, this.bk, i, i + this.cb(), this.a4);
                this.a3 = true;
                this.view.bo();
                break;
            case XamBulletGraph.$$p[5]:
            case XamBulletGraph.$$p[6]:
                this.view.by();
                this.a3 = true;
                this.view.bo();
                break;
            case "PixelScalingRatio":
                if (isNaN_(DeviceUtils.a(this.b5))) {
                    this.bm = 1;
                }
                else {
                    this.bm = DeviceUtils.a(this.b5);
                }
                break;
            case "ActualPixelScalingRatio":
                this.view.bf();
                break;
        }
        this.e6(a);
    };
    XamBulletGraph.prototype.fg = function (a, b) {
        var e_1, _a, e_2, _b;
        if (b.oldItems != null) {
            try {
                for (var _c = __values(fromEn(b.oldItems)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var c = _d.value;
                    c.propertyChanged = delegateRemove(c.propertyChanged, runOn(this, this.ff));
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return))
                        _a.call(_c);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        }
        if (b.newItems != null) {
            try {
                for (var _e = __values(fromEn(b.newItems)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var d = _f.value;
                    d.propertyChanged = delegateCombine(d.propertyChanged, runOn(this, this.ff));
                }
            }
            catch (e_2_1) {
                e_2 = { error: e_2_1 };
            }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return))
                        _b.call(_e);
                }
                finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
        }
        this.a3 = true;
        this.view.bo();
    };
    XamBulletGraph.prototype.ff = function (a, b) {
        this.a3 = true;
        this.view.bo();
    };
    XamBulletGraph.prototype.refresh = function () {
        this.a3 = true;
        this.view.bo();
    };
    XamBulletGraph.prototype.aw = function () {
        return FontUtil.toFontInfo(this.view.ag, this.c7);
    };
    XamBulletGraph.$t = markType(XamBulletGraph, 'XamBulletGraph', Control.$, [INotifyPropertyChanged_$type]);
    XamBulletGraph.gl = DependencyProperty.i("ScaleBackgroundBrush", Brush.$, XamBulletGraph.$, new PropertyMetadata(2, null, function (a, b) { return a.e5("ScaleBackgroundBrush", b.oldValue, b.newValue); }));
    XamBulletGraph.gm = DependencyProperty.i("ScaleBackgroundOutline", Brush.$, XamBulletGraph.$, new PropertyMetadata(2, null, function (a, b) { return a.e5("ScaleBackgroundOutline", b.oldValue, b.newValue); }));
    XamBulletGraph.gn = DependencyProperty.i("ScaleBackgroundThickness", Number_$type, XamBulletGraph.$, new PropertyMetadata(2, 1, function (a, b) { return a.e5("ScaleBackgroundThickness", b.oldValue, b.newValue); }));
    XamBulletGraph.$$p = markDep(DependencyProperty, PropertyMetadata, XamBulletGraph, 'e5', ['BackingBrush:he:fs', [Brush.$, null], 'BackingInnerExtent:bn:ft', [1, 0], 'BackingOuterExtent:bo:fu', [1, 1], 'BackingOutline:hf:fv', [Brush.$, null], 'BackingStrokeThickness:bp:fw', [1, 2], 'FontBrush:hg:fx', [Brush.$, null], 'Font:c7:fy', [2, null], 'Interval:bs:fz', [1, NaN], 'IsScaleInverted:a4:f0', [0, false], 'LabelExtent:bt:f1', [1, 0], 'LabelFormat:dd:f2', [2, null], 'LabelFormatSpecifiers:ag:f3', [Array_$type, null], 'LabelInterval:bu:f4', [1, NaN], 'LabelsPostInitial:bv:f5', [1, 0], 'LabelsPreTerminal:bw:f6', [1, 0], 'MaximumValue:bx:f7', [1, 100], 'MergeViewPorts:a6:f8', [0, false], 'MinimumValue:by:f9', [1, 0], 'MinorTickBrush:hi:ga', [Brush.$, null], 'MinorTickCount:bz:gb', [1, 3], 'MinorTickEndExtent:b0:gc', [1, 0.2], 'MinorTickStartExtent:b2:gd', [1, 0.1], 'MinorTickStrokeThickness:b4:ge', [1, 1], 'Orientation:ar:gf', [LinearScaleOrientation_$type, enumGetBox(LinearScaleOrientation_$type, 0)], 'RangeBrushes:ah:gg', [BrushCollection.$, null], 'RangeInnerExtent:b6:gh', [1, 0.2], 'RangeOuterExtent:b7:gi', [1, 0.95], 'RangeOutlines:ai:gj', [BrushCollection.$, null], 'Ranges::gk', [LinearGraphRangeCollection.$, null], 'ScaleEndExtent:ca:go', [1, 0.95], 'ScaleStartExtent:cd:gp', [1, 0.05], 'ShowToolTipTimeout:cx:gq', [1, 500], 'TargetValueBreadth:cf:gr', [1, 3], 'TargetValueBrush:hl:gs', [Brush.$, null], 'TargetValueInnerExtent:cg:gt', [1, 0.3], 'TargetValueName:d8:gu', [2, null], 'TargetValueOuterExtent:ch:gv', [1, 0.85], 'TargetValueOutline:hm:gw', [Brush.$, null], 'TargetValue:ce:gx', [1, NaN], 'TargetValueStrokeThickness:ci:gy', [1, 1], 'TickBrush:hn:gz', [Brush.$, null], 'TickEndExtent:cj:g0', [1, 0.2], 'TicksPostInitial:cl:g1', [1, 0], 'TicksPreTerminal:cm:g2', [1, 0], 'TickStartExtent:cn:g3', [1, 0.06], 'TickStrokeThickness:cp:g4', [1, 2], 'ToolTip::g5', [4, null], 'TransitionDuration:cy:g6', [1, 0], 'ValueBrush:ho:g7', [Brush.$, null], 'ValueInnerExtent:cs:g8', [1, 0.5], 'ValueName:ep:g9', [2, null], 'ValueOuterExtent:ct:ha', [1, 0.65], 'ValueOutline:hp:hb', [Brush.$, null], 'Value:cr:hc', [1, NaN], 'ValueStrokeThickness:cu:hd', [1, 1]]);
    return XamBulletGraph;
}(Control));
/**
 * @hidden
 */
var XamBulletGraphView = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(XamBulletGraphView, _super);
    function XamBulletGraphView(a) {
        var _this = _super.call(this) || this;
        _this.ao = 0;
        _this.an = 0;
        _this.ap = 0;
        _this.m = null;
        _this.i = null;
        _this.ai = null;
        _this.p = null;
        _this.ag = null;
        _this.aa = null;
        _this.z = null;
        _this.y = null;
        _this.ab = null;
        _this.cj = null;
        _this.ci = null;
        _this.ch = null;
        _this.cf = null;
        _this.cg = null;
        _this.b7 = null;
        _this.b8 = null;
        _this.b4 = null;
        _this.b5 = null;
        _this.b9 = null;
        _this.ca = null;
        _this.b6 = null;
        _this.c = null;
        _this.d = null;
        _this.e = null;
        _this.f = null;
        _this.cb = null;
        _this.cc = null;
        _this.q = false;
        _this.v = null;
        _this.a = ["value", "targetvalue", "backing", "scale", "tick", "minortick", "label"];
        _this.u = false;
        _this.t = false;
        _this.ah = null;
        _this.k = null;
        _this.aj = 0;
        _this.al = 0;
        _this.aq = null;
        _this.am = -1;
        _this.cd = null;
        _this.ak = 0;
        _this.x = null;
        _this.b3 = ((function () {
            var $ret = new Brush();
            $ret.fill = "black";
            return $ret;
        })());
        _this.r = false;
        _this.n = null;
        _this.b2 = null;
        _this.ac = 0;
        _this.m = a;
        _this.v = new Dictionary$2(String_$type, Dictionary$2.$.specialize(String_$type, Brush.$), 0);
        _this.ci = new Path();
        _this.cj = new Path();
        _this.ch = new Path();
        _this.cf = new Path();
        _this.cg = new Path();
        _this.aa = new List$1(Path.$, 0);
        _this.z = new List$1(Path.$, 0);
        _this.y = new List$1(TextBlock.$, 0);
        _this.ab = new List$1(TextBlock.$, 0);
        return _this;
    }
    XamBulletGraphView.prototype.a4 = function () {
        this.a0();
        if (this.i != null) {
            this.i.ap(this.ag.rootWrapper, "");
        }
    };
    XamBulletGraphView.prototype.a8 = function () {
        if (this.i != null) {
            this.i.bb(this.ag.rootWrapper, "");
        }
    };
    XamBulletGraphView.prototype.a9 = function () {
        this.k = new LinearGraphTooltipDataContext();
        this.ak = this.m.cx;
        this.a0();
    };
    XamBulletGraphView.prototype.a0 = function () {
        var a = this.m.b5;
        var b = this.m.bm;
        if (!isNaN_(a) && a != 0) {
            return;
        }
        if (window.devicePixelRatio != undefined && window.devicePixelRatio != b) {
            this.m.bm = window.devicePixelRatio;
        }
    };
    XamBulletGraphView.prototype.s = function () {
        return true;
    };
    XamBulletGraphView.prototype.cn = function () {
        return this.ci;
    };
    XamBulletGraphView.prototype.co = function () {
        return this.cj;
    };
    XamBulletGraphView.prototype.cm = function () {
        return this.ch;
    };
    XamBulletGraphView.prototype.ck = function () {
        return this.cf;
    };
    XamBulletGraphView.prototype.cl = function () {
        return this.cg;
    };
    XamBulletGraphView.prototype.ay = function () {
        this.q = true;
        var a = ["#778899", "black", "#EBEDEF", "#617583", "#617583", "rgba(100,107,114,.74)", "rgba(100,107,114,.74)"];
        var b = ["#778899", "black", "#B2B9C0", "#B2B9C0", null, null, null];
        var c = ((function () {
            var $ret = new List$1(Array_$type, 0);
            $ret.add(a);
            $ret.add(b);
            return $ret;
        })());
        this.v.clear();
        var d = this.a.length;
        var _loop_5 = function (e) {
            var f = this_5.a[e];
            var g = "ui-bulletgraph-" + f;
            var h = "ui-bulletgraph-" + f + "-fill";
            var i = "ui-bulletgraph-" + f + "-outline";
            var j;
            if (!((function () { var k = XamBulletGraphView.w.tryGetValue(h, j); j = k.p1; return k.ret; })())) {
                j = BrushUtil.j(h, g, "background-color", this_5.ag, a[e]);
                XamBulletGraphView.w.addItem(h, j);
            }
            var k;
            if (!((function () { var l = XamBulletGraphView.w.tryGetValue(i, k); k = l.p1; return l.ret; })())) {
                k = BrushUtil.j(i, g, "border-top-color", this_5.ag, b[e]);
                XamBulletGraphView.w.addItem(i, k);
            }
            var l = new Dictionary$2(String_$type, Brush.$, 0);
            l.item("fill", j);
            l.item("outline", k);
            this_5.v.item(this_5.a[e], l);
        };
        var this_5 = this;
        for (var e = 0; e < d; e++) {
            _loop_5(e);
        }
        this.bx();
        if (XamBulletGraphView.g == null || XamBulletGraphView.h == null) {
            var m = BrushUtil.f("ui-bulletgraph-range-fill-palette-", "ui-bulletgraph-range-outline-palette-", "ui-bulletgraph-range-palette-", this.ag, XamBulletGraphView.g, XamBulletGraphView.h, ["#216E99", "#216E99", "#44acd6", "#44acd6", "#cecece", "#cecece"]);
            XamBulletGraphView.g = m.p4;
            XamBulletGraphView.h = m.p5;
        }
        this.c = XamBulletGraphView.g;
        this.d = XamBulletGraphView.h;
        if (this.e == null) {
            this.m.ah = this.c;
        }
        if (this.f == null) {
            this.m.ai = this.d;
        }
        this.q = false;
    };
    XamBulletGraphView.prototype.bx = function () {
        this.q = true;
        var a = this.a.length;
        for (var b = 0; b < a; b++) {
            var c = this.a[b];
            this.bw(c, this.v.item(c));
        }
        this.q = false;
    };
    XamBulletGraphView.prototype.bw = function (a, b) {
        var c = b.item("fill");
        var d = b.item("outline");
        switch (a) {
            case "targetvalue":
                if (this.b7 == null) {
                    this.m.hl = c;
                }
                if (this.b8 == null) {
                    this.m.hm = d;
                }
                break;
            case "value":
                if (this.cb == null) {
                    this.m.ho = c;
                }
                if (this.cc == null) {
                    this.m.hp = d;
                }
                break;
            case "backing":
                if (this.b4 == null) {
                    this.m.he = c;
                }
                if (this.b5 == null) {
                    this.m.hf = d;
                }
                break;
            case "tick":
                if (this.ca == null) {
                    this.m.hn = c;
                }
                break;
            case "minortick":
                if (this.b6 == null) {
                    this.m.hi = c;
                }
                break;
            case "label":
                this.b3 = c;
                break;
        }
    };
    XamBulletGraphView.prototype.a5 = function (a, b, c) {
        var d = b;
        var e = c;
        if (!this.q) {
            switch (a) {
                case XamBulletGraph.$$p[33]:
                    this.b7 = e;
                    break;
                case XamBulletGraph.$$p[37]:
                    this.b8 = e;
                    break;
                case XamBulletGraph.$$p[0]:
                    this.b4 = e;
                    break;
                case XamBulletGraph.$$p[3]:
                    this.b5 = e;
                    break;
                case XamBulletGraph.$$p[48]:
                    this.cb = e;
                    break;
                case XamBulletGraph.$$p[52]:
                    this.cc = e;
                    break;
                case XamBulletGraph.$$p[40]:
                    this.ca = e;
                    break;
                case XamBulletGraph.$$p[18]:
                    this.b6 = e;
                    break;
            }
            if (e == null) {
                this.bx();
            }
        }
    };
    XamBulletGraphView.prototype.ba = function (a, b) {
        if (!this.q) {
            this.e = b;
            if (this.e == null) {
                this.m.ah = this.c;
            }
        }
    };
    XamBulletGraphView.prototype.bb = function (a, b) {
        if (!this.q) {
            this.f = b;
            if (this.f == null) {
                this.m.ai = this.d;
            }
        }
    };
    XamBulletGraphView.prototype.b = function (a, b) {
        this.ag.startCSSQuery();
        for (var c = 0; c < b.length; c++) {
            b[c] = this.ag.getCssDefaultPropertyValue(a, b[c]);
        }
        this.ag.endCSSQuery();
        return b;
    };
    XamBulletGraphView.prototype.bs = function () {
        this.ay();
        this.by();
        this.bo();
    };
    XamBulletGraphView.prototype.ce = function (a) {
        var b = CanvasGestureDOMEventProxy.cy(this.ag.rootWrapper);
        return { $type: Point_$type, x: a.x - b.left, y: a.y - b.top };
    };
    XamBulletGraphView.prototype.br = function (a, b, c, d) {
        this.cd = a;
        this.am = c;
        this.aq = d;
        this.bn();
        this.al = window.setTimeout(runOn(this, this.bz), this.ak);
        this.t = true;
    };
    XamBulletGraphView.prototype.az = function () {
        if (this.t) {
            window.clearTimeout(this.al);
            this.t = false;
        }
        if (this.u) {
            var a = this.m.toolTip;
            window.clearTimeout(this.aj);
            a.hide();
            this.u = false;
            this.k = null;
        }
        this.ak = this.m.cx;
    };
    XamBulletGraphView.prototype.bn = function () {
        if (this.t) {
            window.clearTimeout(this.al);
        }
        if (this.u) {
            var a = this.m.toolTip;
            window.clearTimeout(this.aj);
            a.hide();
            this.u = false;
            this.ak = intDivide(this.m.cx, 2);
        }
    };
    XamBulletGraphView.prototype.bz = function () {
        var _this = this;
        if (this.t) {
            window.clearTimeout(this.al);
            this.t = false;
        }
        var a = this.am;
        var b = this.aq;
        var c = this.cd;
        if (this.ag != null) {
            this.aj = this.ag.setTimeout(runOn(this, this.az), 10 * this.m.cx);
        }
        else {
            this.aj = window.setTimeout(runOn(this, this.az), 10 * this.m.cx);
        }
        var d = this.m.ranges._inner[a];
        if (this.ah != this.m.toolTip) {
            if (this.ah != null) {
                this.ah.remove();
            }
            this.ah = this.m.toolTip;
            this.ah.setStyleProperty("z-index", "10000");
            this.ah.setStyleProperty("position", "absolute");
            this.ag.append(this.ah);
        }
        this.k = this.j(b, a);
        var context_ = this.k;
        var tooltip_ = this.ah;
        var tooltipType_ = b;
        if (tooltip_.updateToolTip) {
            tooltip_.updateToolTip(context_, tooltipType_);
        }
        ;
        var e = this.ah.findByClass(".ui-tooltip-container");
        if (e != null && e.length > 0) {
            e[0].setAttribute("style", null);
        }
        var f = "ui-simple-default-tooltip-content";
        var g = this.ah.findByClass("." + f);
        if (g != null && g.length > 0) {
            var h = ["border-top-color", "border-top-width", "border-top-style", "border-top-left-radius", "background-color", "padding-top", "font-weight"];
            var i = ["border-color", "border-width", "border-style", "border-radius", "background-color", "padding", "font-weight"];
            var j = ((function () {
                var $ret = new List$1(String_$type, 0);
                $ret.add(_this.k.brush.color.colorString);
                $ret.add("2px");
                $ret.add("solid");
                $ret.add("4px");
                $ret.add("rgba(230, 230, 230, 0.74)");
                $ret.add("4px");
                $ret.add("bold");
                return $ret;
            })());
            var k = new Dictionary$2(String_$type, String_$type, 0);
            var l = new Array(h.length);
            arrayCopy1(h, 0, l, 0, h.length);
            this.b(f, l);
            for (var m = 0; m < l.length; m++) {
                this.ah.setStyleProperty(i[m], (l[m] == null) ? j._inner[m] : l[m]);
            }
        }
        this.ah.setStyleProperty("top", (c.y + 15).toString() + "px").setStyleProperty("left", (c.x + 15).toString() + "px");
        this.ah.show();
        this.u = true;
    };
    XamBulletGraphView.prototype.j = function (a, b) {
        var c = new LinearGraphTooltipDataContext();
        switch (a) {
            case "range":
                var d = this.m.ranges._inner[b];
                c.item = d;
                c.itemName = d.u;
                c.label = d.u + ": " + d.o.toString() + "-" + d.j.toString();
                var e = d.an;
                var f = d.ao;
                c.brush = e != null ? e : this.m.hh(b, this.c);
                c.outline = f != null ? f : this.m.hh(b, this.d);
                c.thickness = d.p;
                break;
            case "value":
                c.item = this.m.cr;
                c.itemName = this.m.ep;
                c.label = this.m.ep != null ? this.m.ep + ": " + this.m.cr.toString() : this.m.cr.toString();
                c.brush = this.m.ho;
                c.outline = this.m.hp;
                c.thickness = this.m.cu;
                break;
            case "targetvalue":
                c.item = this.m.ce;
                c.itemName = this.m.d8;
                c.label = this.m.d8 != null ? this.m.d8 + ": " + this.m.ce.toString() : this.m.ce.toString();
                c.brush = this.m.hl;
                c.outline = this.m.hm;
                c.thickness = this.m.ci;
                break;
        }
        return c;
    };
    XamBulletGraphView.prototype.a6 = function (a) {
        if (a == null) {
            this.ai = null;
            this.ag = null;
            this.ah = null;
            this.p = null;
            this.at();
            return;
        }
        var b = a;
        this.ag = b;
        this.m.av.u(this.ag);
        this.ag.rootWrapper.addClass("ui-bulletgraph-container");
        this.ap = (isNaN_(this.m.b5) ? this.m.bm : this.m.b5);
        var c = this.ap;
        var d = Math.round(b.rootWrapper.width());
        var e = Math.round(b.rootWrapper.height());
        var f = d * c;
        var g = e * c;
        this.ag.rootWrapper.setStyleProperty("position", "relative");
        var h = this.ag.createElement("canvas");
        h.setStyleProperty("position", "absolute");
        this.ag.append(h);
        this.ao = f;
        this.an = g;
        h.setAttribute("width", f.toString());
        h.setAttribute("height", g.toString());
        h.setStyleProperty("width", d.toString());
        h.setStyleProperty("height", e.toString());
        this.m.hw = new Rect(0, 0, 0, d, e);
        this.m.hu = new Rect(0, 0, 0, d, e);
        this.ai = h;
        var i = this.ag.get2DCanvasContext(this.ai);
        this.p = new RenderingContext(new CanvasViewRenderer(), i);
        this.ay();
        this.by();
        this.p.ac(this.n);
        this.at();
        if (TypeRegistrar.isRegistered("CanvasGestureDOMEventProxy")) {
            this.i = typeCast(EventProxy.$, TypeRegistrar.create("CanvasGestureDOMEventProxy", this.ag.rootWrapper, this.ag, false));
        }
        if (this.i != null) {
            var j = this.i;
            j.onMouseOver = delegateCombine(j.onMouseOver, runOn(this, this.av));
            var k = this.i;
            k.onMouseLeave = delegateCombine(k.onMouseLeave, runOn(this, this.au));
        }
        this.bm();
    };
    XamBulletGraphView.prototype.at = function () {
        if (this.i != null) {
            var a = this.i;
            a.onMouseOver = delegateRemove(a.onMouseOver, runOn(this, this.av));
            var b = this.i;
            b.onMouseLeave = delegateRemove(b.onMouseLeave, runOn(this, this.au));
            this.i.aq();
        }
    };
    XamBulletGraphView.prototype.av = function (a, b, c) {
        if (this.m != null) {
            this.m.onMouseOver(a, b, c);
        }
    };
    XamBulletGraphView.prototype.au = function (a) {
        if (this.m != null) {
            this.m.onMouseLeave();
        }
    };
    XamBulletGraphView.prototype.a7 = function () {
        this.a0();
        var a = Math.round(this.ag.rootWrapper.width());
        var b = Math.round(this.ag.rootWrapper.height());
        this.m.hw = new Rect(0, 0, 0, a, b);
        this.m.hu = new Rect(0, 0, 0, a, b);
        if (this.i != null) {
            this.i.bf = this.m.hw;
        }
    };
    XamBulletGraphView.prototype.as = function () {
        this.bm();
    };
    XamBulletGraphView.prototype.bp = function (a) {
        this.x = a;
    };
    XamBulletGraphView.prototype.bm = function () {
        var a = this.m.hw.width;
        var b = this.m.hw.height;
        var c = a * this.ap;
        var d = b * this.ap;
        if (this.ao != c || this.an != d) {
            this.ai.setAttribute("width", c.toString());
            this.ai.setAttribute("height", d.toString());
            this.ai.setStyleProperty("width", a.toString() + "px");
            this.ai.setStyleProperty("height", b.toString() + "px");
            this.ao = truncate(Math.round(c));
            this.an = truncate(Math.round(d));
        }
        if (this.p.d && this.ap != 1) {
            this.p.z();
            this.p.aa(this.ap, this.ap);
        }
        this.p.k(this.m.hw.left, this.m.hw.top, this.m.hw.width, this.m.hw.height);
        this.p.s(this.cf);
        this.p.s(this.cg);
        if (this.x != null) {
            for (var e = 0; e < this.x.count; e++) {
                this.p.s(this.x._inner[e]);
            }
        }
        for (var f = 0; f < this.y.count; f++) {
            this.p.ac(this.n);
            this.p.w(this.y._inner[f]);
        }
        for (var g = 0; g < this.z.count; g++) {
            this.p.s(this.z._inner[g]);
        }
        this.p.s(this.cj);
        this.p.s(this.ci);
        if (this.p.d && this.ap != 1) {
            this.p.y();
        }
    };
    XamBulletGraphView.prototype.by = function () {
        if (this.m.c7 != null) {
            this.n = this.m.aw();
        }
        else {
            this.n = FontUtil.getFont(this.ag);
        }
        this.ac = this.ad(this.n);
        if (this.m.hg == null) {
            var a = this.ag.rootWrapper.getStyleProperty("color");
            if (stringIsNullOrEmpty(a) == false) {
                this.b2 = new Brush();
                this.b2._fill = a;
                this.m.hg = this.b2;
            }
        }
        if (this.p != null) {
            this.p.ac(this.n);
        }
    };
    XamBulletGraphView.prototype.ae = function (a) {
        var b = typeCast(TextBlock.$, a);
        if (b != null && b.ak != null) {
            return this.p.e(b) + 0;
        }
        return 0;
    };
    XamBulletGraphView.prototype.cr = function (a) {
        if (isNaN_(this.ac)) {
            this.ac = this.ad(null);
        }
        var b = this.ae(a);
        var c = this.ac;
        return new Size(1, b, c);
    };
    XamBulletGraphView.prototype.bq = function (a, b) {
        if (b != null) {
            a.am = b;
        }
        else {
            a.am = this.b3;
        }
    };
    XamBulletGraphView.prototype.bh = function (a, b, c) {
        a.n = b;
        a.o = c;
    };
    XamBulletGraphView.prototype.bg = function (a, b) {
    };
    XamBulletGraphView.prototype.bi = function (a, b) {
    };
    XamBulletGraphView.prototype.ad = function (a) {
        return FontUtil.getCurrentFontHeight(this.ag, a);
    };
    XamBulletGraphView.prototype.bo = function () {
        if (!this.r) {
            this.r = true;
            if (this.ag != null) {
                this.ag.setTimeout(runOn(this, this.ar), 0);
            }
            else {
                window.setTimeout(runOn(this, this.ar), 0);
            }
        }
    };
    XamBulletGraphView.prototype.ar = function () {
        if (this.r) {
            this.r = false;
            this.m.ew();
        }
    };
    XamBulletGraphView.prototype.flush = function () {
        if (this.r) {
            this.ar();
        }
    };
    XamBulletGraphView.prototype.o = function (a, b) {
        return FontUtil.getFontInfo(this.ag, a, b);
    };
    XamBulletGraphView.prototype.aw = function (a) {
        var e_3, _a, e_4, _b, e_5, _c;
        a.scalePath = new PathVisualData(1, "Scale", this.ch);
        a.targetValuePath = new PathVisualData(1, "TargetValue", this.ci);
        a.valuePath = new PathVisualData(1, "Value", this.cj);
        a.backingPath = new PathVisualData(1, "Backing", this.cf);
        a.scaleBackgroundPath = new PathVisualData(1, "ScaleBackground", this.cg);
        var b = this.n;
        try {
            for (var _d = __values(fromEnum(this.y)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var c = _e.value;
                if (c._visibility == 0) {
                    var d = this.o(c, b);
                    var e = new LinearGraphScaleLabelVisualData();
                    e.labelValue = c.ak;
                    e.labelPosition = PointData.b({ $type: Point_$type, x: c.n, y: c.o });
                    e.labelSize = SizeData.b(this.cr(c));
                    e.appearance = AppearanceHelper.c(c, d);
                    a.scaleLabels.add(e);
                }
            }
        }
        catch (e_3_1) {
            e_3 = { error: e_3_1 };
        }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return))
                    _a.call(_d);
            }
            finally {
                if (e_3)
                    throw e_3.error;
            }
        }
        try {
            for (var _f = __values(fromEnum(this.z)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var f = _g.value;
                if (f._visibility == 0) {
                    var g = new LinearGraphScaleTickmarkVisualData();
                    g.tickPath = new PathVisualData(1, "tickmarks", f);
                    a.scaleTickmarks.add(g);
                }
            }
        }
        catch (e_4_1) {
            e_4 = { error: e_4_1 };
        }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return))
                    _b.call(_f);
            }
            finally {
                if (e_4)
                    throw e_4.error;
            }
        }
        try {
            for (var _h = __values(fromEnum(this.x)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var h = _j.value;
                if (h._visibility == 0) {
                    var i = new LinearGraphRangeVisualData();
                    var j = new PathVisualData(1, "range", h);
                    i.rangePath = j;
                    a.ranges.add(i);
                }
            }
        }
        catch (e_5_1) {
            e_5 = { error: e_5_1 };
        }
        finally {
            try {
                if (_j && !_j.done && (_c = _h.return))
                    _c.call(_h);
            }
            finally {
                if (e_5)
                    throw e_5.error;
            }
        }
    };
    XamBulletGraphView.prototype.bj = function (a) {
        a._visibility = 0;
    };
    XamBulletGraphView.prototype.bk = function (a) {
        a._visibility = 1;
    };
    XamBulletGraphView.prototype.bl = function (a) {
        this.aa.remove(a);
    };
    XamBulletGraphView.prototype.cq = function () {
        var a = new Path();
        this.aa.add(a);
        return a;
    };
    XamBulletGraphView.prototype.bt = function (a) {
        a._visibility = 0;
    };
    XamBulletGraphView.prototype.bu = function (a) {
        a._visibility = 1;
    };
    XamBulletGraphView.prototype.bv = function (a) {
        this.ab.remove(a);
    };
    XamBulletGraphView.prototype.b1 = function () {
        var a = new TextBlock();
        this.ab.add(a);
        return a;
    };
    XamBulletGraphView.prototype.bc = function (a) {
        a._visibility = 0;
    };
    XamBulletGraphView.prototype.bd = function (a) {
        a._visibility = 1;
    };
    XamBulletGraphView.prototype.be = function (a) {
        this.z.remove(a);
    };
    XamBulletGraphView.prototype.cp = function () {
        var a = new Path();
        this.z.add(a);
        return a;
    };
    XamBulletGraphView.prototype.a1 = function (a) {
        a._visibility = 0;
    };
    XamBulletGraphView.prototype.a2 = function (a) {
        a._visibility = 1;
    };
    XamBulletGraphView.prototype.a3 = function (a) {
        this.y.remove(a);
    };
    XamBulletGraphView.prototype.b0 = function () {
        var a = new TextBlock();
        this.y.add(a);
        return a;
    };
    XamBulletGraphView.prototype.l = function () {
        var _this = this;
        if (this.k == null) {
            return null;
        }
        return ((function () {
            var $ret = new ToolTipInfo();
            $ret.b = _this.am;
            $ret.d = _this.cd;
            $ret.c = _this.aq;
            $ret.a = _this.k;
            return $ret;
        })());
    };
    XamBulletGraphView.prototype.bf = function () {
        this.ap = this.m.bm;
    };
    XamBulletGraphView.$t = markType(XamBulletGraphView, 'XamBulletGraphView');
    XamBulletGraphView.w = new Dictionary$2(String_$type, Brush.$, 0);
    XamBulletGraphView.g = null;
    XamBulletGraphView.h = null;
    return XamBulletGraphView;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var defaultFont = "Verdana, Arial, \"Segoe UI\", \"Myriad Pro\", sans-serif";
var BulletGraphStylingDefaults = /*@__PURE__*/ (function () {
    var BulletGraphStylingDefaults = {
        //"ui-bulletgraph-backing": {
        //    "background-color": "#ffffff",
        //    "border-color": "#ffffff"
        //},
        "ui-bulletgraph-targetvalue": {
            "background-color": "#333333",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-tick": {
            "background-color": "rgba(0, 0, 0, 0.35)",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-minortick": {
            "background-color": "rgba(0, 0, 0, 0.2)",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-label": {
            "background-color": "#666666",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-1": {
            "background-color": "#0078C8",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-2": {
            "background-color": "#0099FF",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-3": {
            "background-color": "#21A7FF",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-4": {
            "background-color": "#4FB9FF",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-5": {
            "background-color": "#79C9FF",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-value": {
            "background-color": "#333",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph": {
            "font-family": defaultFont,
            "font-size": "11px",
            "color": "#494949"
        },
        "font-family": defaultFont,
        "font-style": "normal",
        "font-weight": "normal",
        "font-size": "11px",
        "color": "#666666",
        "font-variant": "",
        "line-height": ""
    };
    return BulletGraphStylingDefaults;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents event argument for FormatLinearGraphLabel.
*/
var IgrFormatLinearGraphLabelEventArgs = /** @class */ /*@__PURE__*/ (function () {
    function IgrFormatLinearGraphLabelEventArgs() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    IgrFormatLinearGraphLabelEventArgs.prototype.createImplementation = function () {
        return new FormatLinearGraphLabelEventArgs();
    };
    Object.defineProperty(IgrFormatLinearGraphLabelEventArgs.prototype, "i", {
        get: function () {
            return this._implementation;
        },
        enumerable: true,
        configurable: true
    });
    IgrFormatLinearGraphLabelEventArgs.prototype.onImplementationCreated = function () {
    };
    IgrFormatLinearGraphLabelEventArgs.prototype._provideImplementation = function (i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    };
    Object.defineProperty(IgrFormatLinearGraphLabelEventArgs.prototype, "actualMinimumValue", {
        get: function () {
            return this.i.actualMinimumValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatLinearGraphLabelEventArgs.prototype, "actualMaximumValue", {
        get: function () {
            return this.i.actualMaximumValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatLinearGraphLabelEventArgs.prototype, "value", {
        get: function () {
            return this.i.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatLinearGraphLabelEventArgs.prototype, "label", {
        get: function () {
            return this.i.label;
        },
        set: function (value) {
            this.i.label = value;
        },
        enumerable: true,
        configurable: true
    });
    return IgrFormatLinearGraphLabelEventArgs;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents event argument for AlignLinearGraphLabel.
*/
var IgrAlignLinearGraphLabelEventArgs = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrAlignLinearGraphLabelEventArgs, _super);
    function IgrAlignLinearGraphLabelEventArgs() {
        return _super.call(this) || this;
    }
    IgrAlignLinearGraphLabelEventArgs.prototype.createImplementation = function () {
        return new AlignLinearGraphLabelEventArgs();
    };
    Object.defineProperty(IgrAlignLinearGraphLabelEventArgs.prototype, "i", {
        get: function () {
            return this._implementation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrAlignLinearGraphLabelEventArgs.prototype, "width", {
        get: function () {
            return this.i.width;
        },
        set: function (value) {
            this.i.width = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrAlignLinearGraphLabelEventArgs.prototype, "height", {
        get: function () {
            return this.i.height;
        },
        set: function (value) {
            this.i.height = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrAlignLinearGraphLabelEventArgs.prototype, "offsetX", {
        get: function () {
            return this.i.offsetX;
        },
        set: function (value) {
            this.i.offsetX = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrAlignLinearGraphLabelEventArgs.prototype, "offsetY", {
        get: function () {
            return this.i.offsetY;
        },
        set: function (value) {
            this.i.offsetY = value;
        },
        enumerable: true,
        configurable: true
    });
    return IgrAlignLinearGraphLabelEventArgs;
}(IgrFormatLinearGraphLabelEventArgs));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrLinearGraphRange = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrLinearGraphRange, _super);
    function IgrLinearGraphRange(props) {
        var _this = _super.call(this, props) || this;
        _this._renderer = null;
        _this.__p = null;
        _this._hasUserValues = new Set();
        _this._stylingContainer = null;
        _this._stylingParent = null;
        _this._inStyling = false;
        if (_this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(_this));
        }
        _this._implementation = _this.createImplementation();
        _this._implementation.externalObject = _this;
        _this.onImplementationCreated();
        return _this;
    }
    Object.defineProperty(IgrLinearGraphRange.prototype, "i", {
        get: function () {
            return this._implementation;
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGraphRange.prototype.onImplementationCreated = function () {
    };
    IgrLinearGraphRange.prototype.render = function () {
        return null;
    };
    IgrLinearGraphRange.prototype.componentDidMount = function () {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(this.props)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    {
                        this[p] = this.props[p];
                    }
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
    };
    IgrLinearGraphRange.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var e_2, _a;
        var mod = getModifiedProps(this.props, nextProps);
        try {
            for (var _b = __values(Object.keys(mod)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    this[p] = mod[p];
                }
            }
        }
        catch (e_2_1) {
            e_2 = { error: e_2_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_2)
                    throw e_2.error;
            }
        }
        return true;
    };
    Object.defineProperty(IgrLinearGraphRange.prototype, "rangeInternal", {
        get: function () {
            return this.i;
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGraphRange.prototype.createImplementation = function () {
        return new XamLinearGraphRange();
    };
    IgrLinearGraphRange.prototype.ngOnInit = function () {
    };
    IgrLinearGraphRange.prototype._provideRenderer = function (renderer) {
        this._renderer = renderer;
    };
    IgrLinearGraphRange._createFromInternal = function (internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        var name = internal.$type.name;
        var externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    };
    Object.defineProperty(IgrLinearGraphRange.prototype, "name", {
        /**
     * Gets or sets the name of the range.
    */
        get: function () {
            return this.i.u;
        },
        set: function (v) {
            this.i.u = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "brush", {
        /**
         * Gets or sets the brush to use to fill the range.
        */
        get: function () {
            return brushToString(this.i.an);
        },
        set: function (v) {
            this.i.an = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "outline", {
        /**
         * Gets or sets the outline to use when rendering the range.
        */
        get: function () {
            return brushToString(this.i.ao);
        },
        set: function (v) {
            this.i.ao = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "startValue", {
        /**
         * Gets or sets the value at which the range starts along the scale.
        */
        get: function () {
            return this.i.o;
        },
        set: function (v) {
            this.i.o = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "endValue", {
        /**
         * Gets or sets the value at which the range ends along the scale.
        */
        get: function () {
            return this.i.j;
        },
        set: function (v) {
            this.i.j = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "innerStartExtent", {
        /**
         * Gets or sets the distance measured from the front/bottom of the bullet graph (from 0 to 1) at which to start rendering the inner edge of the range.
         * Values further from zero than 1 can be used to make this extend further than the normal width/height of the bullet graph.
        */
        get: function () {
            return this.i.l;
        },
        set: function (v) {
            this.i.l = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "innerEndExtent", {
        /**
         * Gets or sets the distance measured from the front/bottom of the bullet graph (from 0 to 1) at which to end rendering the inner edge of the range.
         * Values further from zero than 1 can be used to make this extend further than the normal width/height of the bullet graph.
        */
        get: function () {
            return this.i.k;
        },
        set: function (v) {
            this.i.k = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "outerStartExtent", {
        /**
         * Gets or sets the distance measured from the front/bottom of the bullet graph (from 0 to 1) at which to start rendering the outer edge of the range.
         * Values further from zero than 1 can be used to make this extend further than the normal width/height of the bullet graph.
        */
        get: function () {
            return this.i.n;
        },
        set: function (v) {
            this.i.n = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "outerEndExtent", {
        /**
         * Gets or sets the distance measured from the front/bottom of the bullet graph (from 0 to 1) at which to end rendering the outer edge of the range.
         * Values further from zero than 1 can be used to make this extend further than the normal width/height of the bullet graph.
        */
        get: function () {
            return this.i.m;
        },
        set: function (v) {
            this.i.m = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGraphRange.prototype, "strokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering this range's outline.
        */
        get: function () {
            return this.i.p;
        },
        set: function (v) {
            this.i.p = +v;
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGraphRange.prototype.findByName = function (name) {
        return null;
    };
    Object.defineProperty(IgrLinearGraphRange.prototype, "hasUserValues", {
        get: function () {
            return this._hasUserValues;
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGraphRange.prototype.__m = function (propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    };
    IgrLinearGraphRange.prototype._styling = function (container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        var genericPrefix = "";
        var typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("LinearGraphRange");
        var additionalPrefixes = [];
        var prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        var b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            var basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            var parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            var parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    };
    return IgrLinearGraphRange;
}(Component));

var IgrLinearGraphRangeCollection = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrLinearGraphRangeCollection, _super);
    function IgrLinearGraphRangeCollection(list) {
        var _this = _super.call(this) || this;
        if (!IgrLinearGraphRange.$type) {
            IgrLinearGraphRange.$type = markType(IgrLinearGraphRange, "IgrLinearGraphRange");
        }
        if (list) {
            for (var i = 0; i < list.length; i++) {
                _this.add(list[i]);
            }
        }
        return _this;
    }
    IgrLinearGraphRangeCollection.prototype._createInnerColl = function () {
        if (!IgrLinearGraphRange.$type) {
            IgrLinearGraphRange.$type = markType(IgrLinearGraphRange, "IgrLinearGraphRange");
        }
        var coll = new SyncableObservableCollection$2(IgrLinearGraphRange.$type, XamLinearGraphRange.$type, 0);
        coll.compare = function (ext, int) {
            var comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = function (ext) {
            return ext._implementation;
        };
        coll.createFrom = function (int) {
            var ext = int.externalObject;
            if (!ext) {
                ext = IgrLinearGraphRange._createFromInternal(int);
                if (ext) {
                    ext._implementation = int;
                }
            }
            return ext;
        };
        return coll;
    };
    return IgrLinearGraphRangeCollection;
}(IgCollection));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents a bullet graph.
*/
var IgrBulletGraph = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrBulletGraph, _super);
    function IgrBulletGraph(props) {
        var _this = _super.call(this, props) || this;
        _this.contentRanges = [];
        /**
        * The ranges actually present in the chart. Do not directly modify this array.
        * This array's contents can be modified by causing Angular to reproject the child content.
        * Or adding and removing ranges from the manual ranges collection on the ranges property.
        */
        _this.actualRanges = [];
        _this._ranges = null;
        _this._rangesAdapter = null;
        _this._tooltipTemplate = null;
        _this._tooltipContent = null;
        _this._defaultTooltips = null;
        _this._uniqueTooltipId = 0;
        _this._initialized = false;
        _this.__p = null;
        _this._hasUserValues = new Set();
        _this._stylingContainer = null;
        _this._stylingParent = null;
        _this._inStyling = false;
        _this._formatLabel = null;
        _this._formatLabel_wrapped = null;
        _this._alignLabel = null;
        _this._alignLabel_wrapped = null;
        _this._actualMinimumValueChange = null;
        _this._actualMinimumValueChange_wrapped = null;
        _this._actualMaximumValueChange = null;
        _this._actualMaximumValueChange_wrapped = null;
        if (_this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(_this));
        }
        _this._getMainRef = _this._getMainRef.bind(_this);
        _this._tooltipRef = _this._tooltipRef.bind(_this);
        _this._activeTooltipElements = new Map();
        _this._activeTooltips = new Map();
        _this._currentTooltips = [];
        _this._contentChildrenManager = new ContentChildrenManager(function (ch) { return ch.key || ch.props.name; }, function (ch) { return ch.key || ch.props.name; }, function () { return _this._updateContentChildren(); });
        var container = null;
        if (document) {
            container = document.createElement("div");
            container.style.display = "block";
            container.style.width = "100%";
            container.style.height = "100%";
        }
        var root;
        root = container;
        _this._renderer = new ReactRenderer(root, document, true, BulletGraphStylingDefaults);
        _this._container = _this._renderer.getWrapper(container);
        _this._implementation = _this.createImplementation();
        //this._container = this._renderer.createElement("div");
        //this._renderer.rootWrapper.append(this._container);
        //this._container.setStyleProperty("display", "block");
        //this._container.setStyleProperty("width", "100%");
        //this._container.setStyleProperty("height", "100%");
        _this._wrapper = _this._renderer;
        //var root: any;
        //root = this._container;
        //if (this._container.nativeElement != null) {
        //    root = this._container.nativeElement;
        //}
        var gauge = _this.i;
        _this._gauge = gauge;
        _this._rangesAdapter = new CollectionAdapter(_this.contentRanges, _this.i.ranges, _this.actualRanges, function (c) { return c.i; }, function (i) {
            i._provideRenderer(_this._wrapper);
            if (_this._container && _this._container.getNativeElement().parentElement) {
                i._styling(_this._container.getNativeElement(), _this, _this);
            }
        }, function (i) { i._provideRenderer(null); });
        gauge.provideContainer(_this._renderer);
        _this._renderer.addSizeWatcher(function () {
            _this._gauge.containerResized();
        });
        _this._initialized = true;
        return _this;
    }
    Object.defineProperty(IgrBulletGraph.prototype, "height", {
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            if (this._elRef) {
                this._elRef.style.height = value;
                this.containerResized();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (value) {
            this._width = value;
            if (this._elRef) {
                this._elRef.style.width = value;
                this.containerResized();
            }
        },
        enumerable: true,
        configurable: true
    });
    IgrBulletGraph.prototype._updateContentChildren = function () {
        this.contentRanges.length = 0;
        var contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (var i = 0; i < contentChildrenActual.length; i++) {
            if ((XamLinearGraphRange.$type).isAssignableFrom(contentChildrenActual[i].i.$type)) {
                this.contentRanges.push(contentChildrenActual[i]);
            }
        }
        if (this._rangesAdapter !== null) {
            this._rangesAdapter.notifyContentChanged();
        }
    };
    Object.defineProperty(IgrBulletGraph.prototype, "ranges", {
        /**
         * A collection or manually added axes for the chart.
        */
        get: function () {
            var _this = this;
            if (this._ranges === null) {
                var coll = new IgrLinearGraphRangeCollection();
                var inner = coll._innerColl;
                inner.addListener(function (sender, e) {
                    switch (e.action) {
                        case NotifyCollectionChangedAction.Add:
                            _this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Remove:
                            _this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                            break;
                        case NotifyCollectionChangedAction.Replace:
                            _this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                            _this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Reset:
                            _this._rangesAdapter.clearManualItems();
                            break;
                    }
                });
                this._ranges = coll;
            }
            return this._ranges;
        },
        enumerable: true,
        configurable: true
    });
    IgrBulletGraph.prototype._tooltipRef = function (t) {
        //console.log(t);
        if (t === null) {
            return;
        }
        if (t.currentOwner &&
            t.currentOwner.tooltipTemplate) {
            t.template = t.currentOwner.tooltipTemplate;
        }
        this._activeTooltips.set(t.currentOwner, t);
    };
    IgrBulletGraph.prototype.render = function () {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        var children = this._contentChildrenManager.getChildren(this.props.children);
        if (this._currentTooltips && this._currentTooltips.length > 0) {
            for (var i = 0; i < this._currentTooltips.length; i++) {
                var t = this._currentTooltips[i];
                if (this._activeTooltipElements.has(t)) {
                    children.push(this._activeTooltipElements.get(t));
                }
                else {
                    if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
                        continue;
                    }
                    var Tooltip = TypeRegistrar.get("IgrTooltipContainer");
                    var tEle = createElement(Tooltip, {
                        ref: this._tooltipRef,
                        key: this._currentTooltips[i].key,
                        owner: this._currentTooltips[i]
                    });
                    var portal = createPortal(tEle, t, this._currentTooltips[i].key);
                    this._activeTooltipElements.set(t, portal);
                    children.push(portal);
                }
            }
        }
        var div = createElement("div", {
            className: "ig-bullet-graph igr-bullet-graph",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    };
    IgrBulletGraph.prototype.componentDidMount = function () {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(this.props)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    {
                        this[p] = this.props[p];
                    }
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container.getNativeElement());
        this.containerResized();
        this.initializeContent();
    };
    IgrBulletGraph.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var e_2, _a;
        var mod = getModifiedProps(this.props, nextProps);
        try {
            for (var _b = __values(Object.keys(mod)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    this[p] = mod[p];
                }
            }
        }
        catch (e_2_1) {
            e_2 = { error: e_2_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_2)
                    throw e_2.error;
            }
        }
        return true;
    };
    IgrBulletGraph.prototype._getMainRef = function (div) {
        this._elRef = div;
    };
    IgrBulletGraph.prototype.destroy = function () {
        this._wrapper.rootWrapper.unlistenAll();
        this._gauge.destroy();
        this._wrapper.destroy();
    };
    IgrBulletGraph.prototype.createImplementation = function () {
        return new XamBulletGraph();
    };
    IgrBulletGraph.prototype.initializeContent = function () {
        this._styling(this._container.getNativeElement(), this);
        if (this.actualRanges && this.actualRanges.length > 0) {
            var currRange = this.actualRanges;
            for (var i = 0; i < currRange.length; i++) {
                currRange[i]._styling(this._container.getNativeElement(), this, this);
            }
        }
        this._updateContentChildren();
        this.i.containerResized();
    };
    IgrBulletGraph.prototype.componentWillUnmount = function () {
        //this._grid.destroy();
        this.destroy();
    };
    Object.defineProperty(IgrBulletGraph.prototype, "tooltipTemplate", {
        get: function () {
            return this._tooltipTemplate;
        },
        set: function (value) {
            this._tooltipTemplate = value;
            if (value == null) {
                if (this._tooltipContent !== null) {
                    this._tooltipContent.destroy();
                    this._tooltipContent = null;
                }
            }
            if (this._tooltipContent != null) {
                this._tooltipContent.instance.template = this._tooltipTemplate;
            }
            else {
                this._ensureTooltipCreated();
            }
        },
        enumerable: true,
        configurable: true
    });
    IgrBulletGraph.prototype.createWrapper = function (ele) {
        var wrapper = new ReactWrapper(ele, this._renderer);
        wrapper.updateToolTip = ele.updateToolTip;
        wrapper.hideToolTip = ele.hideToolTip;
        return wrapper;
    };
    IgrBulletGraph.prototype._ensureDefaultTooltip = function () {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips["ensureDefaultTooltip"](this);
    };
    IgrBulletGraph.prototype._onDefaultTooltipsReady = function (cr) {
        this._ensureDefaultTooltip();
    };
    IgrBulletGraph.prototype.createTooltip = function () {
        // if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
        // 	return null;
        // }
        // let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
        var wrapper = this._wrapper.createElement("div");
        var ele = wrapper.getNativeElement();
        ele.key = "__tooltip_" + this._uniqueTooltipId;
        this._uniqueTooltipId++;
        this._currentTooltips = this._currentTooltips.slice(0);
        this._currentTooltips.push(ele);
        //let element = React.createElement(Tooltip,  );
        //let portal = ReactDOM.createPortal(element, ele);
        var self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                var ext = new IgrDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container.getNativeElement()) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.getNativeElement().appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            if (self._activeTooltips.has(ele)) {
                var t = self._activeTooltips.get(ele);
                if (t.template === null &&
                    ele.tooltipTemplate !== null) {
                    t.template = ele.tooltipTemplate;
                }
                t.dataContext = c;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        this._updateTooltipState();
        return ele;
    };
    IgrBulletGraph.prototype._updateTooltipState = function () {
        if (this._initialized) {
            this.setState({ tooltips: this._currentTooltips });
        }
    };
    IgrBulletGraph.prototype._ensureTooltipCreated = function () {
        if (this.i.toolTip == null) {
            var tooltip = this.createTooltip();
            var ele = tooltip;
            if (tooltip == null) {
                return;
            }
            this._tooltipContent = tooltip;
            //(<any>tooltip.instance).template = this._tooltipTemplate;
            this.i.toolTip = this.createWrapper(tooltip);
            if (this._activeTooltips.has(ele)) {
                var tCont = this._activeTooltips.get(ele);
                tCont.template = ele.tooltipTemplate;
            }
        }
    };
    Object.defineProperty(IgrBulletGraph.prototype, "i", {
        /**
         * @hidden
         */
        get: function () {
            return this._implementation;
        } /**
                                     * @hidden
                                     */,
        enumerable: true,
        configurable: true
    });
    IgrBulletGraph._createFromInternal = function (internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        var name = internal.$type.name;
        var externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    };
    Object.defineProperty(IgrBulletGraph.prototype, "animating", {
        /**
     * Gets a value indicating whether the bullet graph is currently animating.
    */
        get: function () {
            return this.i.a2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "transitionProgress", {
        /**
         * Gets the transition progress of the animation when the control is animating.
        */
        get: function () {
            return this.i.cq;
        },
        set: function (v) {
            this.i.cq = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "orientation", {
        /**
         * Gets or sets the orientation of the scale.
        */
        get: function () {
            return this.i.ar;
        },
        set: function (v) {
            this.i.ar = ensureEnum(LinearScaleOrientation_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "scaleBackgroundBrush", {
        /**
         * Gets or sets the background brush for the scale.
        */
        get: function () {
            return brushToString(this.i.hj);
        },
        set: function (v) {
            this.i.hj = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "scaleBackgroundOutline", {
        /**
         * Gets or sets the background outline for the scale.
        */
        get: function () {
            return brushToString(this.i.hk);
        },
        set: function (v) {
            this.i.hk = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "scaleBackgroundThickness", {
        /**
         * Gets or sets the background outline thickness for the scale.
        */
        get: function () {
            return this.i.b8;
        },
        set: function (v) {
            this.i.b8 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "rangeBrushes", {
        /**
         * Gets or sets a collection of brushes to be used as the palette for bullet graph ranges.
        */
        get: function () {
            return fromBrushCollection(this.i.ah);
        },
        set: function (v) {
            this.i.ah = toBrushCollection(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "rangeOutlines", {
        /**
         * Gets or sets a collection of brushes to be used as the palette for bullet graph outlines.
        */
        get: function () {
            return fromBrushCollection(this.i.ai);
        },
        set: function (v) {
            this.i.ai = toBrushCollection(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "minimumValue", {
        /**
         * Gets or sets the minimum value of the scale.
        */
        get: function () {
            return this.i.by;
        },
        set: function (v) {
            this.i.by = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "actualMinimumValue", {
        /**
         * Gets the resolved minimum value of the scale.
        */
        get: function () {
            return this.i.bl;
        },
        set: function (v) {
            this.i.bl = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "maximumValue", {
        /**
         * Gets or sets the maximum value of the scale.
        */
        get: function () {
            return this.i.bx;
        },
        set: function (v) {
            this.i.bx = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "actualMaximumValue", {
        /**
         * Gets the resolved maximum value of the scale.
        */
        get: function () {
            return this.i.bk;
        },
        set: function (v) {
            this.i.bk = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "targetValue", {
        /**
         * Gets or sets the value indicated by the target value bar.
        */
        get: function () {
            return this.i.ce;
        },
        set: function (v) {
            this.i.ce = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "targetValueName", {
        /**
         * Gets or sets the name used for the target value. The name is displayed in the default target value tooltip.
        */
        get: function () {
            return this.i.d8;
        },
        set: function (v) {
            this.i.d8 = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "value", {
        /**
         * Gets or sets the value at which the bar ends.
        */
        get: function () {
            return this.i.cr;
        },
        set: function (v) {
            this.i.cr = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "valueName", {
        /**
         * Gets or sets the name used for actual value.
        */
        get: function () {
            return this.i.ep;
        },
        set: function (v) {
            this.i.ep = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "rangeInnerExtent", {
        /**
         * Gets or sets the position at which to start rendering the ranges, measured from the front/bottom of the control as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.b6;
        },
        set: function (v) {
            this.i.b6 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "rangeOuterExtent", {
        /**
         * Gets or sets the position at which to stop rendering the range as a value from 0 to 1 measured from the front/bottom of the bullet graph.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.b7;
        },
        set: function (v) {
            this.i.b7 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "valueInnerExtent", {
        /**
         * Gets or sets the position at which to start rendering the actual value geometries, measured from the front/bottom of the bullet graph as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.cs;
        },
        set: function (v) {
            this.i.cs = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "valueOuterExtent", {
        /**
         * Gets or sets the position at which to stop rendering the actual value geometries as a value from 0 to 1 measured from the front/bottom of the bullet graph.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.ct;
        },
        set: function (v) {
            this.i.ct = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "interval", {
        /**
         * Gets or sets the interval to use for the scale.
        */
        get: function () {
            return this.i.bs;
        },
        set: function (v) {
            this.i.bs = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "ticksPostInitial", {
        /**
         * A value to start adding tickmarks, added to the scale's MinimumValue.
        */
        get: function () {
            return this.i.cl;
        },
        set: function (v) {
            this.i.cl = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "ticksPreTerminal", {
        /**
         * A value to stop adding tickmarks, subtracted from the scale's MaximumValue.
        */
        get: function () {
            return this.i.cm;
        },
        set: function (v) {
            this.i.cm = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "labelInterval", {
        /**
         * Gets or sets the interval to use for rendering labels. This defaults to be the same interval as the tickmarks on the scale.
        */
        get: function () {
            return this.i.bu;
        },
        set: function (v) {
            this.i.bu = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "labelExtent", {
        /**
         * Gets or sets the position at which to put the labels as a value from 0 to 1, measured from the bottom of the scale.
         * Values further from zero than 1 can be used to hide the labels of the bullet graph.
        */
        get: function () {
            return this.i.bt;
        },
        set: function (v) {
            this.i.bt = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "labelsPostInitial", {
        /**
         * A value to start adding labels, added to the scale's MinimumValue.
        */
        get: function () {
            return this.i.bv;
        },
        set: function (v) {
            this.i.bv = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "labelsPreTerminal", {
        /**
         * A value to stop adding labels, subtracted from the scale's MaximumValue.
        */
        get: function () {
            return this.i.bw;
        },
        set: function (v) {
            this.i.bw = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "minorTickCount", {
        /**
         * Gets or sets the number of minor tickmarks to place between major tickmarks.
        */
        get: function () {
            return this.i.bz;
        },
        set: function (v) {
            this.i.bz = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "tickStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the major tickmarks as a value from 0 to 1, measured from the front/bottom of the bullet graph.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.cn;
        },
        set: function (v) {
            this.i.cn = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "tickEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the major tickmarks as a value from 0 to 1, measured from the front/bottom of the bullet graph.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.cj;
        },
        set: function (v) {
            this.i.cj = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "tickStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering ticks.
        */
        get: function () {
            return this.i.cp;
        },
        set: function (v) {
            this.i.cp = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "tickBrush", {
        /**
         * Gets or sets the brush to use for the major tickmarks.
        */
        get: function () {
            return brushToString(this.i.hn);
        },
        set: function (v) {
            this.i.hn = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "fontBrush", {
        /**
         * Gets or sets the brush to use for the label font.
        */
        get: function () {
            return brushToString(this.i.hg);
        },
        set: function (v) {
            this.i.hg = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "valueBrush", {
        /**
         * Gets or sets the brush to use for the actual value element.
        */
        get: function () {
            return brushToString(this.i.ho);
        },
        set: function (v) {
            this.i.ho = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "valueOutline", {
        /**
         * Gets or sets the brush to use for the outline of actual value element.
        */
        get: function () {
            return brushToString(this.i.hp);
        },
        set: function (v) {
            this.i.hp = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "valueStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering single actual value element.
        */
        get: function () {
            return this.i.cu;
        },
        set: function (v) {
            this.i.cu = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "minorTickStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the minor tickmarks as a value from 0 to 1, measured from the front/bottom of the bullet graph.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.b2;
        },
        set: function (v) {
            this.i.b2 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "minorTickEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the minor tickmarks as a value from 0 to 1, measured from the front/bottom of the bullet graph.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.b0;
        },
        set: function (v) {
            this.i.b0 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "minorTickStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering minor ticks.
        */
        get: function () {
            return this.i.b4;
        },
        set: function (v) {
            this.i.b4 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "minorTickBrush", {
        /**
         * Gets or sets the brush to use for the minor tickmarks.
        */
        get: function () {
            return brushToString(this.i.hi);
        },
        set: function (v) {
            this.i.hi = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "isScaleInverted", {
        /**
         * Gets or sets a value indicating whether the scale is inverted.
         * When the scale is inverted the direction in which the scale values increase is right to left.
        */
        get: function () {
            return this.i.a4;
        },
        set: function (v) {
            this.i.a4 = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "backingBrush", {
        /**
         * Gets or sets the brush to use to fill the backing of the bullet graph.
        */
        get: function () {
            return brushToString(this.i.he);
        },
        set: function (v) {
            this.i.he = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "backingOutline", {
        /**
         * Gets or sets the brush to use for the outline of the backing.
        */
        get: function () {
            return brushToString(this.i.hf);
        },
        set: function (v) {
            this.i.hf = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "backingStrokeThickness", {
        /**
         * Gets or sets the stroke thickness of the backing outline.
        */
        get: function () {
            return this.i.bp;
        },
        set: function (v) {
            this.i.bp = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "backingInnerExtent", {
        /**
         * Gets or sets the inner extent of the bullet graph backing.
        */
        get: function () {
            return this.i.bn;
        },
        set: function (v) {
            this.i.bn = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "backingOuterExtent", {
        /**
         * Gets or sets the outer extent of the bullet graph backing.
        */
        get: function () {
            return this.i.bo;
        },
        set: function (v) {
            this.i.bo = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "scaleStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the scale, measured from the front/bottom of the bullet graph as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.cd;
        },
        set: function (v) {
            this.i.cd = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "scaleEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the scale as a value from 0 to 1, measured from the front/bottom of the bullet graph.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.ca;
        },
        set: function (v) {
            this.i.ca = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "targetValueBrush", {
        /**
         * Gets or sets the brush to use when rendering the fill of the comparative marker.
        */
        get: function () {
            return brushToString(this.i.hl);
        },
        set: function (v) {
            this.i.hl = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "targetValueBreadth", {
        /**
         * Get or sets the breadth of the target value element.
        */
        get: function () {
            return this.i.cf;
        },
        set: function (v) {
            this.i.cf = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "targetValueInnerExtent", {
        /**
         * Gets or sets the position at which to start rendering the target value, measured from the front/bottom of the control as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.cg;
        },
        set: function (v) {
            this.i.cg = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "targetValueOuterExtent", {
        /**
         * Gets or sets the position at which to start rendering the target value, measured from the front/bottom of the control as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
        */
        get: function () {
            return this.i.ch;
        },
        set: function (v) {
            this.i.ch = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "targetValueOutline", {
        /**
         * Gets or sets the brush to use when rendering the outline of the target value.
        */
        get: function () {
            return brushToString(this.i.hm);
        },
        set: function (v) {
            this.i.hm = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "targetValueStrokeThickness", {
        /**
         * Gets or sets the stroke thickness of the outline of the target value bar.
        */
        get: function () {
            return this.i.ci;
        },
        set: function (v) {
            this.i.ci = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "labelFormat", {
        /**
         * Gets or sets the label composite format used when creating label values.
        */
        get: function () {
            return this.i.dd;
        },
        set: function (v) {
            this.i.dd = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "labelFormatSpecifiers", {
        /**
         * Gets or sets the format specifiers to use with the LabelFormat string.
        */
        get: function () {
            return this.i.ag;
        },
        set: function (v) {
            this.i.ag = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "transitionDuration", {
        /**
         * Gets or sets the number of milliseconds over which changes to the bullet graph should be animated.
        */
        get: function () {
            return this.i.cy;
        },
        set: function (v) {
            this.i.cy = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "showToolTipTimeout", {
        /**
         * Gets or sets the time in milliseconds that tooltip appearance is delayed with.
        */
        get: function () {
            return this.i.cx;
        },
        set: function (v) {
            this.i.cx = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "showToolTip", {
        /**
         * Gets or sets a value indicating whether tooltips are enabled.
        */
        get: function () {
            return this.i.a8;
        },
        set: function (v) {
            this.i.a8 = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "font", {
        /**
         * Gets or sets the font.
        */
        get: function () {
            return this.i.c7;
        },
        set: function (v) {
            this.i.c7 = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "pixelScalingRatio", {
        /**
         * Gets or sets the scaling value used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get: function () {
            return this.i.b5;
        },
        set: function (v) {
            this.i.b5 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "actualPixelScalingRatio", {
        /**
         * Gets the actual pixel scaling ratio used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get: function () {
            return this.i.bm;
        },
        set: function (v) {
            this.i.bm = +v;
        },
        enumerable: true,
        configurable: true
    });
    IgrBulletGraph.prototype.findByName = function (name) {
        if (this.ranges != null && this.ranges.findByName && this.ranges.findByName(name)) {
            return this.ranges.findByName(name);
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        return null;
    };
    Object.defineProperty(IgrBulletGraph.prototype, "hasUserValues", {
        get: function () {
            return this._hasUserValues;
        },
        enumerable: true,
        configurable: true
    });
    IgrBulletGraph.prototype.__m = function (propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    };
    IgrBulletGraph.prototype._styling = function (container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        var genericPrefix = "";
        var typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("BulletGraph");
        var additionalPrefixes = [];
        var prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        var b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            var basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            var parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            var parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    };
    /**
 * Gets the value for the main scale of the bullet graph for a given point within the bounds of the bullet graph.

* @param point  * The point for which to retrieve the associated value.
*/
    IgrBulletGraph.prototype.getValueForPoint = function (point) {
        var iv = this.i.br(toPoint(point));
        return (iv);
    };
    /**
     * Returns visuals as a serialized string.
    
    */
    IgrBulletGraph.prototype.exportSerializedVisualData = function () {
        var iv = this.i.c6();
        return (iv);
    };
    /**
     * Provide a container for the bullet graph.
    
    * @param container  * The container.
    */
    IgrBulletGraph.prototype.provideContainer = function (container) {
        this.i.provideContainer(container);
    };
    /**
     * Notify that the container has resized.
    
    */
    IgrBulletGraph.prototype.containerResized = function () {
        this.i.containerResized();
    };
    /**
     * Notify that the bullet graph styling has updated.
    
    */
    IgrBulletGraph.prototype.styleUpdated = function () {
        this.i.fr();
    };
    /**
     * Use to force the bullet graph to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the bullet graph needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the bullet graph.
    
    */
    IgrBulletGraph.prototype.flush = function () {
        this.i.ez();
    };
    Object.defineProperty(IgrBulletGraph.prototype, "formatLabel", {
        /**
         * Event which is raised when a label of the bullet graph is formatted.
         * Function takes first argument evt and second argument ui.
         * Use ui.owner to obtain reference to the bullet graph widget.
         * Use ui.actualMinimumValue to obtain the minimum value of the bullet graph scale.
         * Use ui.actualMaximumValue to obtain the maximum value of the bullet graph scale.
         * Use ui.value to obtain the value on the the bullet graph scale associated with the label.
         * Use ui.label to obtain the string value of the label.
        */
        get: function () {
            return this._formatLabel;
        },
        set: function (ev) {
            var _this = this;
            if (this._formatLabel_wrapped !== null) {
                this.i.formatLabel = delegateRemove(this.i.formatLabel, this._formatLabel_wrapped);
                this._formatLabel_wrapped = null;
                this._formatLabel = null;
            }
            this._formatLabel = ev;
            this._formatLabel_wrapped = function (o, e) {
                var outerArgs = new IgrFormatLinearGraphLabelEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeFormatLabel) {
                    _this.beforeFormatLabel(_this, outerArgs);
                }
                if (_this._formatLabel) {
                    _this._formatLabel(_this, outerArgs);
                }
            };
            this.i.formatLabel = delegateCombine(this.i.formatLabel, this._formatLabel_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "alignLabel", {
        /**
         * Event which is raised when a label of the bullet graph is aligned along the scale.
         * Function takes first argument evt and second argument ui.
         * Use ui.owner to obtain reference to gauge widget.
         * Use ui.actualMinimumValue to obtain the minimum value of the bullet graph scale.
         * Use ui.actualMaximumValue to obtain the maximum value of the bullet graph scale.
         * Use ui.value to obtain the value on the the bullet graph scale associated with the label.
         * Use ui.label to obtain the string value of the label.
         * Use ui.width to obtain the width of the label.
         * Use ui.height to obtain the height of the label.
         * Use ui.offsetX to obtain the X offset of the label on the bullet graph scale.
         * Use ui.offsetY to obtain the Y offset of the label on the bullet graph scale.
        */
        get: function () {
            return this._alignLabel;
        },
        set: function (ev) {
            var _this = this;
            if (this._alignLabel_wrapped !== null) {
                this.i.alignLabel = delegateRemove(this.i.alignLabel, this._alignLabel_wrapped);
                this._alignLabel_wrapped = null;
                this._alignLabel = null;
            }
            this._alignLabel = ev;
            this._alignLabel_wrapped = function (o, e) {
                var outerArgs = new IgrAlignLinearGraphLabelEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeAlignLabel) {
                    _this.beforeAlignLabel(_this, outerArgs);
                }
                if (_this._alignLabel) {
                    _this._alignLabel(_this, outerArgs);
                }
            };
            this.i.alignLabel = delegateCombine(this.i.alignLabel, this._alignLabel_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "actualMinimumValueChange", {
        get: function () {
            return this._actualMinimumValueChange;
        },
        set: function (ev) {
            var _this = this;
            if (this._actualMinimumValueChange_wrapped !== null) {
                this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
                this._actualMinimumValueChange_wrapped = null;
                this._actualMinimumValueChange = null;
            }
            this._actualMinimumValueChange = ev;
            this._actualMinimumValueChange_wrapped = function (o, e) {
                var ext = _this.actualMinimumValue;
                if (_this.beforeActualMinimumValueChange) {
                    _this.beforeActualMinimumValueChange(_this, ext);
                }
                if (_this._actualMinimumValueChange) {
                    _this._actualMinimumValueChange(_this, ext);
                }
            };
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrBulletGraph.prototype, "actualMaximumValueChange", {
        get: function () {
            return this._actualMaximumValueChange;
        },
        set: function (ev) {
            var _this = this;
            if (this._actualMaximumValueChange_wrapped !== null) {
                this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
                this._actualMaximumValueChange_wrapped = null;
                this._actualMaximumValueChange = null;
            }
            this._actualMaximumValueChange = ev;
            this._actualMaximumValueChange_wrapped = function (o, e) {
                var ext = _this.actualMaximumValue;
                if (_this.beforeActualMaximumValueChange) {
                    _this.beforeActualMaximumValueChange(_this, ext);
                }
                if (_this._actualMaximumValueChange) {
                    _this._actualMaximumValueChange(_this, ext);
                }
            };
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    return IgrBulletGraph;
}(Component));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrLinearGraphRangeModule = /** @class */ /*@__PURE__*/ (function () {
    function IgrLinearGraphRangeModule() {
    }
    IgrLinearGraphRangeModule.register = function () {
        TypeRegistrar.registerCons('IgrLinearGraphRange', IgrLinearGraphRange);
    };
    return IgrLinearGraphRangeModule;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrBulletGraphCoreModule = /** @class */ /*@__PURE__*/ (function () {
    function IgrBulletGraphCoreModule() {
    }
    IgrBulletGraphCoreModule.register = function () {
        TypeRegistrar.registerCons('IgrBulletGraph', IgrBulletGraph);
        IgrLinearGraphRangeModule.register();
        IgrNumberFormatSpecifierModule.register();
    };
    return IgrBulletGraphCoreModule;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrBulletGraphModule = /** @class */ /*@__PURE__*/ (function () {
    function IgrBulletGraphModule() {
    }
    IgrBulletGraphModule.register = function () {
        IgrBulletGraphCoreModule.register();
        IgrDVInteractivityModule.register();
    };
    return IgrBulletGraphModule;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enumeration of preset needle shapes.
 */
var LinearGraphNeedleShape = /*@__PURE__*/ (function (LinearGraphNeedleShape) {
    /**
     * A custom user defined needle shape.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Custom"] = 0] = "Custom";
    /**
     * A needle shaped like a rectangle.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Rectangle"] = 1] = "Rectangle";
    /**
     * A needle shaped like a triangle.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Triangle"] = 2] = "Triangle";
    /**
     * A needle shaped like a needle.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Needle"] = 3] = "Needle";
    /**
     * A needle shaped like a trapezoid.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Trapezoid"] = 4] = "Trapezoid";
    return LinearGraphNeedleShape;
})({});
/**
 * @hidden
 */
var LinearGraphNeedleShape_$type = /*@__PURE__*/ markEnum('LinearGraphNeedleShape', 'Custom,0|Rectangle,1|Triangle,2|Needle,3|Trapezoid,4');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying the position of the titles relative to scale's start/end.
 */
var TitlesPosition = /*@__PURE__*/ (function (TitlesPosition) {
    /**
     * The titles are placed at scale's start (minimum value).
     */
    TitlesPosition[TitlesPosition["ScaleStart"] = 0] = "ScaleStart";
    /**
     * The titles are placed at the scale's end (maximum value).
     */
    TitlesPosition[TitlesPosition["ScaleEnd"] = 1] = "ScaleEnd";
    return TitlesPosition;
})({});
/**
 * @hidden
 */
var TitlesPosition_$type = /*@__PURE__*/ markEnum('TitlesPosition', 'ScaleStart,0|ScaleEnd,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphNeedlePreparer = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphNeedlePreparer, _super);
    function LinearGraphNeedlePreparer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.b = null;
        return _this;
    }
    LinearGraphNeedlePreparer.prototype.c = function (a) {
        this.d(a);
    };
    LinearGraphNeedlePreparer.prototype.d = function (a) {
        this.f(a);
        var b = this.a();
        a.n = b.u;
        a.m = b.q;
        a.q = 0;
        if (!isNaN_(b.t)) {
            a.q = Math.max(a.q, b.t);
        }
        if (!isNaN_(b.p)) {
            a.q = Math.max(a.q, b.p);
        }
        var c = 7;
        var d = new Array(c);
        var e = new Array(c + 1);
        this.e(a, d, e, b);
        for (var f = 0; f < c; f++) {
            var g = d[f].f;
            g.add(e[f]);
            g.add(e[f + 1]);
        }
    };
    LinearGraphNeedlePreparer.prototype.e = function (a, b, c, d) {
        var e = d.q;
        var f = d.u;
        var g = d.r;
        var h = d.v;
        if (d.d == 0) {
            e = 1 - e;
            f = 1 - f;
            g = 1 - g;
            h = 1 - h;
            b[0] = a.i;
            b[1] = a.j;
            b[2] = a.d;
            b[3] = a.g;
            b[4] = a.f;
            b[5] = a.h;
            b[6] = a.e;
            c[0] = { $type: Point_$type, x: (-1) * d.t, y: f };
            c[1] = { $type: Point_$type, x: d.t, y: f };
            c[2] = { $type: Point_$type, x: d.w, y: h };
            c[3] = { $type: Point_$type, x: d.s, y: g };
            c[4] = { $type: Point_$type, x: d.p, y: e };
            c[5] = { $type: Point_$type, x: (-1) * d.p, y: e };
            c[6] = { $type: Point_$type, x: (-1) * d.s, y: g };
            c[7] = { $type: Point_$type, x: (-1) * d.w, y: h };
        }
        else {
            b[0] = a.i;
            b[1] = a.j;
            b[2] = a.d;
            b[3] = a.g;
            b[4] = a.f;
            b[5] = a.h;
            b[6] = a.e;
            c[0] = { $type: Point_$type, x: f, y: (-1) * d.t };
            c[1] = { $type: Point_$type, x: f, y: d.t };
            c[2] = { $type: Point_$type, x: h, y: d.w };
            c[3] = { $type: Point_$type, x: g, y: d.s };
            c[4] = { $type: Point_$type, x: e, y: d.p };
            c[5] = { $type: Point_$type, x: e, y: (-1) * d.p };
            c[6] = { $type: Point_$type, x: g, y: (-1) * d.s };
            c[7] = { $type: Point_$type, x: h, y: (-1) * d.w };
        }
    };
    LinearGraphNeedlePreparer.prototype.a = function () {
        var a = this.b;
        var b = 0.85;
        var c = 0.25;
        var d = 0.45;
        var e = a.o;
        var f = 0.5;
        var g = a.q;
        var h = a.u;
        var i = a.r;
        var j = a.v;
        var k = a.p;
        var l = a.t;
        var m = a.s;
        var n = a.w;
        if (isNaN_(g)) {
            g = c;
        }
        if (isNaN_(h)) {
            h = b;
        }
        if (isNaN_(i)) {
            if (a.c == 3) {
                i = d;
            }
            else {
                i = c;
            }
        }
        if (isNaN_(j)) {
            j = b;
        }
        if (isNaN_(l)) {
            l = e;
        }
        if (isNaN_(k)) {
            if (a.c == 4) {
                k = l * f;
            }
            else {
                k = e;
            }
        }
        if (isNaN_(m)) {
            m = e;
        }
        if (isNaN_(n)) {
            n = e;
        }
        switch (a.c) {
            case 2:
            case 1:
            case 4:
                j = h;
                i = g;
                break;
        }
        if (a.c == 3) {
            k = 0;
            m = l;
            n = l;
            j = h;
        }
        if (a.c == 2) {
            k = 0;
            m = 0;
            n = l;
        }
        if (a.c == 4) {
            m = k;
            n = l;
        }
        if (a.c == 1) {
            var o = Math.max(k, l);
            k = o;
            l = o;
            m = o;
            n = o;
        }
        a.q = g;
        a.u = h;
        a.r = i;
        a.v = j;
        a.p = k;
        a.t = l;
        a.s = m;
        a.w = n;
        return a;
    };
    LinearGraphNeedlePreparer.prototype.f = function (a) {
        a.f.k();
        a.g.k();
        a.d.k();
        a.j.k();
        a.i.k();
        a.k.k();
        a.e.k();
        a.h.k();
        a.b.k();
        a.c.k();
    };
    LinearGraphNeedlePreparer.$t = markType(LinearGraphNeedlePreparer, 'LinearGraphNeedlePreparer');
    return LinearGraphNeedlePreparer;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGraphNeedleParameters = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGraphNeedleParameters, _super);
    function LinearGraphNeedleParameters() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.d = 0;
        _this.e = false;
        _this.k = NaN;
        _this.j = NaN;
        _this.g = NaN;
        _this.l = NaN;
        _this.i = NaN;
        _this.n = NaN;
        _this.h = NaN;
        _this.m = NaN;
        _this.f = NaN;
        _this.b = 3;
        _this.propertyChanged = null;
        return _this;
    }
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "u", {
        get: function () {
            return this.k;
        },
        set: function (a) {
            if (this.k != a) {
                this.k = a;
                this.x("OuterExtent");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "q", {
        get: function () {
            return this.j;
        },
        set: function (a) {
            if (this.j != a) {
                this.j = a;
                this.x("InnerExtent");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "p", {
        get: function () {
            return this.g;
        },
        set: function (a) {
            if (this.g != a) {
                this.g = a;
                this.x("InnerBaseWidth");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "t", {
        get: function () {
            return this.l;
        },
        set: function (a) {
            if (this.l != a) {
                this.l = a;
                this.x("OuterBaseWidth");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "s", {
        get: function () {
            return this.i;
        },
        set: function (a) {
            if (this.i != a) {
                this.i = a;
                this.x("InnerPointWidth");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "w", {
        get: function () {
            return this.n;
        },
        set: function (a) {
            if (this.n != a) {
                this.n = a;
                this.x("OuterPointWidth");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "r", {
        get: function () {
            return this.h;
        },
        set: function (a) {
            if (this.h != a) {
                this.h = a;
                this.x("InnerPointExtent");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "v", {
        get: function () {
            return this.m;
        },
        set: function (a) {
            if (this.m != a) {
                this.m = a;
                this.x("OuterPointExtent");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "o", {
        get: function () {
            return this.f;
        },
        set: function (a) {
            if (this.f != a) {
                this.f = a;
                this.x("DefaultWidth");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGraphNeedleParameters.prototype, "c", {
        get: function () {
            return this.b;
        },
        set: function (a) {
            if (this.b != a) {
                this.b = a;
                this.x("NeedleShape");
            }
        },
        enumerable: true,
        configurable: true
    });
    LinearGraphNeedleParameters.prototype.a = function () {
        var a = new LinearGraphNeedleParameters();
        a.u = this.u;
        a.q = this.q;
        a.p = this.p;
        a.t = this.t;
        a.r = this.r;
        a.v = this.v;
        a.s = this.s;
        a.w = this.w;
        a.c = this.c;
        a.o = this.o;
        return a;
    };
    LinearGraphNeedleParameters.prototype.x = function (a) {
        if (this.propertyChanged != null) {
            this.propertyChanged(this, new PropertyChangedEventArgs(a));
        }
    };
    LinearGraphNeedleParameters.$t = markType(LinearGraphNeedleParameters, 'LinearGraphNeedleParameters', Base.$, [INotifyPropertyChanged_$type]);
    return LinearGraphNeedleParameters;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearScaleVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearScaleVisualData, _super);
    function LinearScaleVisualData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LinearScaleVisualData.$t = markType(LinearScaleVisualData, 'LinearScaleVisualData');
    return LinearScaleVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGaugeScaleFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGaugeScaleFrame, _super);
    function LinearGaugeScaleFrame() {
        var _this = _super.call(this) || this;
        _this.af = null;
        _this.af = new LinearGraphNeedleFrame();
        return _this;
    }
    LinearGaugeScaleFrame.prototype.y = function (a, b, c) {
        _super.prototype.y.call(this, a, b, c);
        this.af = LinearGraphNeedleFrame.a(a, 1 - a, b.af, c.af);
    };
    LinearGaugeScaleFrame.$t = markType(LinearGaugeScaleFrame, 'LinearGaugeScaleFrame', LinearGraphScaleFrame.$);
    return LinearGaugeScaleFrame;
}(LinearGraphScaleFrame));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGaugeFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGaugeFrame, _super);
    function LinearGaugeFrame() {
        var _this = _super.call(this) || this;
        _this._c = null;
        _this.c = new LinearGaugeScaleFrame();
        return _this;
    }
    LinearGaugeFrame.prototype.get_c = function () {
        return this._c;
    };
    LinearGaugeFrame.prototype.set_c = function (a) {
        this._c = a;
    };
    Object.defineProperty(LinearGaugeFrame.prototype, "c", {
        get: function () {
            return this.get_c();
        },
        set: function (a) {
            this.set_c(a);
        },
        enumerable: true,
        configurable: true
    });
    LinearGaugeFrame.$t = markType(LinearGaugeFrame, 'LinearGaugeFrame', LinearGraphFrame.$);
    return LinearGaugeFrame;
}(LinearGraphFrame));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearGaugeVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearGaugeVisualData, _super);
    function LinearGaugeVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._needlePath = null;
        _this._needle = null;
        return _this;
    }
    Object.defineProperty(LinearGaugeVisualData.prototype, "needlePath", {
        get: function () {
            return this._needlePath;
        },
        set: function (a) {
            this._needlePath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGaugeVisualData.prototype, "needle", {
        get: function () {
            return this._needle;
        },
        set: function (a) {
            this._needle = a;
        },
        enumerable: true,
        configurable: true
    });
    LinearGaugeVisualData.prototype.scaleByViewport = function () {
        _super.prototype.scaleByViewport.call(this);
        if (this.needlePath != null) {
            this.needlePath.scaleByViewport(this.viewport);
        }
    };
    LinearGaugeVisualData.prototype.serialize = function () {
        var a = _super.prototype.serialize.call(this);
        var b = new StringBuilder(0);
        var c = a.length == 0;
        if (this.needlePath != null) {
            if (c) {
                c = false;
            }
            else {
                b.l(", ");
            }
            b.l("needlePath: ");
            b.u(this.needlePath.serialize());
        }
        if (this.needle != null) {
            if (c) {
                c = false;
            }
            else {
                b.l(", ");
            }
            b.l("needle: ");
            b.u(this.needle.serialize());
        }
        if (c) {
            return a;
        }
        b.l("}");
        return a.substr(0, a.length - 1) + b.toString();
    };
    LinearGaugeVisualData.$t = markType(LinearGaugeVisualData, 'LinearGaugeVisualData', LinearGraphVisualData.$);
    return LinearGaugeVisualData;
}(LinearGraphVisualData));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearNeedleVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearNeedleVisualData, _super);
    function LinearNeedleVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = 0;
        return _this;
    }
    Object.defineProperty(LinearNeedleVisualData.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (a) {
            this._value = a;
        },
        enumerable: true,
        configurable: true
    });
    LinearNeedleVisualData.prototype.serialize = function () {
        return "{ value: " + this.value.toString() + ", type: '" + this.type + "'}";
    };
    LinearNeedleVisualData.prototype.get_type = function () {
        return "needle";
    };
    Object.defineProperty(LinearNeedleVisualData.prototype, "type", {
        get: function () {
            return this.get_type();
        },
        enumerable: true,
        configurable: true
    });
    LinearNeedleVisualData.$t = markType(LinearNeedleVisualData, 'LinearNeedleVisualData', ToolTipItemVisualData.$);
    return LinearNeedleVisualData;
}(ToolTipItemVisualData));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var XamLinearGauge = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(XamLinearGauge, _super);
    function XamLinearGauge() {
        var _this = _super.call(this) || this;
        _this.propertyChanged = null;
        _this.av = null;
        _this.bq = 0;
        _this.formatLabel = null;
        _this.alignLabel = null;
        _this.valueChanged = null;
        _this.ao = null;
        _this.an = null;
        _this.am = null;
        _this.ar = null;
        _this.bn = 0;
        _this.bm = 100;
        _this.a3 = false;
        _this.aj = null;
        _this.be = false;
        _this.a1 = null;
        _this.az = null;
        _this.ay = null;
        _this.a2 = null;
        _this.a0 = null;
        _this.bk = null;
        _this.h4 = null;
        _this._view = null;
        _this.h6 = null;
        _this.h5 = null;
        _this.h3 = null;
        _this.bg = new List$1(TextBlock.$, 0);
        _this.bj = new List$1(TextBlock.$, 0);
        _this.bi = new List$1(Path.$, 0);
        _this.bh = new List$1(Path.$, 0);
        _this.a5 = false;
        _this.bp = NaN;
        _this.bo = 1;
        _this.bp = NaN;
        _this.bo = 1;
        _this.view = new XamLinearGaugeView(_this);
        _this.view.bc();
        _this.h6 = Rect.empty;
        _this.h5 = Rect.empty;
        _this.h3 = Rect.empty;
        _this.ao = new LinearGaugeFrame();
        _this.an = new LinearGaugeFrame();
        _this.am = new LinearGaugeFrame();
        _this.ranges = new LinearGraphRangeCollection();
        _this.a5 = true;
        _this.av = new DoubleAnimator(0, 1, _this.c4);
        var a = _this.av;
        a.propertyChanged = delegateCombine(a.propertyChanged, runOn(_this, _this.e3));
        _this.ab = XamLinearGauge.$;
        _this.a0 = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.bm);
            $ret.c = runOn(_this.view, _this.view.bn);
            $ret.d = runOn(_this.view, _this.view.bo);
            $ret.j = runOn(_this.view, _this.view.co);
            return $ret;
        })());
        _this.a1 = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.bf);
            $ret.c = runOn(_this.view, _this.view.bg);
            $ret.d = runOn(_this.view, _this.view.bh);
            $ret.j = runOn(_this.view, _this.view.cn);
            return $ret;
        })());
        _this.az = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.bf);
            $ret.c = runOn(_this.view, _this.view.bg);
            $ret.d = runOn(_this.view, _this.view.bh);
            $ret.j = runOn(_this.view, _this.view.cn);
            return $ret;
        })());
        _this.ay = ((function () {
            var $ret = new StackPool$1(TextBlock.$);
            $ret.b = runOn(_this.view, _this.view.a4);
            $ret.c = runOn(_this.view, _this.view.a5);
            $ret.d = runOn(_this.view, _this.view.a6);
            $ret.j = runOn(_this.view, _this.view.b3);
            return $ret;
        })());
        _this.a2 = ((function () {
            var $ret = new StackPool$1(TextBlock.$);
            $ret.b = runOn(_this.view, _this.view.bw);
            $ret.c = runOn(_this.view, _this.view.bx);
            $ret.d = runOn(_this.view, _this.view.by);
            $ret.j = runOn(_this.view, _this.view.b4);
            return $ret;
        })());
        return _this;
    }
    XamLinearGauge.prototype.fj = function (a) {
        this.fp(a);
    };
    XamLinearGauge.prototype.fp = function (a) {
        var b = this.propertyChanged;
        if (b != null) {
            b(this, new PropertyChangedEventArgs(a));
        }
    };
    XamLinearGauge.prototype.e3 = function (a, b) {
        this.cz = this.av.o;
    };
    Object.defineProperty(XamLinearGauge.prototype, "a4", {
        get: function () {
            return this.av.f();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamLinearGauge.prototype, "cz", {
        get: function () {
            return this.bq;
        },
        set: function (a) {
            var b = this.bq;
            this.bq = a;
            this.fi("TransitionProgress", b, this.bq);
        },
        enumerable: true,
        configurable: true
    });
    XamLinearGauge.prototype.f1 = function () {
        this.bq = 0;
        this.av.w();
        this.av.v();
    };
    Object.defineProperty(XamLinearGauge.prototype, "bd", {
        get: function () {
            return this.c4 > 0;
        },
        enumerable: true,
        configurable: true
    });
    XamLinearGauge.prototype.onDetachedFromUI = function () {
        this.view.bb();
    };
    XamLinearGauge.prototype.onAttachedToUI = function () {
        this.view.a7();
    };
    Object.defineProperty(XamLinearGauge.prototype, "bs", {
        get: function () {
            return this.bn;
        },
        set: function (a) {
            this.bn = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamLinearGauge.prototype, "br", {
        get: function () {
            return this.bm;
        },
        set: function (a) {
            this.bm = a;
        },
        enumerable: true,
        configurable: true
    });
    XamLinearGauge.prototype.bx = function (a) {
        var b = 0;
        var c = a.x;
        if (this.as == 1) {
            b = a.y;
            c = this.h9.height;
        }
        return this.ar.k(c - b);
    };
    XamLinearGauge.prototype.bb = function (a) {
        if (this.bk == null) {
            return false;
        }
        return PolygonUtil.a(this.bk, a);
    };
    XamLinearGauge.prototype.needleContainsPoint = function (a, b) {
        if (this.bk == null) {
            return false;
        }
        return b ? this.h4.containsPoint(a) : PolygonUtil.a(this.bk, a);
    };
    XamLinearGauge.prototype.e7 = function (a, b) {
        var c = this.bx(a);
        c = Math.max(Math.min(c, this.br), this.bs);
        if (c != this.c0) {
            this.c0 = c;
        }
    };
    XamLinearGauge.prototype.at = function () {
        var _this = this;
        var a = new LinearGaugeVisualData();
        a.viewport = new RectData(this.h9.left, this.h9.top, this.h9.width, this.h9.height);
        a.scaleLabels = new LinearGraphScaleLabelVisualDataList();
        a.scaleTickmarks = new LinearGraphScaleTickmarkVisualDataList();
        a.ranges = new LinearGraphRangeVisualDataList();
        a.needle = ((function () {
            var $ret = new LinearNeedleVisualData();
            $ret.value = _this.c0;
            return $ret;
        })());
        this.view.az(a);
        var b = this.view.l();
        if (b != null) {
            var c_1 = null;
            switch (b.c) {
                case "range":
                    c_1 = a.ranges._inner[b.b];
                    break;
                case "needle":
                    c_1 = a.needle;
                    break;
            }
            a.toolTip = ((function () {
                var $ret = new LinearGraphToolTipVisualData();
                $ret.item = c_1;
                $ret.itemBrush = AppearanceHelper.b(b.a.brush);
                $ret.outline = AppearanceHelper.b(b.a.outline);
                $ret.thickness = b.a.thickness;
                return $ret;
            })());
        }
        return a;
    };
    XamLinearGauge.prototype.dc = function () {
        var a = this.at();
        a.scaleByViewport();
        return a.serialize();
    };
    XamLinearGauge.prototype.e8 = function () {
        this.view.flush();
    };
    XamLinearGauge.prototype.destroy = function () {
        this.provideContainer(null);
    };
    XamLinearGauge.prototype.provideContainer = function (a) {
        this.view.a9(a);
    };
    XamLinearGauge.prototype.onMouseOver = function (a, b, c) {
        if (this.be) {
            this.f0(a, null);
        }
    };
    XamLinearGauge.prototype.onMouseLeave = function () {
        if (this.be) {
            this.f0({ $type: Point_$type, x: -10000, y: -10000 }, null);
        }
    };
    XamLinearGauge.prototype.onMouseMove = function (a, b) {
        if (this.a3) {
            this.e7(a, b);
        }
    };
    XamLinearGauge.prototype.onMouseDown = function (a, b) {
        if (this.a7 && !this.a3 && this.needleContainsPoint(a, b)) {
            this.a3 = true;
        }
    };
    Object.defineProperty(XamLinearGauge.prototype, "a6", {
        get: function () {
            return this.a3;
        },
        enumerable: true,
        configurable: true
    });
    XamLinearGauge.prototype.onMouseUp = function (a) {
        if (this.a3) {
            this.a3 = false;
        }
    };
    XamLinearGauge.prototype.containerResized = function () {
        this.view.ba();
    };
    XamLinearGauge.prototype.f2 = function () {
        this.view.bv();
    };
    XamLinearGauge.prototype.f0 = function (a, b) {
        var c = this.bk;
        if (c != null && c.count > 0) {
            var d = PolygonUtil.a(c, a);
            if (d == true) {
                this.view.bu(a, b, -1, "needle");
                return;
            }
        }
        for (var e = 0; e < this.bh.count; e++) {
            var f = new PathVisualData(1, "range", this.bh._inner[e]);
            var g = f.getPoints(new GetPointsSettings());
            if (g.count > 0) {
                var h = PolygonUtil.a(this.bl(g._inner[0]), a);
                if (h == true) {
                    this.view.bu(a, b, e, "range");
                    return;
                }
            }
        }
        this.view.a2();
    };
    XamLinearGauge.prototype.fu = function () {
        if (!this.a5) {
            return;
        }
        var a = this.an.c;
        if (this.as == 0) {
            var b = 0;
            for (var c = 0; c < a.c.length; c++) {
                b = Math.max(b, a.c[c]);
            }
            var d = this.h9.height >= b ? this.h9.height - b : this.h9.height;
            this.h8 = new Rect(0, 0, 0, this.h9.width, d);
        }
        else {
            var e = 0;
            for (var f = 0; f < a.f.length; f++) {
                e = Math.max(e, a.f[f]);
            }
            var g = this.h9.width >= e ? this.h9.width - e : this.h9.width;
            this.h8 = new Rect(0, e, 0, g, this.h9.height);
        }
    };
    Object.defineProperty(XamLinearGauge.prototype, "view", {
        get: function () {
            return this._view;
        },
        set: function (a) {
            this._view = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamLinearGauge.prototype, "h9", {
        get: function () {
            return this.h6;
        },
        set: function (a) {
            var b = this.h6;
            this.h6 = a;
            if (!b.equals1(this.h6)) {
                this.fk(b, this.h6);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamLinearGauge.prototype, "h8", {
        get: function () {
            return this.h5;
        },
        set: function (a) {
            this.h5 = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamLinearGauge.prototype, "h7", {
        get: function () {
            return this.h3;
        },
        set: function (a) {
            this.h3 = a;
        },
        enumerable: true,
        configurable: true
    });
    XamLinearGauge.prototype.a9 = function () {
        return !isNaN_(this.bs) && !isNaN_(this.br) && !this.h9.isEmpty && this.view.s();
    };
    XamLinearGauge.prototype.e4 = function () {
        if (!this.a9()) {
            return;
        }
        var a = this.cr();
        this.ar = new LinearGraphScaler(this.bs, this.br, a, a + this.cp(), this.a8);
        if (this.a5) {
            if (this.a4) {
                if (this.av.g) {
                    this.av.t();
                }
                var b = this.ao;
                this.ao = this.am;
                this.am = b;
            }
            else {
                var c = this.ao;
                this.ao = this.an;
                this.an = c;
            }
        }
        else if (this.a4) {
            this.am.d(this.cz, this.ao, this.an);
            this.fv(this.am);
            this.fy(this.am);
            this.fx(this.am);
        }
        if (this.a5) {
            this.fm();
            this.fu();
            this.fn();
            this.fo();
            this.fl();
        }
        if (this.a5 && this.bd) {
            this.f1();
            this.am.d(this.cz, this.ao, this.an);
            this.fv(this.am);
            this.fy(this.am);
            this.fx(this.am);
            this.fz(this.am);
            this.fw(this.am);
        }
        else {
            if (this.a5) {
                this.fv(this.an);
                this.fy(this.an);
                this.fx(this.an);
                this.fz(this.an);
                this.fw(this.an);
            }
        }
        this.a5 = false;
        this.view.as();
    };
    XamLinearGauge.prototype.fo = function () {
        var a = this.an;
        var b = a.c;
        var c = this.ar;
        var d = this.b5;
        var e = this.h8;
        b.u = this.cs;
        b.r = this.cn;
        b.s = this.co;
        b.t = this.cq;
        b.m.clear();
        for (var f = 0; f < this.ranges.count; f++) {
            var g = this.ranges._inner[f];
            if (g.j <= this.bs || g.o > this.br) {
                continue;
            }
            var h = g.o;
            var i = g.j;
            if (h < this.bs) {
                h = this.bs;
            }
            if (i > this.br) {
                i = this.br;
            }
            var j = new LinearGraphRectFrame();
            j.i = g.an != null ? g.an : this.hv(f, this.ah);
            j.j = g.ao != null ? g.ao : this.hv(f, this.ai);
            j.h = g.p;
            j.g = c.i(h);
            j.d = c.i(i);
            j.e = g.l;
            j.b = g.k;
            j.f = g.n;
            j.c = g.m;
            if (isNaN_(j.e)) {
                j.e = this.ck;
            }
            j.b = g.k;
            if (isNaN_(j.b)) {
                j.b = this.ck;
            }
            j.f = g.n;
            if (isNaN_(j.f)) {
                j.f = this.cl;
            }
            j.c = g.m;
            if (isNaN_(j.c)) {
                j.c = this.cl;
            }
            b.m.add(j);
        }
        b.ab = this.hu;
        b.ad = this.h1;
        b.x = this.cy;
        b.w = this.cx;
        b.v = this.cu;
        b.ac = this.hw;
        b.q = this.b8;
        b.p = this.b7;
        b.o = this.b6;
        var k = this.by;
        if (isNaN_(k)) {
            k = (this.br - this.bs) / 10;
        }
        if (k == 0) {
            k = this.br - this.bs;
        }
        var l = new List$1(Number_$type, 0);
        var m = new List$1(Number_$type, 0);
        if (k > 0) {
            var n = this.bs + this.cv;
            var o = this.br - this.cw;
            var p = 100000;
            var q = Math.abs(o - n) / p;
            if (k >= q) {
                for (var r = n; r <= o || this.bf(r, o, k); r = r + k) {
                    l.add(c.i(r));
                    for (var s = 0; s < d; s++) {
                        var t = (k / (d + 1)) * (s + 1);
                        if (t + r > o) {
                            continue;
                        }
                        m.add(c.i(t + r));
                    }
                }
            }
        }
        if (b.j.length != l.count || b.i.length != m.count) {
            b.j = new Array(l.count);
            b.i = new Array(m.count);
        }
        for (var u = 0; u < l.count; u++) {
            b.j[u] = l._inner[u];
        }
        for (var v = 0; v < m.count; v++) {
            b.i[v] = m._inner[v];
        }
    };
    XamLinearGauge.prototype.ia = function () {
        var a = this.by;
        var b = this.b0;
        if (isNaN_(a)) {
            a = (this.br - this.bs) / 10;
        }
        if (isNaN_(b)) {
            b = a;
        }
        if (b == 0) {
            b = this.br - this.bs;
        }
        var c = new List$1(Number_$type, 0);
        if (b > 0) {
            var d = this.b1 + this.bs;
            var e = this.br - this.b2;
            var f = 100000;
            var g = Math.abs(e - d) / f;
            if (b >= g) {
                for (var h = d; h <= e || this.bf(h, e, a); h += b) {
                    c.add(h);
                }
            }
        }
        var i = new Array(c.count);
        var j = new Array(c.count);
        var _loop_1 = function (k) {
            var l = c._inner[k];
            if (this_1.formatLabel == null && this_1.aj == null) {
                l = (Math.round(l * 100) / 100);
            }
            var m = l.toString();
            if (this_1.aj != null) {
                m = this_1.aj.i(l);
            }
            var n = new FormatLinearGraphLabelEventArgs();
            n.value = l;
            n.label = m;
            if (this_1.formatLabel != null) {
                this_1.formatLabel(this_1, n);
            }
            m = n.label;
            var o = this_1.view.cp(((function () {
                var $ret = new TextBlock();
                $ret.ak = m;
                return $ret;
            })()));
            i[k] = o.width;
            j[k] = o.height;
        };
        var this_1 = this;
        for (var k = 0; k < c.count; k++) {
            _loop_1(k);
        }
        var p = 0;
        var q = 0;
        var r = 1 - this.cn + this.cs;
        if (this.as == 0) {
            for (var s = 0; s < j.length; s++) {
                q = Math.max(q, j[s]);
            }
            for (var t = 0; t < i.length; t++) {
                p += i[t];
            }
            if (i.length > 0) {
                p += i[0] / 2;
            }
            if (i.length > 1) {
                p += i[i.length - 1] / 2;
            }
            if (i.length > 0) {
                p += (i.length - 1) * 5;
            }
            if (r > 0) {
                p = p / Math.abs(1 - r);
            }
        }
        else {
            for (var u = 0; u < i.length; u++) {
                p = Math.max(p, i[u]);
            }
            for (var v = 0; v < j.length; v++) {
                q += j[v];
            }
            if (j.length > 0) {
                q -= j[0] / 2;
            }
            if (j.length > 1) {
                q -= j[j.length - 1] / 2;
            }
            if (r > 0) {
                q = q / Math.abs(1 - r);
            }
            if (j.length > 0) {
                q += (j.length - 1) * 5;
            }
        }
        return new Size(1, p, q);
    };
    XamLinearGauge.prototype.fm = function () {
        var a = this.an;
        var b = a.c;
        var c = this.ar;
        var d = this.by;
        var e = this.b0;
        var f = this.b5;
        if (isNaN_(d)) {
            d = (this.br - this.bs) / 10;
        }
        if (isNaN_(e)) {
            e = d;
        }
        if (e == 0) {
            e = this.br - this.bs;
        }
        var g = new List$1(Tuple$2.$.specialize(Number_$type, Number_$type), 0);
        if (e > 0) {
            var h = this.b1 + this.bs;
            var i = this.br - this.b2;
            var j = 100000;
            var k = Math.abs(i - h) / j;
            if (e >= k) {
                for (var l = h; l <= i || this.bf(l, i, e); l = l + e) {
                    g.add(new Tuple$2(Number_$type, Number_$type, l, c.i(l)));
                }
            }
        }
        if (b.d.length != g.count) {
            b.e = new Array(g.count);
            b.d = new Array(g.count);
            b.f = new Array(g.count);
            b.c = new Array(g.count);
            b.g = new Array(g.count);
            b.h = new Array(g.count);
        }
        b.n = this.bz;
        var m = new FormatLinearGraphLabelEventArgs();
        m.actualMinimumValue = this.bs;
        m.actualMaximumValue = this.br;
        var n = new AlignLinearGraphLabelEventArgs();
        n.actualMinimumValue = this.bs;
        n.actualMaximumValue = this.br;
        var _loop_2 = function (o) {
            var p = g._inner[o].c;
            if (this_2.formatLabel == null) {
                p = (Math.round(p * 100) / 100);
            }
            var q = (p).toString();
            if (this_2.aj != null) {
                q = this_2.aj.i(p);
            }
            m.value = p;
            n.value = p;
            m.label = q;
            if (this_2.formatLabel != null) {
                this_2.formatLabel(this_2, m);
            }
            q = m.label;
            n.label = q;
            var r = this_2.view.cp(((function () {
                var $ret = new TextBlock();
                $ret.ak = q;
                return $ret;
            })()));
            n.width = r.width;
            n.height = r.height;
            if (this_2.as == 0) {
                n.offsetX = -1 * (r.width / 2);
                n.offsetY = -1 * (r.height);
            }
            else {
                n.offsetX = -1 * r.width;
                n.offsetY = -1 * (r.height / 2);
            }
            if (this_2.alignLabel != null) {
                this_2.alignLabel(this_2, n);
            }
            b.f[o] = n.width;
            b.c[o] = n.height;
            b.g[o] = n.offsetX;
            ;
            b.h[o] = n.offsetY;
            b.d[o] = q;
            b.e[o] = g._inner[o].d;
        };
        var this_2 = this;
        for (var o = 0; o < g.count; o++) {
            _loop_2(o);
        }
    };
    XamLinearGauge.prototype.bf = function (a, b, c) {
        var d = c / 10000;
        if (isNaN_(d)) {
            d = 1E-05;
        }
        var e = Math.abs(a - b);
        if (e < d) {
            return true;
        }
        return false;
    };
    XamLinearGauge.prototype.fl = function () {
        var a = this.an;
        var b = a.a;
        b.e = this.hs;
        b.f = this.ht;
        b.c = this.bw;
        b.a = this.bu;
        b.b = this.bv;
    };
    XamLinearGauge.prototype.fn = function () {
        var a = this.c0;
        if (isNaN_(a)) {
            return;
        }
        var b = this.an.c;
        var c = this.ar;
        var d = new LinearGraphNeedleParameters();
        d.c = this.ap;
        d.e = this.a8;
        d.d = this.as;
        d.u = this.cf;
        d.q = this.cb;
        d.v = this.cg;
        d.r = this.cc;
        d.t = this.ce;
        d.p = this.ca;
        d.s = this.cd;
        d.w = this.ch;
        d.o = this.b9 * 0.5 / this.cm();
        var e = new LinearGraphNeedleFrame();
        e.r = this.hx;
        e.s = this.hy;
        e.o = this.ci;
        var f = new LinearGraphNeedlePreparer();
        f.b = d;
        f.c(e);
        e.l = -90;
        var g = c.i(a);
        e.p = g;
        b.af = e;
    };
    XamLinearGauge.prototype.hv = function (a, b) {
        if (b != null && b.count > 0) {
            return b.item(a % b.count);
        }
        else {
            return null;
        }
    };
    XamLinearGauge.prototype.fz = function (a) {
        var b = this.h8;
        var c = a.c;
        var d = this.a1;
        var e = c.j;
        var f = c.w;
        var g = c.v;
        var h = c.ad;
        var i = c.x;
        var j = this.az;
        var k = c.i;
        var l = c.p;
        var m = c.o;
        var n = c.ac;
        var o = c.q;
        d.f = true;
        for (var p = 0; p < this.bi.count; p++) {
            d.n(this.bi._inner[p]);
        }
        this.bi.clear();
        var q = this.cm();
        var r = this.c2();
        var _loop_3 = function (s) {
            var t = void 0, u = void 0, v, w;
            if (this_3.as == 1) {
                t = b.left + q * f;
                u = r - e[s];
                v = b.left + q * g;
                w = u;
            }
            else {
                t = b.left + e[s];
                u = q * (1 - f);
                v = t;
                w = q * (1 - g);
            }
            var x = d.a();
            var y = new PathGeometry();
            var z = new PathFigure();
            z._startPoint = { $type: Point_$type, x: t, y: u };
            z._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: v, y: w };
                return $ret;
            })()));
            y.c.add(z);
            x.ak = y;
            x._stroke = h;
            x.ac = i;
            this_3.bi.add(x);
        };
        var this_3 = this;
        for (var s = 0; s < e.length; s++) {
            _loop_3(s);
        }
        var _loop_4 = function (aa) {
            var ab = void 0, ac = void 0, ad, ae;
            if (this_4.as == 1) {
                ab = b.left + q * l;
                ac = r - k[aa];
                ad = b.left + q * m;
                ae = ac;
            }
            else {
                ab = k[aa];
                ac = q * (1 - l);
                ad = ab;
                ae = q * (1 - m);
            }
            var af = d.a();
            var ag = new PathGeometry();
            var ah = new PathFigure();
            ah._startPoint = { $type: Point_$type, x: ab, y: ac };
            ah._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: ad, y: ae };
                return $ret;
            })()));
            ag.c.add(ah);
            af.ak = ag;
            af._stroke = n;
            af.ac = o;
            this_4.bi.add(af);
        };
        var this_4 = this;
        for (var aa = 0; aa < k.length; aa++) {
            _loop_4(aa);
        }
        d.f = false;
    };
    XamLinearGauge.prototype.fw = function (a) {
        var b = this.h8;
        var c = a.c;
        var d = c.e;
        var e = c.d;
        var f = c.g;
        var g = c.h;
        var h = c.f;
        var i = c.c;
        var j = c.n;
        var k = this.ay;
        k.f = true;
        for (var l = 0; l < this.bg.count; l++) {
            k.n(this.bg._inner[l]);
        }
        this.bg.clear();
        var m = c.ab;
        var n = this.c1();
        var o = this.c2();
        for (var p = 0; p < e.length; p++) {
            var q = void 0, r = void 0;
            if (this.as == 1) {
                q = b.left + n * j;
                r = b.top + o - d[p];
            }
            else {
                q = b.left + d[p];
                r = b.top + n * (1 - j);
            }
            var s = k.a();
            s.ak = e[p];
            this.view.bt(s, m);
            var t = h[p];
            var u = i[p];
            var v = f[p];
            var w = g[p];
            this.view.bk(s, q + v, r + w);
            this.bg.add(s);
        }
        k.f = false;
    };
    XamLinearGauge.prototype.fy = function (a) {
        var b = a.c;
        var c = this.a0;
        c.f = true;
        for (var d = 0; d < this.bh.count; d++) {
            c.n(this.bh._inner[d]);
        }
        this.bh.clear();
        var e = this.cm();
        var f = this.c2();
        var g = this.h2();
        var h = this.view.cm();
        if (isNaN_(b.s) || isNaN_(b.t) || isNaN_(b.u) || isNaN_(b.r)) {
            h.ak = null;
        }
        else {
            var i = this.cp();
            h.ak = b.ae(g, e, i, this.as);
            h._fill = this.hz;
            h._stroke = this.h0;
            h.ac = this.ct;
        }
        for (var j = 0; j < b.m.count; j++) {
            var k = b.m._inner[j];
            var l = c.a();
            l.ak = k.k(g, e, f, this.as);
            l._fill = k.i;
            l._stroke = k.j;
            l.ac = k.h;
            this.bh.add(l);
        }
        this.view.bs(this.bh);
        c.f = false;
    };
    XamLinearGauge.prototype.fv = function (a) {
        var b = this.h7;
        var c = this.view.ck();
        var d = a.a;
        var e = this.as == 0 ? b.height : b.width;
        var f = this.as == 0 ? b.width : b.height;
        var g = d.g(e, f, this.as);
        c.ak = g;
        c._fill = d.e;
        c._stroke = d.f;
        c.ac = d.c;
    };
    XamLinearGauge.prototype.bl = function (a) {
        var b = new List$1(Point_$type, 0);
        for (var c = 0; c < a.count; c++) {
            b.add({ $type: Point_$type, x: a._inner[c].x, y: a._inner[c].y });
        }
        return b;
    };
    XamLinearGauge.prototype.fx = function (a) {
        this.bk = null;
        var b = this.view.cl();
        var c = this.c0;
        if (isNaN_(c) || c < this.bs || c > this.br) {
            b.ak = null;
            return;
        }
        var d = a.c;
        var e = d.af;
        var f = this.cm();
        var g = this.c2();
        var h = f;
        var i = e.p;
        var j = 0;
        if (this.as == 1) {
            i = this.h8.left;
            j = g - e.p;
        }
        b.ak = e.t(h, i, j);
        b._fill = e.r;
        b._stroke = e.s;
        b.ac = e.o;
        var k = new PathVisualData(1, "needle", b);
        var l = k.getPoints(new GetPointsSettings());
        if (l.count > 0) {
            this.bk = this.bl(l._inner[0]);
            var m = 1.7976931348623157E+308, n = 1.7976931348623157E+308;
            var o = -1.7976931348623157E+308, p = -1.7976931348623157E+308;
            for (var q = 0; q < this.bk.count; q++) {
                m = this.bk._inner[q].x < m ? this.bk._inner[q].x : m;
                n = this.bk._inner[q].y < n ? this.bk._inner[q].y : n;
                o = this.bk._inner[q].x > o ? this.bk._inner[q].x : o;
                p = this.bk._inner[q].y > p ? this.bk._inner[q].y : p;
            }
            this.h4 = new Rect(2, { $type: Point_$type, x: m, y: n }, { $type: Point_$type, x: o, y: p });
        }
    };
    XamLinearGauge.prototype.fk = function (a, b) {
        this.a5 = true;
        this.view.br();
    };
    XamLinearGauge.prototype.fc = function (a, b) {
        this.a5 = true;
        this.view.br();
    };
    XamLinearGauge.prototype.cm = function () {
        if (this.as == 0) {
            return this.ba ? this.h9.height : this.h8.height;
        }
        return this.ba ? this.h9.width : this.h8.width;
    };
    XamLinearGauge.prototype.cp = function () {
        if (this.as == 0) {
            return this.h9.width * (this.cn - this.cs);
        }
        return this.h9.height * (this.cn - this.cs);
    };
    XamLinearGauge.prototype.c1 = function () {
        if (this.as == 0) {
            return this.h9.height;
        }
        return this.h9.width;
    };
    XamLinearGauge.prototype.c2 = function () {
        if (this.as == 0) {
            return this.h9.width;
        }
        return this.h9.height;
    };
    XamLinearGauge.prototype.cr = function () {
        var a = this.cs;
        if (this.as == 0) {
            if (this.a8) {
                a = 1 - this.cn;
            }
            return this.h9.left + this.h9.width * a;
        }
        if (this.a8) {
            a = 1 - this.cn;
        }
        return this.h9.top + this.h9.height * a;
    };
    XamLinearGauge.prototype.h2 = function () {
        var a = this.h8.left;
        if (this.ba) {
            a = 0;
        }
        var b = this.cs;
        if (this.as == 0) {
            if (this.a8) {
                b = 1 - this.cn;
            }
            return { $type: Point_$type, x: a + this.h8.width * b, y: this.h8.top };
        }
        if (!this.a8) {
            b = 1 - this.cn;
        }
        return { $type: Point_$type, x: a, y: this.h8.top + this.h8.height * b };
    };
    XamLinearGauge.prototype.fi = function (a, b, c) {
        switch (a) {
            case XamLinearGauge.$$p[0]:
            case XamLinearGauge.$$p[3]:
            case XamLinearGauge.$$p[44]:
            case XamLinearGauge.$$p[48]:
            case XamLinearGauge.$$p[52]:
            case XamLinearGauge.$$p[19]:
            case XamLinearGauge.$$p[25]:
            case XamLinearGauge.$$p[35]:
                this.view.a8(a, b, c);
                break;
            case XamLinearGauge.$$p[39]:
                this.view.bd(b, c);
                break;
            case XamLinearGauge.$$p[42]:
                this.view.be(b, c);
                break;
            case "PixelScalingRatio":
                if (isNaN_(DeviceUtils.a(this.cj))) {
                    this.bt = 1;
                }
                else {
                    this.bt = DeviceUtils.a(this.cj);
                }
                break;
            case "ActualPixelScalingRatio":
                this.view.bi();
                break;
        }
        switch (a) {
            case XamLinearGauge.$$p[11]:
            case XamLinearGauge.$$p[12]:
                if (this.dk != null) {
                    this.aj = new BindingFormatter();
                    this.aj.j = this.dk;
                    this.aj.d = this.ag;
                }
                else {
                    this.aj = null;
                }
                this.a5 = true;
                this.view.br();
                break;
            case XamLinearGauge.$$p[60]:
                if (this.valueChanged != null) {
                    this.valueChanged(this, new DoubleValueChangedEventArgs(b, c));
                }
                this.a5 = true;
                this.view.br();
                break;
            case XamLinearGauge.$$p[59]:
                this.av.r = this.c4;
                this.view.br();
                break;
            case "TransitionProgress":
                if (this.cz >= 1) {
                    this.av.w();
                    var d = this.an;
                    this.an = this.ao;
                    this.ao = d;
                    this.fm();
                    this.fn();
                    this.fo();
                    this.fl();
                    this.fv(this.an);
                    this.fy(this.an);
                    this.fx(this.an);
                    this.fz(this.an);
                    this.fw(this.an);
                }
                this.am.d(this.cz, this.ao, this.an);
                this.fv(this.am);
                this.fy(this.am);
                this.fx(this.am);
                this.fz(this.am);
                this.fw(this.am);
                this.view.as();
                break;
            case XamLinearGauge.$$p[25]:
            case XamLinearGauge.$$p[30]:
            case XamLinearGauge.$$p[24]:
            case XamLinearGauge.$$p[36]:
            case XamLinearGauge.$$p[27]:
            case XamLinearGauge.$$p[32]:
            case XamLinearGauge.$$p[28]:
            case XamLinearGauge.$$p[33]:
            case XamLinearGauge.$$p[26]:
            case XamLinearGauge.$$p[31]:
            case XamLinearGauge.$$p[29]:
            case XamLinearGauge.$$p[34]:
            case XamLinearGauge.$$p[37]:
            case XamLinearGauge.$$p[35]:
            case XamLinearGauge.$$p[0]:
            case XamLinearGauge.$$p[3]:
            case XamLinearGauge.$$p[4]:
            case XamLinearGauge.$$p[1]:
            case XamLinearGauge.$$p[2]:
            case XamLinearGauge.$$p[44]:
            case XamLinearGauge.$$p[48]:
            case XamLinearGauge.$$p[50]:
            case XamLinearGauge.$$p[46]:
            case XamLinearGauge.$$p[47]:
            case XamLinearGauge.$$p[52]:
            case XamLinearGauge.$$p[19]:
            case XamLinearGauge.$$p[39]:
            case XamLinearGauge.$$p[42]:
            case XamLinearGauge.$$p[40]:
            case XamLinearGauge.$$p[41]:
            case XamLinearGauge.$$p[7]:
            case XamLinearGauge.$$p[13]:
            case XamLinearGauge.$$p[10]:
            case XamLinearGauge.$$p[14]:
            case XamLinearGauge.$$p[15]:
            case XamLinearGauge.$$p[54]:
            case XamLinearGauge.$$p[55]:
            case XamLinearGauge.$$p[56]:
            case XamLinearGauge.$$p[53]:
            case XamLinearGauge.$$p[57]:
            case XamLinearGauge.$$p[22]:
            case XamLinearGauge.$$p[21]:
            case XamLinearGauge.$$p[20]:
            case XamLinearGauge.$$p[23]:
                this.a5 = true;
                this.view.br();
                break;
            case XamLinearGauge.$$p[43]:
                var e = b;
                var f = c;
                if (e != null) {
                    var g = e;
                    g.collectionChanged = delegateRemove(g.collectionChanged, runOn(this, this.fs));
                }
                if (f != null) {
                    var h = f;
                    h.collectionChanged = delegateCombine(h.collectionChanged, runOn(this, this.fs));
                }
                this.a5 = true;
                this.view.br();
                break;
            case XamLinearGauge.$$p[38]:
            case XamLinearGauge.$$p[9]:
            case XamLinearGauge.$$p[18]:
            case XamLinearGauge.$$p[16]:
            case XamLinearGauge.$$p[45]:
            case XamLinearGauge.$$p[49]:
                this.bs = Math.min(this.b4, this.b3);
                this.br = Math.max(this.b4, this.b3);
                var i = this.cr();
                this.ar = new LinearGraphScaler(this.bs, this.br, i, i + this.cp(), this.a8);
                this.a5 = true;
                this.view.br();
                break;
            case XamLinearGauge.$$p[5]:
            case XamLinearGauge.$$p[6]:
                this.view.b1();
                this.a5 = true;
                this.view.br();
                break;
        }
        this.fj(a);
    };
    XamLinearGauge.prototype.fs = function (a, b) {
        var e_1, _a, e_2, _b;
        if (b.oldItems != null) {
            try {
                for (var _c = __values(fromEn(b.oldItems)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var c = _d.value;
                    c.propertyChanged = delegateRemove(c.propertyChanged, runOn(this, this.fr));
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return))
                        _a.call(_c);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        }
        if (b.newItems != null) {
            try {
                for (var _e = __values(fromEn(b.newItems)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var d = _f.value;
                    d.propertyChanged = delegateCombine(d.propertyChanged, runOn(this, this.fr));
                }
            }
            catch (e_2_1) {
                e_2 = { error: e_2_1 };
            }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return))
                        _b.call(_e);
                }
                finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
        }
        this.a5 = true;
        this.view.br();
    };
    XamLinearGauge.prototype.fr = function (a, b) {
        this.a5 = true;
        this.view.br();
    };
    XamLinearGauge.prototype.e9 = function (a, b) {
        this.a5 = true;
        this.view.br();
    };
    XamLinearGauge.prototype.refresh = function () {
        this.a5 = true;
        this.view.br();
    };
    XamLinearGauge.prototype.ax = function () {
        return FontUtil.toFontInfo(this.view.ah, this.dd);
    };
    Object.defineProperty(XamLinearGauge.prototype, "cj", {
        get: function () {
            return this.bp;
        },
        set: function (a) {
            var b = this.bp;
            this.bp = a;
            this.fi("PixelScalingRatio", b, this.bp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamLinearGauge.prototype, "bt", {
        get: function () {
            return this.bo;
        },
        set: function (a) {
            var b = this.bo;
            this.bo = a;
            this.fi("ActualPixelScalingRatio", b, this.bo);
        },
        enumerable: true,
        configurable: true
    });
    XamLinearGauge.$t = markType(XamLinearGauge, 'XamLinearGauge', Control.$, [INotifyPropertyChanged_$type]);
    XamLinearGauge.$$p = markDep(DependencyProperty, PropertyMetadata, XamLinearGauge, 'fi', ['BackingBrush:hs:f3', [Brush.$, null], 'BackingInnerExtent:bu:f4', [1, 0], 'BackingOuterExtent:bv:f5', [1, 1], 'BackingOutline:ht:f6', [Brush.$, null], 'BackingStrokeThickness:bw:f7', [1, 2], 'FontBrush:hu:f8', [Brush.$, null], 'Font:dd:f9', [2, null], 'Interval:by:ga', [1, NaN], 'IsNeedleDraggingEnabled:a7:gb', [0, false], 'IsScaleInverted:a8:gc', [0, false], 'LabelExtent:bz:gd', [1, 0], 'LabelFormat:dk:ge', [2, null], 'LabelFormatSpecifiers:ag:gf', [Array_$type, null], 'LabelInterval:b0:gg', [1, NaN], 'LabelsPostInitial:b1:gh', [1, 0], 'LabelsPreTerminal:b2:gi', [1, 0], 'MaximumValue:b3:gj', [1, 100], 'MergeViewPorts:ba:gk', [0, false], 'MinimumValue:b4:gl', [1, 0], 'MinorTickBrush:hw:gm', [Brush.$, null], 'MinorTickCount:b5:gn', [1, 4], 'MinorTickEndExtent:b6:go', [1, 0.35], 'MinorTickStartExtent:b7:gp', [1, 0.05], 'MinorTickStrokeThickness:b8:gq', [1, 1], 'NeedleBreadth:b9:gr', [1, 6], 'NeedleBrush:hx:gs', [Brush.$, null], 'NeedleInnerBaseWidth:ca:gt', [1, NaN], 'NeedleInnerExtent:cb:gu', [1, NaN], 'NeedleInnerPointExtent:cc:gv', [1, NaN], 'NeedleInnerPointWidth:cd:gw', [1, NaN], 'NeedleName:d5:gx', [2, null], 'NeedleOuterBaseWidth:ce:gy', [1, NaN], 'NeedleOuterExtent:cf:gz', [1, NaN], 'NeedleOuterPointExtent:cg:g0', [1, NaN], 'NeedleOuterPointWidth:ch:g1', [1, NaN], 'NeedleOutline:hy:g2', [Brush.$, null], 'NeedleShape:ap:g3', [LinearGraphNeedleShape_$type, enumGetBox(LinearGraphNeedleShape_$type, 3)], 'NeedleStrokeThickness:ci:g4', [1, 1], 'Orientation:as:g5', [LinearScaleOrientation_$type, enumGetBox(LinearScaleOrientation_$type, 0)], 'RangeBrushes:ah:g6', [BrushCollection.$, null], 'RangeInnerExtent:ck:g7', [1, 0.05], 'RangeOuterExtent:cl:g8', [1, 0.65], 'RangeOutlines:ai:g9', [BrushCollection.$, null], 'Ranges::ha', [LinearGraphRangeCollection.$, null], 'ScaleBrush:hz:hb', [Brush.$, null], 'ScaleEndExtent:cn:hc', [1, 0.95], 'ScaleInnerExtent:co:hd', [1, 0.05], 'ScaleOuterExtent:cq:he', [1, 0.65], 'ScaleOutline:h0:hf', [Brush.$, null], 'ScaleStartExtent:cs:hg', [1, 0.05], 'ScaleStrokeThickness:ct:hh', [1, 1], 'ShowToolTipTimeout:c3:hi', [1, 500], 'TickBrush:h1:hj', [Brush.$, null], 'TickEndExtent:cu:hk', [1, 0.65], 'TicksPostInitial:cv:hl', [1, 0], 'TicksPreTerminal:cw:hm', [1, 0], 'TickStartExtent:cx:hn', [1, 0.05], 'TickStrokeThickness:cy:ho', [1, 2], 'ToolTip::hp', [4, null], 'TransitionDuration:c4:hq', [1, 0], 'Value:c0:hr', [1, NaN]]);
    return XamLinearGauge;
}(Control));
/**
 * @hidden
 */
var XamLinearGaugeView = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(XamLinearGaugeView, _super);
    function XamLinearGaugeView(a) {
        var _this = _super.call(this) || this;
        _this.ap = 0;
        _this.ao = 0;
        _this.m = null;
        _this.i = null;
        _this.aj = null;
        _this.p = null;
        _this.ah = null;
        _this.aa = null;
        _this.z = null;
        _this.y = null;
        _this.ab = null;
        _this.ci = null;
        _this.cj = null;
        _this.ch = null;
        _this.ca = null;
        _this.cb = null;
        _this.b7 = null;
        _this.b8 = null;
        _this.cc = null;
        _this.cd = null;
        _this.ce = null;
        _this.b9 = null;
        _this.c = null;
        _this.d = null;
        _this.e = null;
        _this.f = null;
        _this.q = false;
        _this.v = null;
        _this.a = ["needle", "backing", "scale", "tick", "minortick", "label"];
        _this.u = false;
        _this.t = false;
        _this.ai = null;
        _this.k = null;
        _this.ak = 0;
        _this.am = 0;
        _this.aq = null;
        _this.an = -1;
        _this.cf = null;
        _this.al = 0;
        _this.x = null;
        _this.b6 = ((function () {
            var $ret = new Brush();
            $ret.fill = "black";
            return $ret;
        })());
        _this.r = false;
        _this.n = null;
        _this.b5 = null;
        _this.ac = 0;
        _this.ad = 1;
        _this.m = a;
        _this.v = new Dictionary$2(String_$type, Dictionary$2.$.specialize(String_$type, Brush.$), 0);
        _this.ci = new Path();
        _this.cj = new Path();
        _this.ch = new Path();
        _this.aa = new List$1(Path.$, 0);
        _this.z = new List$1(Path.$, 0);
        _this.y = new List$1(TextBlock.$, 0);
        _this.ab = new List$1(TextBlock.$, 0);
        return _this;
    }
    XamLinearGaugeView.prototype.a3 = function () {
        var a = this.m.cj;
        var b = this.m.bt;
        if (!isNaN_(a) && a != 0) {
            return;
        }
        if (window.devicePixelRatio != undefined && window.devicePixelRatio != b) {
            this.m.bt = window.devicePixelRatio;
        }
    };
    XamLinearGaugeView.prototype.bc = function () {
        this.k = new LinearGraphTooltipDataContext();
        this.al = this.m.c3;
        this.a3();
    };
    XamLinearGaugeView.prototype.s = function () {
        return true;
    };
    XamLinearGaugeView.prototype.cl = function () {
        return this.ci;
    };
    XamLinearGaugeView.prototype.cm = function () {
        return this.cj;
    };
    XamLinearGaugeView.prototype.ck = function () {
        return this.ch;
    };
    XamLinearGaugeView.prototype.a1 = function () {
        this.q = true;
        var a = ["#778899", "#EBEDEF", "#e0e0e0", "#617583", "rgba(100,107,114,.74)", "rgba(100,107,114,.74)"];
        var b = ["#778899", "#B2B9C0", "#e0e0e0", null, null, null];
        var c = ((function () {
            var $ret = new List$1(Array_$type, 0);
            $ret.add(a);
            $ret.add(b);
            return $ret;
        })());
        this.v.clear();
        var d = this.a.length;
        var _loop_5 = function (e) {
            var f = this_5.a[e];
            var g = "ui-lineargauge-" + f;
            var h = "ui-lineargauge-" + f + "-fill";
            var i = "ui-lineargauge-" + f + "-outline";
            var j;
            if (!((function () { var k = XamLinearGaugeView.w.tryGetValue(h, j); j = k.p1; return k.ret; })())) {
                j = BrushUtil.j(h, g, "background-color", this_5.ah, a[e]);
                XamLinearGaugeView.w.addItem(h, j);
            }
            var k;
            if (!((function () { var l = XamLinearGaugeView.w.tryGetValue(i, k); k = l.p1; return l.ret; })())) {
                k = BrushUtil.j(i, g, "border-top-color", this_5.ah, b[e]);
                XamLinearGaugeView.w.addItem(i, k);
            }
            var l = new Dictionary$2(String_$type, Brush.$, 0);
            l.item("fill", j);
            l.item("outline", k);
            this_5.v.item(this_5.a[e], l);
        };
        var this_5 = this;
        for (var e = 0; e < d; e++) {
            _loop_5(e);
        }
        this.b0();
        if (XamLinearGaugeView.g == null || XamLinearGaugeView.h == null) {
            var m = BrushUtil.f("ui-lineargauge-range-fill-palette-", "ui-lineargauge-range-outline-palette-", "ui-lineargauge-range-palette-", this.ah, XamLinearGaugeView.g, XamLinearGaugeView.h, ["#216E99", "#216E99", "#44acd6", "#44acd6", "#cecece", "#cecece"]);
            XamLinearGaugeView.g = m.p4;
            XamLinearGaugeView.h = m.p5;
        }
        this.c = XamLinearGaugeView.g;
        this.d = XamLinearGaugeView.h;
        if (this.e == null) {
            this.m.ah = this.c;
        }
        if (this.f == null) {
            this.m.ai = this.d;
        }
        this.q = false;
    };
    XamLinearGaugeView.prototype.b0 = function () {
        this.q = true;
        var a = this.a.length;
        for (var b = 0; b < a; b++) {
            var c = this.a[b];
            this.bz(c, this.v.item(c));
        }
        this.q = false;
    };
    XamLinearGaugeView.prototype.bz = function (a, b) {
        var c = b.item("fill");
        var d = b.item("outline");
        switch (a) {
            case "needle":
                if (this.ca == null) {
                    this.m.hx = c;
                }
                if (this.cb == null) {
                    this.m.hy = d;
                }
                break;
            case "scale":
                if (this.cc == null) {
                    this.m.hz = c;
                }
                if (this.cd == null) {
                    this.m.h0 = d;
                }
                break;
            case "backing":
                if (this.b7 == null) {
                    this.m.hs = c;
                }
                if (this.b8 == null) {
                    this.m.ht = d;
                }
                break;
            case "tick":
                if (this.ce == null) {
                    this.m.h1 = c;
                }
                break;
            case "minortick":
                if (this.b9 == null) {
                    this.m.hw = c;
                }
                break;
            case "label":
                this.b6 = c;
                break;
        }
    };
    XamLinearGaugeView.prototype.a8 = function (a, b, c) {
        var d = b;
        var e = c;
        if (!this.q) {
            switch (a) {
                case XamLinearGauge.$$p[25]:
                    this.ca = e;
                    break;
                case XamLinearGauge.$$p[35]:
                    this.cb = e;
                    break;
                case XamLinearGauge.$$p[0]:
                    this.b7 = e;
                    break;
                case XamLinearGauge.$$p[3]:
                    this.b8 = e;
                    break;
                case XamLinearGauge.$$p[44]:
                    this.cc = e;
                    break;
                case XamLinearGauge.$$p[48]:
                    this.cd = e;
                    break;
                case XamLinearGauge.$$p[52]:
                    this.ce = e;
                    break;
                case XamLinearGauge.$$p[19]:
                    this.b9 = e;
                    break;
            }
            if (e == null) {
                this.b0();
            }
        }
    };
    XamLinearGaugeView.prototype.bd = function (a, b) {
        if (!this.q) {
            this.e = b;
            if (this.e == null) {
                this.m.ah = this.c;
            }
        }
    };
    XamLinearGaugeView.prototype.be = function (a, b) {
        if (!this.q) {
            this.f = b;
            if (this.f == null) {
                this.m.ai = this.d;
            }
        }
    };
    XamLinearGaugeView.prototype.b = function (a, b) {
        this.ah.startCSSQuery();
        for (var c = 0; c < b.length; c++) {
            b[c] = this.ah.getCssDefaultPropertyValue(a, b[c]);
        }
        this.ah.endCSSQuery();
        return b;
    };
    XamLinearGaugeView.prototype.bv = function () {
        this.a1();
        this.b1();
        this.br();
    };
    XamLinearGaugeView.prototype.cg = function (a) {
        var b = CanvasGestureDOMEventProxy.cy(this.ah.rootWrapper);
        return { $type: Point_$type, x: a.x - b.left, y: a.y - b.top };
    };
    XamLinearGaugeView.prototype.bu = function (a, b, c, d) {
        this.cf = a;
        this.an = c;
        this.aq = d;
        this.bq();
        if (this.ah != null) {
            this.am = this.ah.setTimeout(runOn(this, this.b2), this.al);
        }
        else {
            this.am = window.setTimeout(runOn(this, this.b2), this.al);
        }
        this.t = true;
    };
    XamLinearGaugeView.prototype.a2 = function () {
        if (this.t) {
            if (this.ah != null) {
                this.ah.clearTimeout(this.am);
            }
            else {
                window.clearTimeout(this.am);
            }
            this.t = false;
        }
        if (this.u) {
            var a = this.m.toolTip;
            if (this.ah != null) {
                this.ah.clearTimeout(this.ak);
            }
            else {
                window.clearTimeout(this.ak);
            }
            a.hide();
            this.u = false;
            this.k = null;
        }
        this.al = this.m.c3;
    };
    XamLinearGaugeView.prototype.bq = function () {
        if (this.t) {
            if (this.ah != null) {
                this.ah.clearTimeout(this.am);
            }
            else {
                window.clearTimeout(this.am);
            }
        }
        if (this.u) {
            var a = this.m.toolTip;
            if (this.ah != null) {
                this.ah.clearTimeout(this.ak);
            }
            else {
                window.clearTimeout(this.ak);
            }
            a.hide();
            this.u = false;
            this.al = intDivide(this.m.c3, 2);
        }
    };
    XamLinearGaugeView.prototype.b2 = function () {
        var _this = this;
        if (this.t) {
            if (this.ah != null) {
                this.ah.clearTimeout(this.am);
            }
            else {
                window.clearTimeout(this.am);
            }
            this.t = false;
        }
        var a = this.an;
        var b = this.aq;
        var c = this.cf;
        if (this.ah != null) {
            this.ak = this.ah.setTimeout(runOn(this, this.a2), 10 * this.m.c3);
        }
        else {
            this.ak = window.setTimeout(runOn(this, this.a2), 10 * this.m.c3);
        }
        var d = this.m.ranges._inner[a];
        if (this.ai != this.m.toolTip) {
            if (this.ai != null) {
                this.ai.remove();
            }
            this.ai = this.m.toolTip;
            this.ai.setStyleProperty("z-index", "10000");
            this.ai.setStyleProperty("position", "absolute");
            this.ah.append(this.ai);
        }
        this.k = this.j(b, a);
        var context_ = this.k;
        var tooltip_ = this.ai;
        var tooltipType_ = b;
        if (tooltip_.updateToolTip) {
            tooltip_.updateToolTip(context_, tooltipType_);
        }
        ;
        var e = this.ai.findByClass(".ui-tooltip-container");
        if (e != null && e.length > 0) {
            e[0].setAttribute("style", null);
        }
        var f = "ui-simple-default-tooltip-content";
        var g = this.ai.findByClass("." + f);
        if (g != null && g.length > 0) {
            var h = ["border-top-color", "border-top-width", "border-top-style", "border-top-left-radius", "background-color", "padding-top", "font-weight"];
            var i = ["border-color", "border-width", "border-style", "border-radius", "background-color", "padding", "font-weight"];
            var j = ((function () {
                var $ret = new List$1(String_$type, 0);
                $ret.add(_this.k.brush.color.colorString);
                $ret.add("2px");
                $ret.add("solid");
                $ret.add("4px");
                $ret.add("rgba(230, 230, 230, 0.74)");
                $ret.add("4px");
                $ret.add("bold");
                return $ret;
            })());
            var k = new Dictionary$2(String_$type, String_$type, 0);
            var l = new Array(h.length);
            arrayCopy1(h, 0, l, 0, h.length);
            this.b(f, l);
            for (var m = 0; m < l.length; m++) {
                this.ai.setStyleProperty(i[m], (l[m] == null) ? j._inner[m] : l[m]);
            }
        }
        this.ai.setStyleProperty("top", (c.y + 15).toString() + "px").setStyleProperty("left", (c.x + 15).toString() + "px");
        this.ai.show();
        this.u = true;
    };
    XamLinearGaugeView.prototype.j = function (a, b) {
        var c = new LinearGraphTooltipDataContext();
        switch (a) {
            case "range":
                var d = this.m.ranges._inner[b];
                c.item = d;
                c.itemName = d.u;
                c.label = d.u + ": " + d.o.toString() + "-" + d.j.toString();
                var e = d.an;
                var f = d.ao;
                c.brush = e != null ? e : this.m.hv(b, this.c);
                c.outline = f != null ? f : this.m.hv(b, this.d);
                c.thickness = d.p;
                break;
            case "needle":
                c.item = this.m.c0;
                c.itemName = this.m.d5;
                c.label = this.m.d5 != null ? this.m.d5 + ": " + this.m.c0.toString() : this.m.c0.toString();
                c.brush = this.m.hx;
                c.outline = this.m.hy;
                c.thickness = this.m.ci;
                break;
        }
        return c;
    };
    XamLinearGaugeView.prototype.a9 = function (a) {
        if (a == null) {
            this.aj = null;
            this.ah = null;
            this.ai = null;
            this.p = null;
            this.at();
            return;
        }
        var b = a;
        this.ah = b;
        this.m.av.u(this.ah);
        this.ah.rootWrapper.addClass("ui-lineargauge-container");
        this.ad = (isNaN_(this.m.cj) ? this.m.bt : this.m.cj);
        var c = this.ad;
        var d = Math.round(b.rootWrapper.width());
        var e = Math.round(b.rootWrapper.height());
        var f = d * c;
        var g = e * c;
        this.ah.rootWrapper.setStyleProperty("position", "relative");
        var h = this.ah.createElement("canvas");
        h.setStyleProperty("position", "absolute");
        this.ah.append(h);
        this.ap = f;
        this.ao = g;
        h.setAttribute("width", f.toString());
        h.setAttribute("height", g.toString());
        h.setStyleProperty("width", d.toString() + "px");
        h.setStyleProperty("height", e.toString() + "px");
        this.m.h9 = new Rect(0, 0, 0, d, e);
        this.m.h7 = new Rect(0, 0, 0, d, e);
        this.aj = h;
        var i = this.ah.get2DCanvasContext(this.aj);
        this.p = new RenderingContext(new CanvasViewRenderer(), i);
        this.a1();
        this.b1();
        this.p.ac(this.n);
        this.at();
        if (TypeRegistrar.isRegistered("CanvasGestureDOMEventProxy")) {
            this.i = typeCast(EventProxy.$, TypeRegistrar.create("CanvasGestureDOMEventProxy", this.ah.rootWrapper, this.ah, false));
        }
        if (this.i != null) {
            var j = this.i;
            j.onMouseOver = delegateCombine(j.onMouseOver, runOn(this, this.ay));
            var k = this.i;
            k.onMouseLeave = delegateCombine(k.onMouseLeave, runOn(this, this.ax));
            var l = this.i;
            l.onContactStarted = delegateCombine(l.onContactStarted, runOn(this, this.aw));
            var m = this.i;
            m.onContactMoved = delegateCombine(m.onContactMoved, runOn(this, this.av));
            var n = this.i;
            n.onContactCompleted = delegateCombine(n.onContactCompleted, runOn(this, this.au));
        }
        this.bp();
    };
    XamLinearGaugeView.prototype.au = function (a, b) {
        if (this.m != null) {
            this.m.onMouseUp(a);
        }
    };
    XamLinearGaugeView.prototype.av = function (a, b) {
        if (this.m != null) {
            this.m.onMouseMove(a, b);
        }
    };
    XamLinearGaugeView.prototype.aw = function (a, b) {
        if (this.m != null) {
            this.m.onMouseDown(a, b);
        }
    };
    XamLinearGaugeView.prototype.ay = function (a, b, c) {
        if (this.m != null) {
            this.m.onMouseOver(a, b, c);
        }
    };
    XamLinearGaugeView.prototype.ax = function (a) {
        if (this.m != null) {
            this.m.onMouseLeave();
        }
    };
    XamLinearGaugeView.prototype.at = function () {
        if (this.i != null) {
            var a = this.i;
            a.onMouseOver = delegateRemove(a.onMouseOver, runOn(this, this.ay));
            var b = this.i;
            b.onMouseLeave = delegateRemove(b.onMouseLeave, runOn(this, this.ax));
            var c = this.i;
            c.onContactStarted = delegateRemove(c.onContactStarted, runOn(this, this.aw));
            var d = this.i;
            d.onContactMoved = delegateRemove(d.onContactMoved, runOn(this, this.av));
            var e = this.i;
            e.onContactCompleted = delegateRemove(e.onContactCompleted, runOn(this, this.au));
            this.i.aq();
        }
    };
    XamLinearGaugeView.prototype.ba = function () {
        this.a3();
        var a = Math.round(this.ah.rootWrapper.width());
        var b = Math.round(this.ah.rootWrapper.height());
        this.m.h9 = new Rect(0, 0, 0, a, b);
        this.m.h7 = new Rect(0, 0, 0, a, b);
        if (this.i != null) {
            this.i.bf = this.m.h9;
        }
    };
    XamLinearGaugeView.prototype.as = function () {
        this.bp();
    };
    XamLinearGaugeView.prototype.bs = function (a) {
        this.x = a;
    };
    XamLinearGaugeView.prototype.bp = function () {
        var a = this.m.h9.width;
        var b = this.m.h9.height;
        var c = a * this.ad;
        var d = b * this.ad;
        if (this.ap != a || this.ao != b) {
            this.aj.setAttribute("width", c.toString());
            this.aj.setAttribute("height", d.toString());
            this.aj.setStyleProperty("width", a.toString() + "px");
            this.aj.setStyleProperty("height", b.toString() + "px");
            this.ap = truncate(Math.round(c));
            this.ao = truncate(Math.round(d));
        }
        if (this.p.d && this.ad != 1) {
            this.p.z();
            this.p.aa(this.ad, this.ad);
        }
        this.p.k(this.m.h9.left, this.m.h9.top, this.m.h9.width, this.m.h9.height);
        this.p.s(this.ch);
        this.p.s(this.cj);
        if (this.x != null) {
            for (var e = 0; e < this.x.count; e++) {
                this.p.s(this.x._inner[e]);
            }
        }
        for (var f = 0; f < this.y.count; f++) {
            this.p.ac(this.n);
            this.p.w(this.y._inner[f]);
        }
        for (var g = 0; g < this.z.count; g++) {
            this.p.s(this.z._inner[g]);
        }
        this.p.s(this.ci);
        if (this.p.d && this.ad != 1) {
            this.p.y();
        }
    };
    XamLinearGaugeView.prototype.b1 = function () {
        if (this.m.dd != null) {
            this.n = this.m.ax();
        }
        else {
            this.n = FontUtil.getFont(this.ah);
        }
        this.ac = this.ae(this.n);
        if (this.m.hu == null) {
            var a = this.ah.rootWrapper.getStyleProperty("color");
            if (stringIsNullOrEmpty(a) == false) {
                this.b5 = new Brush();
                this.b5._fill = a;
                this.m.hu = this.b5;
            }
        }
        if (this.p != null) {
            this.p.ac(this.n);
        }
    };
    XamLinearGaugeView.prototype.af = function (a) {
        var b = typeCast(TextBlock.$, a);
        if (b != null && b.ak != null) {
            return this.p.e(b) + 0;
        }
        return 0;
    };
    XamLinearGaugeView.prototype.cp = function (a) {
        if (isNaN_(this.ac)) {
            this.ac = this.ae(null);
        }
        var b = this.af(a);
        var c = this.ac;
        return new Size(1, b, c);
    };
    XamLinearGaugeView.prototype.bt = function (a, b) {
        if (b != null) {
            a.am = b;
        }
        else {
            a.am = this.b6;
        }
    };
    XamLinearGaugeView.prototype.bk = function (a, b, c) {
        a.n = b;
        a.o = c;
    };
    XamLinearGaugeView.prototype.bj = function (a, b) {
    };
    XamLinearGaugeView.prototype.bl = function (a, b) {
    };
    XamLinearGaugeView.prototype.ae = function (a) {
        return FontUtil.getCurrentFontHeight(this.ah, a);
    };
    XamLinearGaugeView.prototype.br = function () {
        if (!this.r) {
            this.r = true;
            window.setTimeout(runOn(this, this.ar), 0);
        }
    };
    XamLinearGaugeView.prototype.ar = function () {
        if (this.r) {
            this.r = false;
            this.m.e4();
        }
    };
    XamLinearGaugeView.prototype.flush = function () {
        if (this.r) {
            this.ar();
        }
    };
    XamLinearGaugeView.prototype.o = function (a, b) {
        return FontUtil.getFontInfo(this.ah, a, b);
    };
    XamLinearGaugeView.prototype.az = function (a) {
        var e_3, _a, e_4, _b, e_5, _c;
        a.scalePath = new PathVisualData(1, "Scale", this.cj);
        a.needlePath = new PathVisualData(1, "Needle", this.ci);
        a.backingPath = new PathVisualData(1, "Backing", this.ch);
        var b = this.n;
        try {
            for (var _d = __values(fromEnum(this.y)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var c = _e.value;
                if (c._visibility == 0) {
                    var d = this.o(c, b);
                    var e = new LinearGraphScaleLabelVisualData();
                    e.labelValue = c.ak;
                    e.labelPosition = PointData.b({ $type: Point_$type, x: c.n, y: c.o });
                    e.labelSize = SizeData.b(this.cp(c));
                    e.appearance = AppearanceHelper.c(c, d);
                    a.scaleLabels.add(e);
                }
            }
        }
        catch (e_3_1) {
            e_3 = { error: e_3_1 };
        }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return))
                    _a.call(_d);
            }
            finally {
                if (e_3)
                    throw e_3.error;
            }
        }
        try {
            for (var _f = __values(fromEnum(this.z)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var f = _g.value;
                if (f._visibility == 0) {
                    var g = new LinearGraphScaleTickmarkVisualData();
                    g.tickPath = new PathVisualData(1, "tickmarks", f);
                    a.scaleTickmarks.add(g);
                }
            }
        }
        catch (e_4_1) {
            e_4 = { error: e_4_1 };
        }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return))
                    _b.call(_f);
            }
            finally {
                if (e_4)
                    throw e_4.error;
            }
        }
        try {
            for (var _h = __values(fromEnum(this.x)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var h = _j.value;
                if (h._visibility == 0) {
                    var i = new LinearGraphRangeVisualData();
                    var j = new PathVisualData(1, "range", h);
                    i.rangePath = j;
                    a.ranges.add(i);
                }
            }
        }
        catch (e_5_1) {
            e_5 = { error: e_5_1 };
        }
        finally {
            try {
                if (_j && !_j.done && (_c = _h.return))
                    _c.call(_h);
            }
            finally {
                if (e_5)
                    throw e_5.error;
            }
        }
    };
    XamLinearGaugeView.prototype.a7 = function () {
        this.a3();
        if (this.i != null) {
            this.i.ap(this.ah.rootWrapper, "");
        }
    };
    XamLinearGaugeView.prototype.bb = function () {
        if (this.i != null) {
            this.i.bb(this.ah.rootWrapper, "");
        }
    };
    XamLinearGaugeView.prototype.bm = function (a) {
        a._visibility = 0;
    };
    XamLinearGaugeView.prototype.bn = function (a) {
        a._visibility = 1;
    };
    XamLinearGaugeView.prototype.bo = function (a) {
        this.aa.remove(a);
    };
    XamLinearGaugeView.prototype.co = function () {
        var a = new Path();
        this.aa.add(a);
        return a;
    };
    XamLinearGaugeView.prototype.bw = function (a) {
        a._visibility = 0;
    };
    XamLinearGaugeView.prototype.bx = function (a) {
        a._visibility = 1;
    };
    XamLinearGaugeView.prototype.by = function (a) {
        this.ab.remove(a);
    };
    XamLinearGaugeView.prototype.b4 = function () {
        var a = new TextBlock();
        this.ab.add(a);
        return a;
    };
    XamLinearGaugeView.prototype.bf = function (a) {
        a._visibility = 0;
    };
    XamLinearGaugeView.prototype.bg = function (a) {
        a._visibility = 1;
    };
    XamLinearGaugeView.prototype.bh = function (a) {
        this.z.remove(a);
    };
    XamLinearGaugeView.prototype.cn = function () {
        var a = new Path();
        this.z.add(a);
        return a;
    };
    XamLinearGaugeView.prototype.a4 = function (a) {
        a._visibility = 0;
    };
    XamLinearGaugeView.prototype.a5 = function (a) {
        a._visibility = 1;
    };
    XamLinearGaugeView.prototype.a6 = function (a) {
        this.y.remove(a);
    };
    XamLinearGaugeView.prototype.b3 = function () {
        var a = new TextBlock();
        this.y.add(a);
        return a;
    };
    XamLinearGaugeView.prototype.l = function () {
        var _this = this;
        if (this.k == null) {
            return null;
        }
        return ((function () {
            var $ret = new ToolTipInfo();
            $ret.b = _this.an;
            $ret.d = _this.cf;
            $ret.c = _this.aq;
            $ret.a = _this.k;
            return $ret;
        })());
    };
    XamLinearGaugeView.prototype.bi = function () {
        this.ad = this.m.bt;
    };
    XamLinearGaugeView.$t = markType(XamLinearGaugeView, 'XamLinearGaugeView');
    XamLinearGaugeView.w = new Dictionary$2(String_$type, Brush.$, 0);
    XamLinearGaugeView.g = null;
    XamLinearGaugeView.h = null;
    return XamLinearGaugeView;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

var defaultFont$1 = "Verdana, \"Segoe UI\", Arial, \"Myriad Pro\", sans-serif";
var LinearGaugeStylingDefaults = {
    //"ui-lineargauge-backing": {
    //    "background-color": "#ffffff",
    //    "border-color": "#ffffff"
    //},
    "ui-lineargauge-needle": {
        "background-color": "#999999",
        "border-top-color": "#FFFFFF"
    },
    "ui-lineargauge-scale": {
        "background-color": "transparent",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-tick": {
        "background-color": "rgba(0, 0, 0, 0.35)",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-minortick": {
        "background-color": "rgba(0, 0, 0, 0.2)",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-label": {
        "background-color": "#666666",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-1": {
        "background-color": "#0078C8",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-2": {
        "background-color": "#0099FF",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-3": {
        "background-color": "#21A7FF",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-4": {
        "background-color": "#4FB9FF",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-5": {
        "background-color": "#79C9FF",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-1": {
        "background-color": "#e0e0e0",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-2": {
        "background-color": "#c0c0c0",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-3": {
        "background-color": "#999999",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-4": {
        "background-color": "#494949",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-5": {
        "background-color": "#353535",
        "border-top-color": "transparent"
    },
    //"ui-lineargauge-tooltip": {
    //    "border-style": "none",
    //    "white-space": "nowrap",
    //    "background-color": "transparent"
    //},
    //"ui-lineargauge-range-tooltip": {
    //    "border-style": "solid",
    //    "border-width": "2px",
    //    "border-radius": "4px",
    //    "background-color": "rgba(230, 230, 230, 0.74)",
    //    "padding": "4px",
    //    "font-weight": "bold"
    //},
    //"ui-lineargauge-needle-tooltip": {
    //    "border-style": "solid",
    //    "border-width": "2px",
    //    "border-radius": "4px",
    //    "background-color": "rgba(230, 230, 230, 0.74)",
    //    "padding": "4px",
    //    "font-weight": "bold"
    //},
    "ui-lineargauge": {
        "font-family": defaultFont$1,
        "font-size": "11px",
        "color": "#494949"
    },
    "font-family": defaultFont$1,
    "font-style": "normal",
    "font-weight": "normal",
    "font-size": "11px",
    "color": "#666666",
    "font-variant": "",
    "line-height": ""
};

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * A linear gauge for displaying a single value on a defined scale.
*/
var IgrLinearGauge = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrLinearGauge, _super);
    function IgrLinearGauge(props) {
        var _this = _super.call(this, props) || this;
        _this.contentRanges = [];
        /**
        * The ranges actually present in the chart. Do not directly modify this array.
        * This array's contents can be modified by causing Angular to reproject the child content.
        * Or adding and removing ranges from the manual ranges collection on the ranges property.
        */
        _this.actualRanges = [];
        _this._ranges = null;
        _this._rangesAdapter = null;
        _this._initialized = false;
        _this._tooltipTemplate = null;
        _this._tooltipContent = null;
        _this._defaultTooltips = null;
        _this._uniqueTooltipId = 0;
        _this.__p = null;
        _this._hasUserValues = new Set();
        _this._stylingContainer = null;
        _this._stylingParent = null;
        _this._inStyling = false;
        _this._formatLabel = null;
        _this._formatLabel_wrapped = null;
        _this._alignLabel = null;
        _this._alignLabel_wrapped = null;
        _this._valueChanged = null;
        _this._valueChanged_wrapped = null;
        _this._actualMinimumValueChange = null;
        _this._actualMinimumValueChange_wrapped = null;
        _this._actualMaximumValueChange = null;
        _this._actualMaximumValueChange_wrapped = null;
        if (_this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(_this));
        }
        _this._getMainRef = _this._getMainRef.bind(_this);
        _this._tooltipRef = _this._tooltipRef.bind(_this);
        _this._activeTooltipElements = new Map();
        _this._activeTooltips = new Map();
        _this._currentTooltips = [];
        _this._contentChildrenManager = new ContentChildrenManager(function (ch) { return ch.key || ch.props.name; }, function (ch) { return ch.key || ch.props.name; }, function () { return _this._updateContentChildren(); });
        var container = null;
        if (document) {
            container = document.createElement("div");
            container.style.display = "block";
            container.style.width = "100%";
            container.style.height = "100%";
        }
        var root;
        root = container;
        _this._renderer = new ReactRenderer(root, document, true, LinearGaugeStylingDefaults);
        _this._container = _this._renderer.getWrapper(container);
        _this._implementation = _this.createImplementation();
        //this._container = this._renderer.createElement("div");
        //this._renderer.rootWrapper.append(this._container);
        //this._container.setStyleProperty("display", "block");
        //this._container.setStyleProperty("width", "100%");
        //this._container.setStyleProperty("height", "100%");
        _this._wrapper = _this._renderer;
        //var root: any;
        //root = this._container;
        //if (this._container.nativeElement != null) {
        //    root = this._container.nativeElement;
        //}
        var gauge = _this.i;
        _this._gauge = gauge;
        _this._rangesAdapter = new CollectionAdapter(_this.contentRanges, _this.i.ranges, _this.actualRanges, function (c) { return c.i; }, function (i) {
            i._provideRenderer(_this._wrapper);
            if (_this._container && _this._container.getNativeElement().parentElement) {
                i._styling(_this._container.getNativeElement(), _this, _this);
            }
        }, function (i) { i._provideRenderer(null); });
        gauge.provideContainer(_this._renderer);
        _this._renderer.addSizeWatcher(function () {
            _this._gauge.containerResized();
        });
        _this._initialized = true;
        return _this;
    }
    Object.defineProperty(IgrLinearGauge.prototype, "height", {
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            if (this._elRef) {
                this._elRef.style.height = value;
                this.containerResized();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (value) {
            this._width = value;
            if (this._elRef) {
                this._elRef.style.width = value;
                this.containerResized();
            }
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGauge.prototype._updateContentChildren = function () {
        this.contentRanges.length = 0;
        var contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (var i = 0; i < contentChildrenActual.length; i++) {
            if ((XamLinearGraphRange.$type).isAssignableFrom(contentChildrenActual[i].i.$type)) {
                this.contentRanges.push(contentChildrenActual[i]);
            }
        }
        if (this._rangesAdapter !== null) {
            this._rangesAdapter.notifyContentChanged();
        }
    };
    Object.defineProperty(IgrLinearGauge.prototype, "ranges", {
        /**
         * A collection or manually added axes for the chart.
        */
        get: function () {
            var _this = this;
            if (this._ranges === null) {
                var coll = new IgrLinearGraphRangeCollection();
                var inner = coll._innerColl;
                inner.addListener(function (sender, e) {
                    switch (e.action) {
                        case NotifyCollectionChangedAction.Add:
                            _this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Remove:
                            _this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                            break;
                        case NotifyCollectionChangedAction.Replace:
                            _this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                            _this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Reset:
                            _this._rangesAdapter.clearManualItems();
                            break;
                    }
                });
                this._ranges = coll;
            }
            return this._ranges;
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGauge.prototype._tooltipRef = function (t) {
        //console.log(t);
        if (t === null) {
            return;
        }
        if (t.currentOwner &&
            t.currentOwner.tooltipTemplate) {
            t.template = t.currentOwner.tooltipTemplate;
        }
        this._activeTooltips.set(t.currentOwner, t);
    };
    IgrLinearGauge.prototype.render = function () {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        var children = this._contentChildrenManager.getChildren(this.props.children);
        if (this._currentTooltips && this._currentTooltips.length > 0) {
            for (var i = 0; i < this._currentTooltips.length; i++) {
                var t = this._currentTooltips[i];
                if (this._activeTooltipElements.has(t)) {
                    children.push(this._activeTooltipElements.get(t));
                }
                else {
                    if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
                        continue;
                    }
                    var Tooltip = TypeRegistrar.get("IgrTooltipContainer");
                    var tEle = createElement(Tooltip, {
                        ref: this._tooltipRef,
                        key: this._currentTooltips[i].key,
                        owner: this._currentTooltips[i]
                    });
                    var portal = createPortal(tEle, t, this._currentTooltips[i].key);
                    this._activeTooltipElements.set(t, portal);
                    children.push(portal);
                }
            }
        }
        var div = createElement("div", {
            className: "ig-linear-gauge igr-linear-gauge",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    };
    IgrLinearGauge.prototype.componentDidMount = function () {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(this.props)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    {
                        this[p] = this.props[p];
                    }
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container.getNativeElement());
        this.containerResized();
        this.initializeContent();
    };
    IgrLinearGauge.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var e_2, _a;
        var mod = getModifiedProps(this.props, nextProps);
        try {
            for (var _b = __values(Object.keys(mod)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    this[p] = mod[p];
                }
            }
        }
        catch (e_2_1) {
            e_2 = { error: e_2_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_2)
                    throw e_2.error;
            }
        }
        return true;
    };
    IgrLinearGauge.prototype._getMainRef = function (div) {
        this._elRef = div;
    };
    IgrLinearGauge.prototype.destroy = function () {
        this._wrapper.rootWrapper.unlistenAll();
        this._gauge.destroy();
        this._wrapper.destroy();
    };
    IgrLinearGauge.prototype.createImplementation = function () {
        return new XamLinearGauge();
    };
    IgrLinearGauge.prototype.initializeContent = function () {
        this._styling(this._container.getNativeElement(), this);
        if (this.actualRanges && this.actualRanges.length > 0) {
            var currRange = this.actualRanges;
            for (var i = 0; i < currRange.length; i++) {
                currRange[i]._styling(this._container.getNativeElement(), this, this);
            }
        }
        this._updateContentChildren();
        this.i.containerResized();
    };
    IgrLinearGauge.prototype.componentWillUnmount = function () {
        //this._grid.destroy();
        this.destroy();
    };
    Object.defineProperty(IgrLinearGauge.prototype, "tooltipTemplate", {
        get: function () {
            return this._tooltipTemplate;
        },
        set: function (value) {
            this._tooltipTemplate = value;
            if (value == null) {
                if (this._tooltipContent !== null) {
                    this._tooltipContent.destroy();
                    this._tooltipContent = null;
                }
            }
            if (this._tooltipContent != null) {
                this._tooltipContent.instance.template = this._tooltipTemplate;
            }
            else {
                this._ensureTooltipCreated();
            }
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGauge.prototype.createWrapper = function (ele) {
        var wrapper = new ReactWrapper(ele, this._renderer);
        wrapper.updateToolTip = ele.updateToolTip;
        wrapper.hideToolTip = ele.hideToolTip;
        return wrapper;
    };
    IgrLinearGauge.prototype._ensureDefaultTooltip = function () {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips["ensureDefaultTooltip"](this);
    };
    IgrLinearGauge.prototype._onDefaultTooltipsReady = function (cr) {
        this._ensureDefaultTooltip();
    };
    IgrLinearGauge.prototype._updateTooltipState = function () {
        if (this._initialized) {
            this.setState({ tooltips: this._currentTooltips });
        }
    };
    IgrLinearGauge.prototype.createTooltip = function () {
        // if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
        // 	return null;
        // }
        // let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
        var wrapper = this._wrapper.createElement("div");
        var ele = wrapper.getNativeElement();
        ele.key = "__tooltip_" + this._uniqueTooltipId;
        this._uniqueTooltipId++;
        this._currentTooltips = this._currentTooltips.slice(0);
        this._currentTooltips.push(ele);
        //let element = React.createElement(Tooltip,  );
        //let portal = ReactDOM.createPortal(element, ele);
        var self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                var ext = new IgrDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container.getNativeElement()) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.getNativeElement().appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            if (self._activeTooltips.has(ele)) {
                var t = self._activeTooltips.get(ele);
                if (t.template === null &&
                    ele.tooltipTemplate !== null) {
                    t.template = ele.tooltipTemplate;
                }
                t.dataContext = c;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        this._updateTooltipState();
        return ele;
    };
    IgrLinearGauge.prototype._ensureTooltipCreated = function () {
        if (this.i.toolTip == null) {
            var tooltip = this.createTooltip();
            var ele = tooltip;
            if (tooltip == null) {
                return;
            }
            this._tooltipContent = tooltip;
            //(<any>tooltip.instance).template = this._tooltipTemplate;
            this.i.toolTip = this.createWrapper(tooltip);
            if (this._activeTooltips.has(ele)) {
                var tCont = this._activeTooltips.get(ele);
                tCont.template = ele.tooltipTemplate;
            }
        }
    };
    Object.defineProperty(IgrLinearGauge.prototype, "i", {
        /**
         * @hidden
         */
        get: function () {
            return this._implementation;
        } /**
                                     * @hidden
                                     */,
        enumerable: true,
        configurable: true
    });
    IgrLinearGauge._createFromInternal = function (internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        var name = internal.$type.name;
        var externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    };
    Object.defineProperty(IgrLinearGauge.prototype, "animating", {
        /**
     * Gets a value indicating whether the bullet graph is currently animating.
    */
        get: function () {
            return this.i.a4;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "transitionProgress", {
        /**
         * Gets the transition progress of the animation when the control is animating.
        */
        get: function () {
            return this.i.cz;
        },
        set: function (v) {
            this.i.cz = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "orientation", {
        /**
         * Gets or sets the orientation of the scale.
        */
        get: function () {
            return this.i.as;
        },
        set: function (v) {
            this.i.as = ensureEnum(LinearScaleOrientation_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "rangeBrushes", {
        /**
         * Gets or sets a collection of brushes to be used as the palette for linear gauge ranges.
        */
        get: function () {
            return fromBrushCollection(this.i.ah);
        },
        set: function (v) {
            this.i.ah = toBrushCollection(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "rangeOutlines", {
        /**
         * Gets or sets a collection of brushes to be used as the palette for linear gauge outlines.
        */
        get: function () {
            return fromBrushCollection(this.i.ai);
        },
        set: function (v) {
            this.i.ai = toBrushCollection(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "minimumValue", {
        /**
         * Gets or sets the minimum value of the scale.
        */
        get: function () {
            return this.i.b4;
        },
        set: function (v) {
            this.i.b4 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "actualMinimumValue", {
        /**
         * Gets the resolved minimum value of the scale.
        */
        get: function () {
            return this.i.bs;
        },
        set: function (v) {
            this.i.bs = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "maximumValue", {
        /**
         * Gets or sets the maximum value of the scale.
        */
        get: function () {
            return this.i.b3;
        },
        set: function (v) {
            this.i.b3 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "actualMaximumValue", {
        /**
         * Gets the resolved maximum value of the scale.
        */
        get: function () {
            return this.i.br;
        },
        set: function (v) {
            this.i.br = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "value", {
        /**
         * Gets or sets the value at which the needle is positioned.
        */
        get: function () {
            return this.i.c0;
        },
        set: function (v) {
            this.i.c0 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleShape", {
        /**
         * Gets or sets the shape to use when rendering the needle from a number of options.
        */
        get: function () {
            return this.i.ap;
        },
        set: function (v) {
            this.i.ap = ensureEnum(LinearGraphNeedleShape_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleName", {
        /**
         * Gets or sets the name used for needle.
        */
        get: function () {
            return this.i.d5;
        },
        set: function (v) {
            this.i.d5 = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "rangeInnerExtent", {
        /**
         * Gets or sets the position at which to start rendering the ranges, measured from the front/bottom of the control as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.ck;
        },
        set: function (v) {
            this.i.ck = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "scaleInnerExtent", {
        /**
         * Gets or sets the position at which to start rendering the scale, measured from the bottom/front (when orientation is horizontal/vertical) of the control as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.co;
        },
        set: function (v) {
            this.i.co = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "rangeOuterExtent", {
        /**
         * Gets or sets the position at which to stop rendering the range as a value from 0 to 1 measured from the front/bottom of the linear gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.cl;
        },
        set: function (v) {
            this.i.cl = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "scaleOuterExtent", {
        /**
         * Gets or sets the position at which to stop rendering the scale as a value from 0 to 1 measured from the bottom/front (when orientation is horizontal/vertical) of the linear gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.cq;
        },
        set: function (v) {
            this.i.cq = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleInnerExtent", {
        /**
         * Gets or sets the position at which to start rendering the needle geometry, measured from the front/bottom of the linear gauge as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.cb;
        },
        set: function (v) {
            this.i.cb = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleOuterExtent", {
        /**
         * Gets or sets the position at which to stop rendering the needle geometry as a value from 0 to 1 measured from the front/bottom of the linear gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.cf;
        },
        set: function (v) {
            this.i.cf = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleInnerBaseWidth", {
        /**
         * Gets or sets the width of the needle's inner base.
        */
        get: function () {
            return this.i.ca;
        },
        set: function (v) {
            this.i.ca = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleOuterBaseWidth", {
        /**
         * Gets or sets the width of the needle's outer base.
        */
        get: function () {
            return this.i.ce;
        },
        set: function (v) {
            this.i.ce = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleInnerPointWidth", {
        /**
         * Gets or sets the width of the needle's inner point.
        */
        get: function () {
            return this.i.cd;
        },
        set: function (v) {
            this.i.cd = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleOuterPointWidth", {
        /**
         * Gets or sets the width of the needle's outer point.
        */
        get: function () {
            return this.i.ch;
        },
        set: function (v) {
            this.i.ch = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleInnerPointExtent", {
        /**
         * Gets or sets the extent of the needle's inner point.
        */
        get: function () {
            return this.i.cc;
        },
        set: function (v) {
            this.i.cc = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleOuterPointExtent", {
        /**
         * Gets or sets the extent of the needle's outer point.
        */
        get: function () {
            return this.i.cg;
        },
        set: function (v) {
            this.i.cg = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "interval", {
        /**
         * Gets or sets the interval to use for the scale.
        */
        get: function () {
            return this.i.by;
        },
        set: function (v) {
            this.i.by = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "ticksPostInitial", {
        /**
         * A value to start adding tickmarks, added to the scale's MinimumValue.
        */
        get: function () {
            return this.i.cv;
        },
        set: function (v) {
            this.i.cv = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "ticksPreTerminal", {
        /**
         * A value to stop adding tickmarks, subtracted from the scale's MaximumValue.
        */
        get: function () {
            return this.i.cw;
        },
        set: function (v) {
            this.i.cw = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "labelInterval", {
        /**
         * Gets or sets the interval to use for rendering labels. This defaults to be the same interval as the tickmarks on the scale.
        */
        get: function () {
            return this.i.b0;
        },
        set: function (v) {
            this.i.b0 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "labelExtent", {
        /**
         * Gets or sets the position at which to put the labels as a value from 0 to 1, measured from the bottom of the scale.
         * Values further from zero than 1 can be used to hide the labels of the linear gauge.
        */
        get: function () {
            return this.i.bz;
        },
        set: function (v) {
            this.i.bz = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "labelsPostInitial", {
        /**
         * A value to start adding labels, added to the scale's MinimumValue.
        */
        get: function () {
            return this.i.b1;
        },
        set: function (v) {
            this.i.b1 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "labelsPreTerminal", {
        /**
         * A value to stop adding labels, subtracted from the scale's MaximumValue.
        */
        get: function () {
            return this.i.b2;
        },
        set: function (v) {
            this.i.b2 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "minorTickCount", {
        /**
         * Gets or sets the number of minor tickmarks to place between major tickmarks.
        */
        get: function () {
            return this.i.b5;
        },
        set: function (v) {
            this.i.b5 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "tickStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the major tickmarks as a value from 0 to 1, measured from the front/bottom of the linear gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.cx;
        },
        set: function (v) {
            this.i.cx = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "tickEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the major tickmarks as a value from 0 to 1, measured from the front/bottom of the linear gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.cu;
        },
        set: function (v) {
            this.i.cu = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "tickStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering ticks.
        */
        get: function () {
            return this.i.cy;
        },
        set: function (v) {
            this.i.cy = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "tickBrush", {
        /**
         * Gets or sets the brush to use for the major tickmarks.
        */
        get: function () {
            return brushToString(this.i.h1);
        },
        set: function (v) {
            this.i.h1 = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "fontBrush", {
        /**
         * Gets or sets the brush to use for the label font.
        */
        get: function () {
            return brushToString(this.i.hu);
        },
        set: function (v) {
            this.i.hu = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleBreadth", {
        /**
         * Gets or sets the needle breadth.
        */
        get: function () {
            return this.i.b9;
        },
        set: function (v) {
            this.i.b9 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleBrush", {
        /**
         * Gets or sets the brush to use for needle element.
        */
        get: function () {
            return brushToString(this.i.hx);
        },
        set: function (v) {
            this.i.hx = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleOutline", {
        /**
         * Gets or sets the brush to use for the outline of needle element.
        */
        get: function () {
            return brushToString(this.i.hy);
        },
        set: function (v) {
            this.i.hy = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "needleStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering single actual value element.
        */
        get: function () {
            return this.i.ci;
        },
        set: function (v) {
            this.i.ci = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "minorTickStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the minor tickmarks as a value from 0 to 1, measured from the front/bottom of the linear gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.b7;
        },
        set: function (v) {
            this.i.b7 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "minorTickEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the minor tickmarks as a value from 0 to 1, measured from the front/bottom of the linear gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.b6;
        },
        set: function (v) {
            this.i.b6 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "minorTickStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering minor ticks.
        */
        get: function () {
            return this.i.b8;
        },
        set: function (v) {
            this.i.b8 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "minorTickBrush", {
        /**
         * Gets or sets the brush to use for the minor tickmarks.
        */
        get: function () {
            return brushToString(this.i.hw);
        },
        set: function (v) {
            this.i.hw = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "isScaleInverted", {
        /**
         * Gets or sets a value indicating whether the scale is inverted.
         * When the scale is inverted the direction in which the scale values increase is right to left.
        */
        get: function () {
            return this.i.a8;
        },
        set: function (v) {
            this.i.a8 = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "backingBrush", {
        /**
         * Gets or sets the brush to use to fill the backing of the linear gauge.
        */
        get: function () {
            return brushToString(this.i.hs);
        },
        set: function (v) {
            this.i.hs = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "backingOutline", {
        /**
         * Gets or sets the brush to use for the outline of the backing.
        */
        get: function () {
            return brushToString(this.i.ht);
        },
        set: function (v) {
            this.i.ht = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "backingStrokeThickness", {
        /**
         * Gets or sets the stroke thickness of the backing outline.
        */
        get: function () {
            return this.i.bw;
        },
        set: function (v) {
            this.i.bw = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "backingInnerExtent", {
        /**
         * Gets or sets the inner extent of the linear gauge backing.
        */
        get: function () {
            return this.i.bu;
        },
        set: function (v) {
            this.i.bu = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "backingOuterExtent", {
        /**
         * Gets or sets the outer extent of the linear gauge backing.
        */
        get: function () {
            return this.i.bv;
        },
        set: function (v) {
            this.i.bv = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "scaleStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the scale, measured from the front/bottom of the linear gauge as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.cs;
        },
        set: function (v) {
            this.i.cs = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "scaleEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the scale as a value from 0 to 1, measured from the front/bottom of the linear gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
        */
        get: function () {
            return this.i.cn;
        },
        set: function (v) {
            this.i.cn = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "scaleBrush", {
        /**
         * Gets or sets the brush to use to fill the scale of the linear gauge.
        */
        get: function () {
            return brushToString(this.i.hz);
        },
        set: function (v) {
            this.i.hz = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "scaleOutline", {
        /**
         * Gets or sets the brush to use for the outline of the scale.
        */
        get: function () {
            return brushToString(this.i.h0);
        },
        set: function (v) {
            this.i.h0 = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "scaleStrokeThickness", {
        /**
         * Gets or sets the stroke thickness of the scale outline.
        */
        get: function () {
            return this.i.ct;
        },
        set: function (v) {
            this.i.ct = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "isNeedleDraggingEnabled", {
        /**
         * Gets or sets whether needle dragging is enabled or not.
        */
        get: function () {
            return this.i.a7;
        },
        set: function (v) {
            this.i.a7 = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "labelFormat", {
        /**
         * Gets or sets the label composite format used when creating label values.
        */
        get: function () {
            return this.i.dk;
        },
        set: function (v) {
            this.i.dk = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "labelFormatSpecifiers", {
        /**
         * Gets or sets the format specifiers to use with the LabelFormat string.
        */
        get: function () {
            return this.i.ag;
        },
        set: function (v) {
            this.i.ag = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "transitionDuration", {
        /**
         * Gets or sets the number of milliseconds over which changes to the linear gauge should be animated.
        */
        get: function () {
            return this.i.c4;
        },
        set: function (v) {
            this.i.c4 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "showToolTipTimeout", {
        /**
         * Gets or sets the time in milliseconds that tooltip appearance is delayed with.
        */
        get: function () {
            return this.i.c3;
        },
        set: function (v) {
            this.i.c3 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "showToolTip", {
        /**
         * Gets or sets a value indicating whether tooltips are enabled.
        */
        get: function () {
            return this.i.be;
        },
        set: function (v) {
            this.i.be = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "font", {
        /**
         * Gets or sets the font.
        */
        get: function () {
            return this.i.dd;
        },
        set: function (v) {
            this.i.dd = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "pixelScalingRatio", {
        /**
         * Gets or sets the scaling value used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get: function () {
            return this.i.cj;
        },
        set: function (v) {
            this.i.cj = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "actualPixelScalingRatio", {
        /**
         * Gets the actual pixel scaling ratio used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get: function () {
            return this.i.bt;
        },
        set: function (v) {
            this.i.bt = +v;
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGauge.prototype.findByName = function (name) {
        if (this.ranges != null && this.ranges.findByName && this.ranges.findByName(name)) {
            return this.ranges.findByName(name);
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        return null;
    };
    Object.defineProperty(IgrLinearGauge.prototype, "hasUserValues", {
        get: function () {
            return this._hasUserValues;
        },
        enumerable: true,
        configurable: true
    });
    IgrLinearGauge.prototype.__m = function (propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    };
    IgrLinearGauge.prototype._styling = function (container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        var genericPrefix = "";
        var typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("LinearGauge");
        var additionalPrefixes = [];
        var prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        var b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            var basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            var parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            var parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    };
    /**
 * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.

* @param point  * The point for which to retrieve the associated value.
*/
    IgrLinearGauge.prototype.getValueForPoint = function (point) {
        var iv = this.i.bx(toPoint(point));
        return (iv);
    };
    IgrLinearGauge.prototype.needleContainsPoint = function (point, isFinger) {
        var iv = this.i.needleContainsPoint(toPoint(point), isFinger);
        return (iv);
    };
    /**
     * Returns visuals as a serialized string.
    
    */
    IgrLinearGauge.prototype.exportSerializedVisualData = function () {
        var iv = this.i.dc();
        return (iv);
    };
    /**
     * Use to force the linear gauge to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the linear gauge needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the linear gauge.
    
    */
    IgrLinearGauge.prototype.flush = function () {
        this.i.e8();
    };
    /**
     * Called by the UI framework to provide a UI container for rendering this control.
    
    * @param container  * The UI container element.
    */
    IgrLinearGauge.prototype.provideContainer = function (container) {
        this.i.provideContainer(container);
    };
    IgrLinearGauge.prototype.containerResized = function () {
        this.i.containerResized();
    };
    IgrLinearGauge.prototype.styleUpdated = function () {
        this.i.f2();
    };
    Object.defineProperty(IgrLinearGauge.prototype, "formatLabel", {
        /**
         * Event which is raised when a label of the the gauge is formatted.
         * Function takes first argument evt and second argument ui.
         * Use ui.owner to obtain reference to the gauge widget.
         * Use ui.actualMinimumValue to obtain the minimum value of the gauge scale.
         * Use ui.actualMaximumValue to obtain the maximum value of the gauge scale.
         * Use ui.value to obtain the value on the the gauge scale associated with the label.
         * Use ui.label to obtain the string value of the label.
        */
        get: function () {
            return this._formatLabel;
        },
        set: function (ev) {
            var _this = this;
            if (this._formatLabel_wrapped !== null) {
                this.i.formatLabel = delegateRemove(this.i.formatLabel, this._formatLabel_wrapped);
                this._formatLabel_wrapped = null;
                this._formatLabel = null;
            }
            this._formatLabel = ev;
            this._formatLabel_wrapped = function (o, e) {
                var outerArgs = new IgrFormatLinearGraphLabelEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeFormatLabel) {
                    _this.beforeFormatLabel(_this, outerArgs);
                }
                if (_this._formatLabel) {
                    _this._formatLabel(_this, outerArgs);
                }
            };
            this.i.formatLabel = delegateCombine(this.i.formatLabel, this._formatLabel_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "alignLabel", {
        /**
         * Event which is raised when a label of the linear gauge is aligned along the scale.
         * Function takes first argument evt and second argument ui.
         * Use ui.owner to obtain reference to the gauge widget.
         * Use ui.actualMinimumValue to obtain the minimum value of the gauge scale.
         * Use ui.actualMaximumValue to obtain the maximum value of the gauge scale.
         * Use ui.value to obtain the value on the gauge scale associated with the label.
         * Use ui.label to obtain the string value of the label.
         * Use ui.width to obtain the width of the label.
         * Use ui.height to obtain the height of the label.
         * Use ui.offsetX to obtain the X offset of the label on the gauge scale.
         * Use ui.offsetY to obtain the Y offset of the label on the gauge scale.
        */
        get: function () {
            return this._alignLabel;
        },
        set: function (ev) {
            var _this = this;
            if (this._alignLabel_wrapped !== null) {
                this.i.alignLabel = delegateRemove(this.i.alignLabel, this._alignLabel_wrapped);
                this._alignLabel_wrapped = null;
                this._alignLabel = null;
            }
            this._alignLabel = ev;
            this._alignLabel_wrapped = function (o, e) {
                var outerArgs = new IgrAlignLinearGraphLabelEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeAlignLabel) {
                    _this.beforeAlignLabel(_this, outerArgs);
                }
                if (_this._alignLabel) {
                    _this._alignLabel(_this, outerArgs);
                }
            };
            this.i.alignLabel = delegateCombine(this.i.alignLabel, this._alignLabel_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "valueChanged", {
        /**
         * Occurs when the Value property changes.
        */
        get: function () {
            return this._valueChanged;
        },
        set: function (ev) {
            var _this = this;
            if (this._valueChanged_wrapped !== null) {
                this.i.valueChanged = delegateRemove(this.i.valueChanged, this._valueChanged_wrapped);
                this._valueChanged_wrapped = null;
                this._valueChanged = null;
            }
            this._valueChanged = ev;
            this._valueChanged_wrapped = function (o, e) {
                var outerArgs = new IgrDoubleValueChangedEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeValueChanged) {
                    _this.beforeValueChanged(_this, outerArgs);
                }
                if (_this._valueChanged) {
                    _this._valueChanged(_this, outerArgs);
                }
            };
            this.i.valueChanged = delegateCombine(this.i.valueChanged, this._valueChanged_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "actualMinimumValueChange", {
        get: function () {
            return this._actualMinimumValueChange;
        },
        set: function (ev) {
            var _this = this;
            if (this._actualMinimumValueChange_wrapped !== null) {
                this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
                this._actualMinimumValueChange_wrapped = null;
                this._actualMinimumValueChange = null;
            }
            this._actualMinimumValueChange = ev;
            this._actualMinimumValueChange_wrapped = function (o, e) {
                var ext = _this.actualMinimumValue;
                if (_this.beforeActualMinimumValueChange) {
                    _this.beforeActualMinimumValueChange(_this, ext);
                }
                if (_this._actualMinimumValueChange) {
                    _this._actualMinimumValueChange(_this, ext);
                }
            };
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrLinearGauge.prototype, "actualMaximumValueChange", {
        get: function () {
            return this._actualMaximumValueChange;
        },
        set: function (ev) {
            var _this = this;
            if (this._actualMaximumValueChange_wrapped !== null) {
                this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
                this._actualMaximumValueChange_wrapped = null;
                this._actualMaximumValueChange = null;
            }
            this._actualMaximumValueChange = ev;
            this._actualMaximumValueChange_wrapped = function (o, e) {
                var ext = _this.actualMaximumValue;
                if (_this.beforeActualMaximumValueChange) {
                    _this.beforeActualMaximumValueChange(_this, ext);
                }
                if (_this._actualMaximumValueChange) {
                    _this._actualMaximumValueChange(_this, ext);
                }
            };
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    return IgrLinearGauge;
}(Component));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrLinearGaugeCoreModule = /** @class */ /*@__PURE__*/ (function () {
    function IgrLinearGaugeCoreModule() {
    }
    IgrLinearGaugeCoreModule.register = function () {
        TypeRegistrar.registerCons('IgrLinearGauge', IgrLinearGauge);
        IgrLinearGraphRangeModule.register();
        IgrNumberFormatSpecifierModule.register();
    };
    return IgrLinearGaugeCoreModule;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrLinearGaugeModule = /** @class */ /*@__PURE__*/ (function () {
    function IgrLinearGaugeModule() {
    }
    IgrLinearGaugeModule.register = function () {
        IgrLinearGaugeCoreModule.register();
        IgrDVInteractivityModule.register();
    };
    return IgrLinearGaugeModule;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var LinearNeedleVisualDataList = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(LinearNeedleVisualDataList, _super);
    function LinearNeedleVisualDataList() {
        return _super.call(this, LinearNeedleVisualData.$, 0) || this;
    }
    LinearNeedleVisualDataList.$t = markType(LinearNeedleVisualDataList, 'LinearNeedleVisualDataList', List$1.$.specialize(LinearNeedleVisualData.$));
    return LinearNeedleVisualDataList;
}(List$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying various preset needle shapes.
 */
var RadialGaugeNeedleShape = /*@__PURE__*/ (function (RadialGaugeNeedleShape) {
    /**
     * No shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["None"] = 0] = "None";
    /**
     * A rectangle shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["Rectangle"] = 1] = "Rectangle";
    /**
     * A triangle shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["Triangle"] = 2] = "Triangle";
    /**
     * A needle shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["Needle"] = 3] = "Needle";
    /**
     * A trapezoid shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["Trapezoid"] = 4] = "Trapezoid";
    /**
     * A rectangle shape with a bulb at the end.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["RectangleWithBulb"] = 5] = "RectangleWithBulb";
    /**
     * A triangle shape with a bulb at the end.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["TriangleWithBulb"] = 6] = "TriangleWithBulb";
    /**
     * A needle shape with a bulb at the end.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["NeedleWithBulb"] = 7] = "NeedleWithBulb";
    /**
     * A trapezoid shape with a bulb at the end.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["TrapezoidWithBulb"] = 8] = "TrapezoidWithBulb";
    return RadialGaugeNeedleShape;
})({});
/**
 * @hidden
 */
var RadialGaugeNeedleShape_$type = /*@__PURE__*/ markEnum('RadialGaugeNeedleShape', 'None,0|Rectangle,1|Triangle,2|Needle,3|Trapezoid,4|RectangleWithBulb,5|TriangleWithBulb,6|NeedleWithBulb,7|TrapezoidWithBulb,8');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying shapes for the needle pivot.
 */
var RadialGaugePivotShape = /*@__PURE__*/ (function (RadialGaugePivotShape) {
    /**
     * No pivot shape.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["None"] = 0] = "None";
    /**
     * A circle shaped pivot.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["Circle"] = 1] = "Circle";
    /**
     * A circle pivot with a hole in it.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleWithHole"] = 2] = "CircleWithHole";
    /**
     * A circle pivot overlayed on top of the needle.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleOverlay"] = 3] = "CircleOverlay";
    /**
     * A circle pivot with a hole in it overlayed on top of the needle.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleOverlayWithHole"] = 4] = "CircleOverlayWithHole";
    /**
     * A circle pivot rendered underneath the needle.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleUnderlay"] = 5] = "CircleUnderlay";
    /**
     * A circle pivot with a hold in it rendered underneath the needle.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleUnderlayWithHole"] = 6] = "CircleUnderlayWithHole";
    return RadialGaugePivotShape;
})({});
/**
 * @hidden
 */
var RadialGaugePivotShape_$type = /*@__PURE__*/ markEnum('RadialGaugePivotShape', 'None,0|Circle,1|CircleWithHole,2|CircleOverlay,3|CircleOverlayWithHole,4|CircleUnderlay,5|CircleUnderlayWithHole,6');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying oversweep shapes.
 */
var RadialGaugeScaleOversweepShape = /*@__PURE__*/ (function (RadialGaugeScaleOversweepShape) {
    /**
     * A default oversweep shape.
     */
    RadialGaugeScaleOversweepShape[RadialGaugeScaleOversweepShape["Auto"] = 0] = "Auto";
    /**
     * A circular oversweep shape.
     */
    RadialGaugeScaleOversweepShape[RadialGaugeScaleOversweepShape["Circular"] = 1] = "Circular";
    /**
     * A fitted oversweep shape.
     */
    RadialGaugeScaleOversweepShape[RadialGaugeScaleOversweepShape["Fitted"] = 2] = "Fitted";
    return RadialGaugeScaleOversweepShape;
})({});
/**
 * @hidden
 */
var RadialGaugeScaleOversweepShape_$type = /*@__PURE__*/ markEnum('RadialGaugeScaleOversweepShape', 'Auto,0|Circular,1|Fitted,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying shapes that can be used by the backing area of the radial gauge.
 */
var RadialGaugeBackingShape = /*@__PURE__*/ (function (RadialGaugeBackingShape) {
    /**
     * A circular backing shape.
     */
    RadialGaugeBackingShape[RadialGaugeBackingShape["Circular"] = 0] = "Circular";
    /**
     * A fitted backing shape.
     */
    RadialGaugeBackingShape[RadialGaugeBackingShape["Fitted"] = 1] = "Fitted";
    return RadialGaugeBackingShape;
})({});
/**
 * @hidden
 */
var RadialGaugeBackingShape_$type = /*@__PURE__*/ markEnum('RadialGaugeBackingShape', 'Circular,0|Fitted,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var XamRadialGaugeRange = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(XamRadialGaugeRange, _super);
    function XamRadialGaugeRange() {
        var _this = _super.call(this) || this;
        _this.propertyChanged = null;
        return _this;
    }
    XamRadialGaugeRange.prototype.ad = function (a, b, c) {
    };
    XamRadialGaugeRange.prototype.ac = function (a, b, c) {
        this.ad(a, b, c);
        if (this.propertyChanged != null) {
            this.propertyChanged(this, new PropertyChangedEventArgs(a));
        }
    };
    XamRadialGaugeRange.$t = markType(XamRadialGaugeRange, 'XamRadialGaugeRange', DependencyObject.$, [INotifyPropertyChanged_$type]);
    XamRadialGaugeRange.q = DeviceUtils.g(1);
    XamRadialGaugeRange.$$p = markDep(DependencyProperty, PropertyMetadata, XamRadialGaugeRange, 'ac', ['Brush:ao:ae', [Brush.$, null], 'EndValue:j:af', [1, NaN], 'InnerEndExtent:k:ag', [1, NaN], 'InnerStartExtent:l:ah', [1, NaN], 'Name:v:ai', [2, null], 'OuterEndExtent:m:aj', [1, NaN], 'OuterStartExtent:n:ak', [1, NaN], 'Outline:ap:al', [Brush.$, null], 'StartValue:o:am', [1, NaN], 'StrokeThickness:p:an', [1, XamRadialGaugeRange.q]]);
    return XamRadialGaugeRange;
}(DependencyObject));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RadialGaugeRangeCollection = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RadialGaugeRangeCollection, _super);
    function RadialGaugeRangeCollection() {
        return _super.call(this, XamRadialGaugeRange.$, 0) || this;
    }
    RadialGaugeRangeCollection.$t = markType(RadialGaugeRangeCollection, 'RadialGaugeRangeCollection', ObservableCollection$1.$.specialize(XamRadialGaugeRange.$));
    return RadialGaugeRangeCollection;
}(ObservableCollection$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying multiple strategies for omitting labels.
 */
var RadialGaugeDuplicateLabelOmissionStrategy = /*@__PURE__*/ (function (RadialGaugeDuplicateLabelOmissionStrategy) {
    /**
     * Omit the last label.
     */
    RadialGaugeDuplicateLabelOmissionStrategy[RadialGaugeDuplicateLabelOmissionStrategy["OmitLast"] = 0] = "OmitLast";
    /**
     * Omit the first label.
     */
    RadialGaugeDuplicateLabelOmissionStrategy[RadialGaugeDuplicateLabelOmissionStrategy["OmitFirst"] = 1] = "OmitFirst";
    /**
     * Omit no labels.
     */
    RadialGaugeDuplicateLabelOmissionStrategy[RadialGaugeDuplicateLabelOmissionStrategy["OmitNeither"] = 2] = "OmitNeither";
    /**
     * Omit both labels.
     */
    RadialGaugeDuplicateLabelOmissionStrategy[RadialGaugeDuplicateLabelOmissionStrategy["OmitBoth"] = 3] = "OmitBoth";
    return RadialGaugeDuplicateLabelOmissionStrategy;
})({});
/**
 * @hidden
 */
var RadialGaugeDuplicateLabelOmissionStrategy_$type = /*@__PURE__*/ markEnum('RadialGaugeDuplicateLabelOmissionStrategy', 'OmitLast,0|OmitFirst,1|OmitNeither,2|OmitBoth,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RadialGaugeScaler = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RadialGaugeScaler, _super);
    function RadialGaugeScaler(a, b, c, d, e) {
        var _this = _super.call(this) || this;
        _this.e = 0;
        _this.d = 0;
        _this.c = 0;
        _this.b = 0;
        _this.l = 0;
        _this.f = 0;
        _this.a = 0;
        _this.e = c;
        _this.d = d;
        if (isNaN_(_this.e) || isInfinity(_this.e)) {
            _this.e = 135;
        }
        if (isNaN_(_this.d) || isInfinity(_this.d)) {
            _this.d = 45;
        }
        _this.l = e;
        _this.c = a;
        _this.b = b;
        var f = MathUtil.k(_this.e);
        var g = MathUtil.k(_this.d);
        var h = RadialGaugeScaler.k(f, g, _this.l);
        _this.f = h.c;
        _this.a = h.d;
        return _this;
    }
    Object.defineProperty(RadialGaugeScaler.prototype, "i", {
        get: function () {
            return this.f;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadialGaugeScaler.prototype, "g", {
        get: function () {
            return this.a;
        },
        enumerable: true,
        configurable: true
    });
    RadialGaugeScaler.k = function (a, b, c) {
        if (c == 1 && b < a) {
            b += Math.PI * 2;
        }
        if (c == 0 && a < b) {
            a += Math.PI * 2;
        }
        if (c == 0) {
            var d = a;
            a = b;
            b = d;
        }
        return new Tuple$2(Number_$type, Number_$type, a, b);
    };
    RadialGaugeScaler.prototype.h = function (a) {
        var b = NaN;
        if (this.c == this.b) {
            b = 0;
        }
        else {
            b = (a - this.c) / (this.b - this.c);
        }
        if (this.l == 0) {
            b = 1 - b;
        }
        var c = this.f + (this.a - this.f) * b;
        return c;
    };
    RadialGaugeScaler.prototype.j = function (a) {
        var b = (a - this.f) / (this.a - this.f);
        if (this.l == 0) {
            b = 1 - b;
        }
        var c = this.c + (this.b - this.c) * b;
        return c;
    };
    RadialGaugeScaler.$t = markType(RadialGaugeScaler, 'RadialGaugeScaler');
    return RadialGaugeScaler;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RadialGaugeNeedleFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RadialGaugeNeedleFrame, _super);
    function RadialGaugeNeedleFrame() {
        var _this = _super.call(this) || this;
        _this.ad = 0;
        _this.ac = 0;
        _this.af = 0;
        _this.ab = 0;
        _this.aj = null;
        _this.ak = null;
        _this.aa = 0;
        _this.ae = 0;
        _this.ai = null;
        _this.ah = null;
        _this.d = null;
        _this.b = null;
        _this.t = null;
        _this.e = null;
        _this.f = null;
        _this.x = null;
        _this.v = null;
        _this.w = null;
        _this.z = null;
        _this.y = null;
        _this.u = null;
        _this.h = null;
        _this.g = null;
        _this.c = null;
        _this.s = null;
        _this.a = null;
        _this.q = null;
        _this.r = null;
        _this.i = null;
        _this.l = null;
        _this.m = null;
        _this.p = null;
        _this.j = null;
        _this.k = null;
        _this.n = null;
        _this.o = null;
        _this.d = new MorphSegment();
        _this.b = new MorphSegment();
        _this.t = new MorphSegment();
        _this.e = new MorphSegment();
        _this.f = new MorphSegment();
        _this.x = new MorphSegment();
        _this.v = new MorphSegment();
        _this.w = new MorphSegment();
        _this.z = new MorphSegment();
        _this.y = new MorphSegment();
        _this.u = new MorphSegment();
        _this.h = new MorphSegment();
        _this.g = new MorphSegment();
        _this.c = new MorphSegment();
        _this.s = new MorphSegment();
        _this.a = new MorphSegment();
        _this.q = new MorphSegment();
        _this.r = new MorphSegment();
        _this.i = new MorphSegment();
        _this.l = new MorphSegment();
        _this.m = new MorphSegment();
        _this.p = new MorphSegment();
        _this.j = new MorphSegment();
        _this.k = new MorphSegment();
        _this.n = new MorphSegment();
        _this.o = new MorphSegment();
        return _this;
    }
    RadialGaugeNeedleFrame.prototype.ag = function (a, b, c) {
        this.ad = b.ad + (c.ad - b.ad) * a;
        this.ac = b.ac + (c.ac - b.ac) * a;
        this.af = b.af + (c.af - b.af) * a;
        this.ab = b.ab + (c.ab - b.ab) * a;
        this.aj = BrushUtil.k(b.aj, a, c.aj, 0);
        this.ak = BrushUtil.k(b.ak, a, c.ak, 0);
        this.ae = b.ae + (c.ae - b.ae) * a;
        this.aa = b.aa + (c.aa - b.aa) * a;
        this.ah = BrushUtil.k(b.ah, a, c.ah, 0);
        this.ai = BrushUtil.k(b.ai, a, c.ai, 0);
        this.d.j(a, b.d, c.d);
        this.b.j(a, b.b, c.b);
        this.t.j(a, b.t, c.t);
        this.e.j(a, b.e, c.e);
        this.f.j(a, b.f, c.f);
        this.x.j(a, b.x, c.x);
        this.v.j(a, b.v, c.v);
        this.w.j(a, b.w, c.w);
        this.z.j(a, b.z, c.z);
        this.y.j(a, b.y, c.y);
        this.u.j(a, b.u, c.u);
        this.h.j(a, b.h, c.h);
        this.g.j(a, b.g, c.g);
        this.c.j(a, b.c, c.c);
        this.s.j(a, b.s, c.s);
        this.a.j(a, b.a, c.a);
        this.q.j(a, b.q, c.q);
        this.r.j(a, b.r, c.r);
        this.i.j(a, b.i, c.i);
        this.l.j(a, b.l, c.l);
        this.m.j(a, b.m, c.m);
        this.p.j(a, b.p, c.p);
        this.j.j(a, b.j, c.j);
        this.k.j(a, b.k, c.k);
        this.n.j(a, b.n, c.n);
        this.o.j(a, b.o, c.o);
    };
    RadialGaugeNeedleFrame.prototype.am = function (a, b, c) {
        var d = new PathGeometry();
        var e = new PathFigure();
        var f = { $type: Point_$type, x: NaN, y: NaN };
        f = this.d.l(f, e, a, b, c);
        f = this.b.l(f, e, a, b, c);
        f = this.t.l(f, e, a, b, c);
        f = this.e.l(f, e, a, b, c);
        f = this.f.l(f, e, a, b, c);
        f = this.x.l(f, e, a, b, c);
        f = this.v.l(f, e, a, b, c);
        f = this.w.l(f, e, a, b, c);
        f = this.z.l(f, e, a, b, c);
        f = this.y.l(f, e, a, b, c);
        f = this.u.l(f, e, a, b, c);
        f = this.h.l(f, e, a, b, c);
        f = this.g.l(f, e, a, b, c);
        f = this.c.l(f, e, a, b, c);
        f = this.s.l(f, e, a, b, c);
        f = this.a.l(f, e, a, b, c);
        e._isClosed = true;
        d.c.add(e);
        var g = new PathFigure();
        if (this.q.f.count > 0 || this.r.f.count > 0) {
            f = this.q.l(f, g, a, b, c);
            f = this.r.l(f, g, a, b, c);
            g._isClosed = true;
            d.c.add(g);
        }
        return d;
    };
    RadialGaugeNeedleFrame.prototype.an = function (a, b, c) {
        var d = new PathGeometry();
        var e = { $type: Point_$type, x: NaN, y: NaN };
        var f = new PathFigure();
        if (this.m.f.count > 0 || this.p.f.count > 0) {
            e = this.m.l(e, f, a, b, c);
            e = this.p.l(e, f, a, b, c);
            f._isClosed = true;
            d.c.add(f);
        }
        var g = new PathFigure();
        if (this.n.f.count > 0 || this.o.f.count > 0) {
            e = this.n.l(e, g, a, b, c);
            e = this.o.l(e, g, a, b, c);
            g._isClosed = true;
            d.c.add(g);
        }
        return d;
    };
    RadialGaugeNeedleFrame.prototype.al = function (a, b, c) {
        var d = new PathGeometry();
        var e = { $type: Point_$type, x: NaN, y: NaN };
        var f = new PathFigure();
        if (this.i.f.count > 0 || this.l.f.count > 0) {
            e = this.i.l(e, f, a, b, c);
            e = this.l.l(e, f, a, b, c);
            f._isClosed = true;
            d.c.add(f);
        }
        var g = new PathFigure();
        if (this.j.f.count > 0 || this.k.f.count > 0) {
            e = this.j.l(e, g, a, b, c);
            e = this.k.l(e, g, a, b, c);
            g._isClosed = true;
            d.c.add(g);
        }
        return d;
    };
    RadialGaugeNeedleFrame.$t = markType(RadialGaugeNeedleFrame, 'RadialGaugeNeedleFrame');
    return RadialGaugeNeedleFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RadialGaugeRangeFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RadialGaugeRangeFrame, _super);
    function RadialGaugeRangeFrame() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.f = 0;
        _this.g = 0;
        _this.e = 0;
        _this.b = 0;
        _this.c = 0;
        _this.d = 0;
        _this.k = null;
        _this.l = null;
        _this.h = 0;
        return _this;
    }
    RadialGaugeRangeFrame.a = function (a, b, c, d) {
        var e = new RadialGaugeRangeFrame();
        e.k = BrushUtil.k(c.k, a, d.k, 0);
        e.l = BrushUtil.k(c.l, a, d.l, 0);
        e.h = b * c.h + a * d.h;
        e.f = b * c.f + a * d.f;
        e.g = b * c.g + a * d.g;
        e.e = b * c.e + a * d.e;
        e.b = b * c.b + a * d.b;
        e.c = b * c.c + a * d.c;
        e.d = b * c.d + a * d.d;
        return e;
    };
    RadialGaugeRangeFrame.prototype.m = function (a, b, c) {
        var d = new PathGeometry();
        var e = new PathFigure();
        var f = 4;
        var g = 1 / a;
        var h = false;
        if (Math.abs(this.g - this.d) < g) {
            h = true;
        }
        var i = false;
        if (Math.abs(this.f - this.c) < g) {
            i = true;
        }
        var j = false;
        if ((this.b - this.e) >= 2 * Math.PI) {
            j = true;
        }
        if (i && h && j) {
            var k = this.i(0, Math.PI, this.g, a, b, c, true);
            e._startPoint = k.c;
            var l = this.i(Math.PI, 0, this.g, a, b, c, true);
            var m = new PathFigure();
            var n = this.i(0, Math.PI, this.f, a, b, c, false);
            m._startPoint = n.c;
            var o = this.i(Math.PI, 0, this.f, a, b, c, false);
            e._segments.add(k.d);
            e._segments.add(l.d);
            m._segments.add(n.d);
            m._segments.add(o.d);
            d.c.add(e);
            d.c.add(m);
            return d;
        }
        var p = null;
        if (h) {
            var q = this.i(this.e, this.b, Math.max(0, this.g), a, b, c, true);
            e._startPoint = q.c;
            p = q.d;
        }
        else {
            var r = this.j(this.e, this.b, this.g, this.d, a, b, c, true, f);
            e._startPoint = r.c;
            p = r.d;
        }
        var s = null;
        var t = new LineSegment(1);
        if (i) {
            var u = this.i(this.e, this.b, Math.max(0, this.f), a, b, c, false);
            s = u.d;
            t.c = u.c;
        }
        else {
            var v = this.j(this.e, this.b, this.f, this.c, a, b, c, false, f);
            s = v.d;
            t.c = v.c;
        }
        e._segments.add(p);
        e._segments.add(t);
        e._segments.add(s);
        e._isFilled = true;
        e._isClosed = true;
        d.c.add(e);
        return d;
    };
    RadialGaugeRangeFrame.prototype.j = function (a, b, c, d, e, f, g, h, i) {
        var j = new PolyLineSegment();
        var k = e * c;
        var l = e * d;
        var m = Math.max(k, l);
        var n = m + m;
        var o = Math.asin(i / n) * 2;
        var p;
        var q;
        var r;
        var s = l - k;
        var t = Math.abs(b - a);
        var u = j._points;
        if (h) {
            var v = void 0;
            for (v = a; v < b; v += o) {
                r = (v - a) / t;
                q = k + r * s;
                p = { $type: Point_$type, x: f + Math.cos(v) * q, y: g + Math.sin(v) * q };
                u.add(p);
            }
            v = b;
            r = (v - a) / t;
            q = k + r * s;
            p = { $type: Point_$type, x: f + Math.cos(v) * q, y: g + Math.sin(v) * q };
            u.add(p);
        }
        else {
            var w = void 0;
            for (w = b; w > a; w -= o) {
                r = (w - b) / t;
                q = l + r * s;
                p = { $type: Point_$type, x: f + Math.cos(w) * q, y: g + Math.sin(w) * q };
                u.add(p);
            }
            w = a;
            r = (w - b) / t;
            q = l + r * s;
            p = { $type: Point_$type, x: f + Math.cos(w) * q, y: g + Math.sin(w) * q };
            u.add(p);
        }
        return new Tuple$2(Point_$type, PathSegment.$, u._inner[0], j);
    };
    RadialGaugeRangeFrame.prototype.i = function (a, b, c, d, e, f, g) {
        var h = c * d;
        var i = new ArcSegment();
        i.d = g ? 1 : 0;
        i.b = b - a > Math.PI;
        i.f = new Size(1, h, h);
        var j = g ? b : a;
        var k = g ? a : b;
        i.e = { $type: Point_$type, x: e + Math.cos(j) * h, y: f + Math.sin(j) * h };
        var l = { $type: Point_$type, x: e + Math.cos(k) * h, y: f + Math.sin(k) * h };
        return new Tuple$2(Point_$type, PathSegment.$, l, i);
    };
    RadialGaugeRangeFrame.$t = markType(RadialGaugeRangeFrame, 'RadialGaugeRangeFrame');
    return RadialGaugeRangeFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RadialGaugeScaleFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RadialGaugeScaleFrame, _super);
    function RadialGaugeScaleFrame() {
        var _this = _super.call(this) || this;
        _this.j = null;
        _this.i = null;
        _this.c = null;
        _this.e = null;
        _this.f = null;
        _this.d = null;
        _this.g = null;
        _this.h = null;
        _this.t = 0;
        _this.q = 0;
        _this.l = 0;
        _this.v = 0;
        _this.u = 0;
        _this.n = 0;
        _this.m = 0;
        _this.s = 0;
        _this.p = 0;
        _this.ac = null;
        _this.w = 0;
        _this.o = 0;
        _this.aa = null;
        _this.ab = null;
        _this.z = null;
        _this.r = 0;
        _this.k = null;
        _this.k = new List$1(RadialGaugeRangeFrame.$, 0);
        _this.j = new Array(0);
        _this.i = new Array(0);
        _this.c = new Array(0);
        _this.e = new Array(0);
        _this.f = new Array(0);
        _this.d = new Array(0);
        _this.g = new Array(0);
        _this.h = new Array(0);
        return _this;
    }
    RadialGaugeScaleFrame.prototype.a = function (a, b, c, d) {
        var e = Math.max(c.length, d.length);
        var f = Math.min(c.length, d.length);
        if (b.length != e) {
            b = new Array(e);
        }
        var g = 0;
        if (c.length > 0) {
            g = c[c.length - 1];
        }
        var h = 0;
        if (d.length > 0) {
            h = d[d.length - 1];
        }
        var i = c.length > d.length;
        var j = 0;
        for (j = 0; j < f; j++) {
            b[j] = c[j] + (d[j] - c[j]) * a;
        }
        var k;
        var l;
        for (j = f; j < e; j++) {
            if (i) {
                k = c[j];
                l = h;
            }
            else {
                k = g;
                l = d[j];
            }
            b[j] = k + (l - k) * a;
        }
        return b;
    };
    RadialGaugeScaleFrame.prototype.b = function (a, b, c, d) {
        var e = Math.max(c.length, d.length);
        var f = Math.min(c.length, d.length);
        if (b.length != e) {
            b = new Array(e);
        }
        var g = null;
        if (c.length > 0) {
            g = c[c.length - 1];
        }
        var h = null;
        if (d.length > 0) {
            h = d[d.length - 1];
        }
        var i = c.length > d.length;
        var j = 0;
        for (j = 0; j < f; j++) {
            b[j] = d[j];
        }
        var k;
        var l;
        for (j = f; j < e; j++) {
            if (i) {
                k = c[j];
                l = h;
            }
            else {
                k = g;
                l = d[j];
            }
            if (l != null) {
                b[j] = l;
            }
            else {
                b[j] = k;
            }
        }
        return b;
    };
    RadialGaugeScaleFrame.prototype.x = function (a, b, c) {
        this.ab = BrushUtil.k(b.ab, a, c.ab, 0);
        this.ac = BrushUtil.k(b.ac, a, c.ac, 0);
        this.aa = BrushUtil.k(b.aa, a, c.aa, 0);
        if (b.z == null && c.z == null) {
            this.z = null;
        }
        else {
            this.z = BrushUtil.k(b.z, a, c.z, 0);
        }
        this.t = b.t + (c.t - b.t) * a;
        this.q = b.q + (c.q - b.q) * a;
        this.s = b.s + (c.s - b.s) * a;
        this.p = b.p + (c.p - b.p) * a;
        this.r = b.r + (c.r - b.r) * a;
        this.l = b.l + (c.l - b.l) * a;
        this.v = b.v + (c.v - b.v) * a;
        this.u = b.u + (c.u - b.u) * a;
        this.n = b.n + (c.n - b.n) * a;
        this.m = b.m + (c.m - b.m) * a;
        this.w = b.w + (c.w - b.w) * a;
        this.o = b.o + (c.o - b.o) * a;
        this.j = this.a(a, this.j, b.j, c.j);
        this.i = this.a(a, this.i, b.i, c.i);
        this.c = this.a(a, this.c, b.c, c.c);
        this.f = this.a(a, this.f, b.f, c.f);
        this.d = this.a(a, this.d, b.d, c.d);
        this.g = this.a(a, this.g, b.g, c.g);
        this.h = this.a(a, this.h, b.h, c.h);
        this.e = this.b(a, this.e, b.e, c.e);
        this.y(a, this.k, b.k, c.k);
    };
    RadialGaugeScaleFrame.prototype.y = function (a, b, c, d) {
        InterpolationUtil.c(RadialGaugeRangeFrame.$, b, a, c, d, function () { return new RadialGaugeRangeFrame(); }, RadialGaugeRangeFrame.a);
    };
    RadialGaugeScaleFrame.$t = markType(RadialGaugeScaleFrame, 'RadialGaugeScaleFrame');
    return RadialGaugeScaleFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var BackingFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(BackingFrame, _super);
    function BackingFrame() {
        var _this = _super.call(this) || this;
        _this.l = null;
        _this.m = null;
        _this.h = 0;
        _this.g = 0;
        _this.c = 0;
        _this.f = 0;
        _this.e = 0;
        _this.d = 0;
        _this.b = 0;
        return _this;
    }
    BackingFrame.prototype.k = function (a, b, c) {
        this.h = b.h + (c.h - b.h) * a;
        this.l = BrushUtil.k(b.l, a, c.l, 0);
        this.m = BrushUtil.k(b.m, a, c.m, 0);
        this.g = b.g + (c.g - b.g) * a;
        this.c = b.c + (c.c - b.c) * a;
        this.e = b.e + (c.e - b.e) * a;
        this.d = b.d + (c.d - b.d) * a;
        this.b = b.b + (c.b - b.b) * a;
        this.f = b.f + (c.f - b.f) * a;
    };
    BackingFrame.prototype.i = function (a, b, c, d) {
        var _this = this;
        a._startPoint = { $type: Point_$type, x: b * this.e + c, y: 0 + d };
        var e = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: -1 * b * _this.e + c, y: 0 + d };
            $ret.b = false;
            $ret.d = 1;
            $ret.f = new Size(1, b * _this.e, b * _this.e);
            return $ret;
        })());
        var f = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: b * _this.e + c, y: 0 + d };
            $ret.b = false;
            $ret.d = 1;
            $ret.f = new Size(1, b * _this.e, b * _this.e);
            return $ret;
        })());
        a._segments.add(e);
        a._segments.add(f);
        a._isClosed = true;
    };
    BackingFrame.prototype.n = function (a, b, c) {
        var d = new PathGeometry();
        var e = new PathFigure();
        if (this.g == this.c) {
            this.i(e, a, b, c);
        }
        else {
            var f = this.e;
            var g = this.d;
            var h = this.g;
            var i = this.c;
            var j = this.f;
            var k = h;
            var l = i;
            h -= j;
            i += j;
            if ((i - h) > 2 * Math.PI) {
                this.i(e, a, b, c);
            }
            else {
                this.j(e, a, b, c);
            }
        }
        e._isClosed = true;
        d.c.add(e);
        return d;
    };
    BackingFrame.prototype.a = function (a, b) {
        return Math.abs(a - b) < 1E-05;
    };
    BackingFrame.prototype.j = function (a, b, c, d) {
        var e = this.e;
        var f = this.d;
        var g = this.g;
        var h = this.c;
        var i = this.f;
        var j = g;
        var k = h;
        g -= i;
        h += i;
        var l = Math.sin(g);
        var m = Math.cos(g);
        var n = Math.sin(h);
        var o = Math.cos(h);
        var p = this.b;
        var q = b * e;
        var r = b * f;
        if (p * 2 > (q - r)) {
            p = (q - r) / 2;
        }
        var s = p / (b - p);
        var t = Math.atan(s);
        var u = q - p;
        var v = r + p;
        var w = Math.sin(g - t);
        var x = Math.sin(g + t);
        var y = Math.cos(g - t);
        var z = Math.cos(g + t);
        var aa = Math.sin(h - t);
        var ab = Math.sin(h + t);
        var ac = Math.cos(h - t);
        var ad = Math.cos(h + t);
        var ae = Math.sin(j);
        var af = Math.sin(k);
        var ag = Math.cos(j);
        var ah = Math.cos(k);
        a._startPoint = { $type: Point_$type, x: m * u + c, y: l * u + d };
        var ai = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: z * q + c, y: x * q + d };
            $ret.b = (t * 2) > Math.PI;
            $ret.d = 1;
            $ret.f = new Size(1, p, p);
            return $ret;
        })());
        var aj = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: ac * q + c, y: aa * q + d };
            $ret.b = ((h - t) - (g + t)) > Math.PI;
            $ret.d = 1;
            $ret.f = new Size(1, q, q);
            return $ret;
        })());
        var ak = ((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: o * u + c, y: n * u + d };
            $ret.b = (t * 2) > Math.PI;
            $ret.d = 1;
            $ret.f = new Size(1, p, p);
            return $ret;
        })());
        var al = { $type: Point_$type, x: ah * q + c, y: af * q + d };
        var am = { $type: Point_$type, x: ah * r + c, y: af * r + d };
        var an = { $type: Point_$type, x: o * q + c, y: n * q + d };
        var ao = { $type: Point_$type, x: o * r + c, y: n * r + d };
        var ap = an.y;
        var aq = an.x;
        if (al.x - am.x != 0) {
            aq = c;
            var ar = (al.y - am.y) / (al.x - am.x);
            ap = ar * (c - an.x) + an.y;
        }
        ao = { $type: Point_$type, x: c, y: ap };
        if (this.a(ao.x, an.x) && this.a(ao.y, an.y)) {
            ao = am;
        }
        var as = GeometryUtil.i(ao, an, { $type: Point_$type, x: c, y: d }, r);
        var at = { $type: Point_$type, x: ag * q + c, y: ae * q + d };
        var au = { $type: Point_$type, x: ag * r + c, y: ae * r + d };
        var av = { $type: Point_$type, x: m * q + c, y: l * q + d };
        var aw = { $type: Point_$type, x: m * r + c, y: l * r + d };
        var ax = av.y;
        var ay = av.x;
        if (at.x - au.x != 0) {
            ay = c;
            var az = (at.y - au.y) / (at.x - au.x);
            ax = az * (c - av.x) + av.y;
        }
        aw = { $type: Point_$type, x: ay, y: ax };
        if (this.a(aw.x, av.x) && this.a(aw.y, av.y)) {
            aw = au;
        }
        var a0 = GeometryUtil.i(aw, av, { $type: Point_$type, x: c, y: d }, r);
        if (isNaN_(as.c.x) || isNaN_(as.c.y) || isNaN_(as.d.x) || isNaN_(as.d.y) || isNaN_(a0.c.x) || isNaN_(a0.c.y) || isNaN_(a0.d.x) || isNaN_(a0.d.y)) {
            a._startPoint = { $type: Point_$type, x: m * q + c, y: l * q + d };
            a._segments.add(aj);
            var a1 = ((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: m * q + c, y: l * q + d };
                return $ret;
            })());
            a._segments.add(a1);
        }
        else {
            var a2_1;
            var a3_1;
            if ((Math.pow(as.c.x - an.x, 2) + Math.pow(as.c.y - an.y, 2)) < (Math.pow(as.d.x - an.x, 2) + Math.pow(as.d.y - an.y, 2))) {
                a2_1 = as.c;
            }
            else {
                a2_1 = as.d;
            }
            if ((Math.pow(a0.c.x - av.x, 2) + Math.pow(a0.c.y - av.y, 2)) < (Math.pow(a0.d.x - av.x, 2) + Math.pow(a0.d.y - av.y, 2))) {
                a3_1 = a0.c;
            }
            else {
                a3_1 = a0.d;
            }
            if ((Math.pow(a3_1.x - an.x, 2) + Math.pow(a3_1.y - an.y, 2)) <= (Math.pow(a2_1.x - an.x, 2) + Math.pow(a2_1.y - an.y, 2))) {
                a._startPoint = { $type: Point_$type, x: m * q + c, y: l * q + d };
                a._segments.add(aj);
                var a4 = ((function () {
                    var $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: m * q + c, y: l * q + d };
                    return $ret;
                })());
                a._segments.add(a4);
            }
            else {
                a._segments.add(ai);
                a._segments.add(aj);
                a._segments.add(ak);
                var a5 = ((function () {
                    var $ret = new LineSegment(1);
                    $ret.c = a2_1;
                    return $ret;
                })());
                a._segments.add(a5);
                var a6_1 = GeometryUtil.e({ $type: Point_$type, x: c, y: d }, a2_1);
                var a7_1 = GeometryUtil.e({ $type: Point_$type, x: c, y: d }, a3_1);
                while (a7_1 < a6_1) {
                    a7_1 += 2 * Math.PI;
                }
                var a8 = ((function () {
                    var $ret = new ArcSegment();
                    $ret.e = a3_1;
                    $ret.b = a7_1 - a6_1 > Math.PI;
                    $ret.d = 1;
                    $ret.f = new Size(1, r, r);
                    return $ret;
                })());
                a._segments.add(a8);
                var a9 = ((function () {
                    var $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: m * u + c, y: l * u + d };
                    return $ret;
                })());
                a._segments.add(a9);
            }
        }
    };
    BackingFrame.$t = markType(BackingFrame, 'BackingFrame');
    return BackingFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RadialGaugeFrame = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RadialGaugeFrame, _super);
    function RadialGaugeFrame() {
        var _this = _super.call(this) || this;
        _this.b = null;
        _this.c = null;
        _this.a = null;
        _this.d = 0;
        _this.b = new RadialGaugeNeedleFrame();
        _this.c = new RadialGaugeScaleFrame();
        _this.a = new BackingFrame();
        return _this;
    }
    RadialGaugeFrame.prototype.e = function (a, b, c) {
        this.d = b.d + (c.d - b.d) * a;
        this.b.ag(a, b.b, c.b);
        this.c.x(a, b.c, c.c);
        this.a.k(a, b.a, c.a);
    };
    RadialGaugeFrame.$t = markType(RadialGaugeFrame, 'RadialGaugeFrame');
    return RadialGaugeFrame;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var FormatRadialGaugeLabelEventArgs = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(FormatRadialGaugeLabelEventArgs, _super);
    function FormatRadialGaugeLabelEventArgs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.actualMinimumValue = 0;
        _this.actualMaximumValue = 0;
        _this.startAngle = 0;
        _this.endAngle = 0;
        _this.angle = 0;
        _this.value = 0;
        _this.label = null;
        return _this;
    }
    FormatRadialGaugeLabelEventArgs.$t = markType(FormatRadialGaugeLabelEventArgs, 'FormatRadialGaugeLabelEventArgs', EventArgs.$);
    return FormatRadialGaugeLabelEventArgs;
}(EventArgs));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var AlignRadialGaugeLabelEventArgs = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(AlignRadialGaugeLabelEventArgs, _super);
    function AlignRadialGaugeLabelEventArgs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = 0;
        _this.height = 0;
        _this.offsetX = 0;
        _this.offsetY = 0;
        return _this;
    }
    AlignRadialGaugeLabelEventArgs.$t = markType(AlignRadialGaugeLabelEventArgs, 'AlignRadialGaugeLabelEventArgs', FormatRadialGaugeLabelEventArgs.$);
    return AlignRadialGaugeLabelEventArgs;
}(FormatRadialGaugeLabelEventArgs));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RadialGaugeNeedleParameters = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RadialGaugeNeedleParameters, _super);
    function RadialGaugeNeedleParameters() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.m = 0;
        _this.k = 0;
        _this.n = 0;
        _this.l = 0;
        _this.e = 0;
        _this.d = 0;
        _this.q = 0;
        _this.p = 0;
        _this.j = 0;
        _this.b = 0;
        _this.c = 0;
        _this.i = 0;
        _this.r = null;
        _this.s = null;
        _this.h = 0;
        _this.t = null;
        _this.u = null;
        _this.o = 0;
        _this.g = 0;
        _this.f = 0;
        return _this;
    }
    RadialGaugeNeedleParameters.prototype.a = function () {
        var a = new RadialGaugeNeedleParameters();
        a.m = this.m;
        a.k = this.k;
        a.n = this.n;
        a.l = this.l;
        a.e = this.e;
        a.d = this.d;
        a.q = this.q;
        a.p = this.p;
        a.b = this.b;
        a.c = this.c;
        a.i = this.i;
        a.r = this.r;
        a.s = this.s;
        a.h = this.h;
        a.t = this.t;
        a.u = this.u;
        a.o = this.o;
        a.g = this.g;
        a.f = this.f;
        return a;
    };
    RadialGaugeNeedleParameters.$t = markType(RadialGaugeNeedleParameters, 'RadialGaugeNeedleParameters');
    return RadialGaugeNeedleParameters;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RadialGaugeNeedlePreparer = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RadialGaugeNeedlePreparer, _super);
    function RadialGaugeNeedlePreparer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.b = null;
        return _this;
    }
    RadialGaugeNeedlePreparer.prototype.e = function (a) {
        var b = this.b;
        a.aj = b.t;
        a.ak = b.u;
        a.ah = b.r;
        a.ai = b.s;
        a.ae = b.o;
        a.aa = b.h;
        switch (b.b) {
            case 0:
                this.i(a);
                break;
            case 1:
                this.j(a);
                break;
            case 2:
                this.n(a);
                break;
            case 4:
                this.l(a);
                break;
            case 5:
                this.k(a);
                break;
            case 3:
                this.g(a);
                break;
            case 7:
                this.h(a);
                break;
            case 8:
                this.m(a);
                break;
            case 6:
                this.o(a);
                break;
        }
        switch (b.c) {
            case 3:
                this.d(a, true, false);
                break;
            case 5:
                this.d(a, false, false);
                break;
            case 4:
                this.d(a, true, true);
                break;
            case 6:
                this.d(a, false, true);
                break;
        }
    };
    RadialGaugeNeedlePreparer.prototype.d = function (a, b, c) {
        var d = this.a();
        var e = d.i;
        var f = d.g;
        var g = d.f;
        var h = a.m;
        if (b) {
            h = a.i;
        }
        var i = h.f;
        h.b = true;
        h.c = true;
        h.d = false;
        h.h = e;
        i.add({ $type: Point_$type, x: 0 + e, y: 0 });
        i.add({ $type: Point_$type, x: 0 - e, y: 0 });
        h = a.p;
        if (b) {
            h = a.l;
        }
        i = h.f;
        h.b = true;
        h.c = true;
        h.d = true;
        h.h = e;
        i.add({ $type: Point_$type, x: 0 - e, y: 0 });
        i.add({ $type: Point_$type, x: 0 + e, y: 0 });
        if (c) {
            h = a.n;
            if (b) {
                h = a.j;
            }
            i = h.f;
            h.b = true;
            h.c = false;
            h.d = false;
            h.h = g;
            i.add({ $type: Point_$type, x: 0 + g, y: 0 });
            i.add({ $type: Point_$type, x: 0 - g, y: 0 });
            h = a.o;
            if (b) {
                h = a.k;
            }
            i = h.f;
            h.b = true;
            h.c = false;
            h.d = true;
            h.h = g;
            i.add({ $type: Point_$type, x: 0 - g, y: 0 });
            i.add({ $type: Point_$type, x: 0 + g, y: 0 });
        }
    };
    RadialGaugeNeedlePreparer.prototype.o = function (a) {
        this.f(a, false, true, false, true);
    };
    RadialGaugeNeedlePreparer.prototype.m = function (a) {
        this.f(a, false, false, true, true);
    };
    RadialGaugeNeedlePreparer.prototype.l = function (a) {
        this.f(a, false, false, true, false);
    };
    RadialGaugeNeedlePreparer.prototype.n = function (a) {
        this.f(a, false, true, false, false);
    };
    RadialGaugeNeedlePreparer.prototype.h = function (a) {
        this.f(a, false, false, false, true);
    };
    RadialGaugeNeedlePreparer.prototype.c = function (a, b, c, d, e) {
        var f = 0;
        if (c == a) {
            f = 0;
        }
        else {
            f = (e - a) / (c - a);
        }
        var g = b + (d - b) * f;
        return g;
    };
    RadialGaugeNeedlePreparer.prototype.f = function (a, b, c, d, e) {
        this.p(a);
        var f = this.a();
        a.ad = f.m;
        a.ac = f.k;
        a.af = 0;
        if (!isNaN_(f.l)) {
            a.af = Math.max(a.af, f.l);
        }
        if (!isNaN_(f.i)) {
            a.af = Math.max(a.af, f.i);
        }
        if (!isNaN_(f.q)) {
            a.af = Math.max(a.af, f.q);
        }
        if (!isNaN_(f.e)) {
            a.af = Math.max(a.af, f.e);
        }
        if (c) {
            f.p = f.k;
            f.q = 0;
        }
        if (d) {
            f.p = f.k;
            f.q = f.l;
        }
        if (b) {
            var g = Math.max(f.n, f.l);
            f.n = g;
            f.l = g;
            f.p = f.k;
            f.q = f.l;
        }
        if (isNaN_(f.p)) {
            f.p = f.k;
        }
        var h = f.c == 1 || f.c == 2;
        var i = f.n;
        var j = f.l;
        if (!d && !b) {
            j = 0;
        }
        var k = f.q;
        var l = f.i;
        var m = f.m;
        var n = f.k;
        var o = f.d;
        var p = f.p;
        var q = f.e;
        var r = true;
        var s = true;
        if (isNaN_(p)) {
            r = false;
            p = n;
        }
        if (isNaN_(o)) {
            s = false;
            o = m;
        }
        var t = f.f;
        var u = f.g;
        var v = 0;
        var w = u;
        var x = u;
        var y = this.c(m, i, p, k, u);
        var z = y;
        var aa = f.c == 2;
        if (h) {
            var ab = GeometryUtil.i({ $type: Point_$type, x: m, y: i }, { $type: Point_$type, x: p, y: k }, { $type: Point_$type, x: 0, y: 0 }, l);
            if (isNaN_(ab.c.x) || isNaN_(ab.c.y) || isNaN_(ab.d.x) || isNaN_(ab.d.y)) {
                h = false;
            }
            else {
                var ac = ab.c;
                var ad = ab.d;
                w = ac.x;
                x = ad.x;
                y = ac.y;
                z = ad.y;
                if (w > x) {
                    var ae = w;
                    w = x;
                    x = ae;
                    ae = y;
                    y = z;
                    z = ae;
                }
            }
        }
        if (aa) {
            var af = GeometryUtil.i({ $type: Point_$type, x: m, y: i }, { $type: Point_$type, x: p, y: k }, { $type: Point_$type, x: 0, y: 0 }, t);
            if ((isNaN_(af.c.x) || isNaN_(af.c.y) || isNaN_(af.d.x) || isNaN_(af.d.y)) || h) {
                aa = true;
            }
            else {
                aa = false;
            }
        }
        if (m > x || n < w) {
            h = false;
            w = m;
            x = m;
        }
        var ag = false;
        var ah = false;
        if (h && m >= w) {
            ag = true;
        }
        if (h && n <= x) {
            ah = true;
        }
        if (isNaN_(o) || o > w) {
            o = w;
        }
        if (p < x) {
            p = x;
        }
        var ai = e;
        var aj = l;
        var ak = l;
        if (o + q > w) {
            ai = false;
        }
        var al = o;
        var am = i;
        var an = o;
        var ao = i;
        var ap = w;
        var aq = x;
        var ar = y;
        var as = z;
        var at = w;
        var au = x;
        var av = y;
        var aw = z;
        if (ai) {
            var ax = GeometryUtil.i({ $type: Point_$type, x: m, y: i }, { $type: Point_$type, x: p, y: k }, { $type: Point_$type, x: o, y: 0 }, q);
            if ((!isNaN_(ax.c.x) && !isNaN_(ax.c.y) && !isNaN_(ax.d.x) && !isNaN_(ax.d.y))) {
                ai = true;
                al = ax.c.x;
                am = ax.c.y;
                an = ax.d.x;
                ao = ax.d.y;
                if (al > an) {
                    var ay = al;
                    al = an;
                    an = ay;
                    ay = am;
                    am = ao;
                    ao = ay;
                }
            }
            else {
                ai = false;
            }
        }
        if (ag) {
            ai = false;
        }
        if (ai && m >= al) {
            ag = true;
            aj = q;
            ap = al;
            ar = am;
            aq = an;
            as = ao;
        }
        if (ai && n <= an) {
            ah = true;
            ak = q;
            ak = q;
            at = al;
            av = am;
            au = an;
            aw = ao;
        }
        var az = m;
        var a0 = a.a;
        var a1 = a0.f;
        var a2 = i;
        if (ag) {
            az = ap;
            a0.b = true;
            a0.d = false;
            a0.c = false;
            a0.h = aj;
            o = ap;
            m = ap;
            a2 = ar;
            i = ar;
            h = false;
        }
        if (ah) {
            p = au;
            n = au;
            h = false;
        }
        var a3 = ag || ah || h;
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a0 = a.d;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: a2 });
        az = al;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a0 = a.b;
        a1 = a0.f;
        if (ai) {
            a0.b = true;
            a0.d = false;
            a0.c = false;
            a0.h = q;
        }
        a1.add({ $type: Point_$type, x: az, y: a2 });
        az = an;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a0 = a.t;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: a2 });
        az = w;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a0 = a.e;
        a1 = a0.f;
        if (a3) {
            a0.b = true;
            a0.d = false;
            a0.c = false;
            a0.h = l;
        }
        a1.add({ $type: Point_$type, x: az, y: a2 });
        az = x;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a0 = a.f;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: a2 });
        az = p;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a0 = a.x;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a0 = a.v;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: a2 });
        az = n;
        a2 = this.c(p, k, n, j, az);
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a0 = a.w;
        a1 = a0.f;
        if (ah) {
            az = au;
            a0.b = true;
            a0.d = false;
            a0.c = false;
            a0.h = ak;
        }
        a1.add({ $type: Point_$type, x: az, y: a2 });
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a0 = a.z;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        az = p;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a0 = a.y;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a0 = a.u;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        az = x;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a0 = a.h;
        a1 = a0.f;
        if (a3) {
            a0.b = true;
            a0.d = false;
            a0.c = false;
            a0.h = l;
        }
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        az = w;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a0 = a.g;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        az = an;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a0 = a.c;
        a1 = a0.f;
        if (ai) {
            a0.b = true;
            a0.d = false;
            a0.c = false;
            a0.h = q;
        }
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        az = al;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a0 = a.s;
        a1 = a0.f;
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        az = m;
        a2 = this.c(m, i, p, k, az);
        a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
        a0 = a.q;
        a1 = a0.f;
        if (aa && a3) {
            a0.b = true;
            a0.c = true;
            a0.d = false;
            a0.h = t;
            a1.add({ $type: Point_$type, x: 0 + t, y: 0 });
            a1.add({ $type: Point_$type, x: 0 - t, y: 0 });
        }
        a0 = a.r;
        a1 = a0.f;
        if (aa && a3) {
            a0.b = true;
            a0.c = true;
            a0.d = true;
            a0.h = t;
            a1.add({ $type: Point_$type, x: 0 - t, y: 0 });
            a1.add({ $type: Point_$type, x: 0 + t, y: 0 });
        }
    };
    RadialGaugeNeedlePreparer.prototype.g = function (a) {
        this.f(a, false, false, false, false);
    };
    RadialGaugeNeedlePreparer.prototype.k = function (a) {
        this.f(a, true, false, false, true);
    };
    RadialGaugeNeedlePreparer.prototype.a = function () {
        var a = this.b;
        var b = this.b.a();
        var c = 0;
        var d = 0.48;
        var e = NaN;
        var f = NaN;
        var g = 0.15;
        var h = 0.1;
        var i = 0.1;
        var j = 0.1;
        var k = 0.14;
        var l = 0.06;
        switch (a.b) {
            case 3:
                f = 0.4;
                break;
            case 4:
                h = 0.06;
                i = 0.02;
                break;
            case 7:
                f = 0.4;
                c = -0.3;
                e = -0.2;
                k = 0.14;
                break;
            case 5:
                c = -0.3;
                e = -0.2;
                k = 0.14;
                break;
            case 8:
                i = 0.06;
                c = -0.3;
                e = -0.2;
                k = 0.14;
                break;
            case 6:
                c = -0.3;
                e = -0.2;
                k = 0.14;
                break;
        }
        var m = a.m;
        var n = a.k;
        var o = a.c == 1 || a.c == 2;
        if (isNaN_(m)) {
            m = c;
        }
        if (isNaN_(n)) {
            n = d;
        }
        var p = Math.min(m, n);
        var q = Math.max(m, n);
        m = p;
        n = q;
        var r = a.n;
        if (isNaN_(r)) {
            r = h;
        }
        var s = a.l;
        if (isNaN_(s)) {
            s = i;
        }
        var t = a.i;
        var u = a.f;
        if (isNaN_(t)) {
            t = g;
        }
        if (isNaN_(u)) {
            u = j;
        }
        var v = Math.max(t, u);
        var w = Math.min(t, u);
        t = v;
        u = w;
        var x = a.d;
        if (isNaN_(x)) {
            x = e;
        }
        if (!isNaN_(x)) {
            if (x < m) {
                x = NaN;
            }
            if (x > 0 && m <= 0) {
                x = NaN;
            }
            if (x > n) {
                x = n;
            }
        }
        var y = a.p;
        if (isNaN_(y)) {
            y = f;
        }
        if (!isNaN_(y)) {
            if (y > n) {
                y = NaN;
            }
            if (y < 0 && n >= 0) {
                y = NaN;
            }
            if (y < m) {
                y = m;
            }
        }
        var z = 0;
        if (m > 0) {
            z = m;
        }
        if (n < 0) {
            z = m;
        }
        if (t <= 0) {
            t = 0;
        }
        var aa = a.e;
        var ab = a.q;
        if (isNaN_(aa)) {
            aa = k;
        }
        if (isNaN_(ab)) {
            ab = l;
        }
        b.i = t / 2;
        b.f = u / 2;
        b.d = x;
        b.p = y;
        b.m = m;
        b.k = n;
        b.g = z;
        b.n = r / 2;
        b.l = s / 2;
        b.q = ab / 2;
        b.e = aa / 2;
        return b;
    };
    RadialGaugeNeedlePreparer.prototype.j = function (a) {
        this.f(a, true, false, false, false);
    };
    RadialGaugeNeedlePreparer.prototype.p = function (a) {
        a.a.k();
        a.d.k();
        a.b.k();
        a.t.k();
        a.e.k();
        a.f.k();
        a.x.k();
        a.v.k();
        a.w.k();
        a.z.k();
        a.y.k();
        a.u.k();
        a.h.k();
        a.g.k();
        a.c.k();
        a.s.k();
        a.q.k();
        a.r.k();
        a.i.k();
        a.l.k();
        a.m.k();
        a.p.k();
        a.j.k();
        a.k.k();
        a.n.k();
        a.o.k();
    };
    RadialGaugeNeedlePreparer.prototype.i = function (a) {
        this.p(a);
        var b = 0;
        var c = 0;
        var d = 0;
        var e = 0;
        var f = 0;
        var g = 0;
        var h = 0;
        var i = a.a;
        var j = i.f;
        j.add({ $type: Point_$type, x: b, y: h });
        j.add({ $type: Point_$type, x: b, y: g });
        i = a.d;
        j = i.f;
        j.add({ $type: Point_$type, x: b, y: g });
        j.add({ $type: Point_$type, x: d, y: g });
        i = a.b;
        j = i.f;
        j.add({ $type: Point_$type, x: d, y: g });
        j.add({ $type: Point_$type, x: d, y: g });
        var k = f;
        var l = f;
        i = a.t;
        j = i.f;
        j.add({ $type: Point_$type, x: d, y: g });
        j.add({ $type: Point_$type, x: k, y: g });
        i = a.e;
        j = i.f;
        j.add({ $type: Point_$type, x: k, y: g });
        j.add({ $type: Point_$type, x: l, y: g });
        i = a.f;
        j = i.f;
        j.add({ $type: Point_$type, x: l, y: g });
        j.add({ $type: Point_$type, x: e, y: g });
        i = a.x;
        j = i.f;
        j.add({ $type: Point_$type, x: e, y: g });
        j.add({ $type: Point_$type, x: e, y: g });
        i = a.v;
        j = i.f;
        j.add({ $type: Point_$type, x: e, y: g });
        j.add({ $type: Point_$type, x: c, y: g });
        i = a.w;
        j = i.f;
        j.add({ $type: Point_$type, x: c, y: g });
        j.add({ $type: Point_$type, x: c, y: h });
        i = a.z;
        j = i.f;
        j.add({ $type: Point_$type, x: c, y: h });
        j.add({ $type: Point_$type, x: e, y: h });
        i = a.y;
        j = i.f;
        j.add({ $type: Point_$type, x: e, y: h });
        j.add({ $type: Point_$type, x: e, y: h });
        i = a.u;
        j = i.f;
        j.add({ $type: Point_$type, x: e, y: h });
        j.add({ $type: Point_$type, x: l, y: h });
        i = a.h;
        j = i.f;
        j.add({ $type: Point_$type, x: l, y: h });
        j.add({ $type: Point_$type, x: k, y: h });
        i = a.g;
        j = i.f;
        j.add({ $type: Point_$type, x: k, y: h });
        j.add({ $type: Point_$type, x: d, y: h });
        i = a.c;
        j = i.f;
        j.add({ $type: Point_$type, x: d, y: h });
        j.add({ $type: Point_$type, x: d, y: h });
        i = a.s;
        j = i.f;
        j.add({ $type: Point_$type, x: d, y: h });
        j.add({ $type: Point_$type, x: b, y: h });
    };
    RadialGaugeNeedlePreparer.$t = markType(RadialGaugeNeedlePreparer, 'RadialGaugeNeedlePreparer');
    return RadialGaugeNeedlePreparer;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var GaugeVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(GaugeVisualData, _super);
    function GaugeVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._scalePath = null;
        _this._needlePath = null;
        _this._backingPath = null;
        _this._underlayPath = null;
        _this._overlayPath = null;
        _this._scale = null;
        _this._scaleLabels = null;
        _this._scaleTickmarks = null;
        _this._needle = null;
        _this._ranges = null;
        _this._name = null;
        _this._viewport = null;
        return _this;
    }
    Object.defineProperty(GaugeVisualData.prototype, "scalePath", {
        get: function () {
            return this._scalePath;
        },
        set: function (a) {
            this._scalePath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "needlePath", {
        get: function () {
            return this._needlePath;
        },
        set: function (a) {
            this._needlePath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "backingPath", {
        get: function () {
            return this._backingPath;
        },
        set: function (a) {
            this._backingPath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "underlayPath", {
        get: function () {
            return this._underlayPath;
        },
        set: function (a) {
            this._underlayPath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "overlayPath", {
        get: function () {
            return this._overlayPath;
        },
        set: function (a) {
            this._overlayPath = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "scale", {
        get: function () {
            return this._scale;
        },
        set: function (a) {
            this._scale = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "scaleLabels", {
        get: function () {
            return this._scaleLabels;
        },
        set: function (a) {
            this._scaleLabels = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "scaleTickmarks", {
        get: function () {
            return this._scaleTickmarks;
        },
        set: function (a) {
            this._scaleTickmarks = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "needle", {
        get: function () {
            return this._needle;
        },
        set: function (a) {
            this._needle = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "ranges", {
        get: function () {
            return this._ranges;
        },
        set: function (a) {
            this._ranges = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeVisualData.prototype, "name", {
        get: function () {
            return this._name;
        },
        set: function (a) {
            this._name = a;
        },
        enumerable: true,
        configurable: true
    });
    GaugeVisualData.prototype.scaleByViewport = function () {
        var e_1, _a, e_2, _b, e_3, _c;
        if (this.scalePath != null) {
            this.scalePath.scaleByViewport(this.viewport);
        }
        if (this.needlePath != null) {
            this.needlePath.scaleByViewport(this.viewport);
        }
        if (this.backingPath != null) {
            this.backingPath.scaleByViewport(this.viewport);
        }
        if (this.underlayPath != null) {
            this.underlayPath.scaleByViewport(this.viewport);
        }
        if (this.overlayPath != null) {
            this.overlayPath.scaleByViewport(this.viewport);
        }
        if (this.scaleLabels != null) {
            try {
                for (var _d = __values(fromEnum(this.scaleLabels)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var a = _e.value;
                    a.scaleByViewport(this.viewport);
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return))
                        _a.call(_d);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        }
        if (this.scaleTickmarks != null) {
            try {
                for (var _f = __values(fromEnum(this.scaleTickmarks)), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var b = _g.value;
                    if (b.tickPath != null) {
                        b.tickPath.scaleByViewport(this.viewport);
                    }
                }
            }
            catch (e_2_1) {
                e_2 = { error: e_2_1 };
            }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return))
                        _b.call(_f);
                }
                finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
        }
        if (this.ranges != null) {
            try {
                for (var _h = __values(fromEnum(this.ranges)), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var c = _j.value;
                    if (c.rangePath != null) {
                        c.rangePath.scaleByViewport(this.viewport);
                    }
                }
            }
            catch (e_3_1) {
                e_3 = { error: e_3_1 };
            }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return))
                        _c.call(_h);
                }
                finally {
                    if (e_3)
                        throw e_3.error;
                }
            }
        }
    };
    GaugeVisualData.prototype.serialize = function () {
        var e_4, _a, e_5, _b, e_6, _c;
        var a = new StringBuilder(0);
        var b = true;
        a.u("{");
        if (this.scalePath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("scalePath: ");
            a.u(this.scalePath.serialize());
        }
        if (this.needlePath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("needlePath: ");
            a.u(this.needlePath.serialize());
        }
        if (this.backingPath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("backingPath: ");
            a.u(this.backingPath.serialize());
        }
        if (this.underlayPath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("underlayPath: ");
            a.u(this.underlayPath.serialize());
        }
        if (this.overlayPath != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("overlayPath: ");
            a.u(this.overlayPath.serialize());
        }
        if (this.scaleLabels != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            var c = true;
            a.l("scaleLabels: [");
            try {
                for (var _d = __values(fromEnum(this.scaleLabels)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var d = _e.value;
                    if (c) {
                        c = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(d.serialize());
                }
            }
            catch (e_4_1) {
                e_4 = { error: e_4_1 };
            }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return))
                        _a.call(_d);
                }
                finally {
                    if (e_4)
                        throw e_4.error;
                }
            }
            a.u("]");
        }
        if (this.scaleTickmarks != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            var e = true;
            a.l("scaleTickmarks: [");
            try {
                for (var _f = __values(fromEnum(this.scaleTickmarks)), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var f = _g.value;
                    if (e) {
                        e = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(f.serialize());
                }
            }
            catch (e_5_1) {
                e_5 = { error: e_5_1 };
            }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return))
                        _b.call(_f);
                }
                finally {
                    if (e_5)
                        throw e_5.error;
                }
            }
            a.u("]");
        }
        if (this.needle != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("needle: ");
            a.u(this.needle.serialize());
        }
        if (this.ranges != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            var g = true;
            a.l("ranges: [");
            try {
                for (var _h = __values(fromEnum(this.ranges)), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var h = _j.value;
                    if (g) {
                        g = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(h.serialize());
                }
            }
            catch (e_6_1) {
                e_6 = { error: e_6_1 };
            }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return))
                        _c.call(_h);
                }
                finally {
                    if (e_6)
                        throw e_6.error;
                }
            }
            a.u("]");
        }
        if (this.name != null) {
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("name: '");
            a.l(this.name);
            a.u("'");
        }
        if (b) {
            b = false;
        }
        else {
            a.l(", ");
        }
        a.l("viewport: {");
        a.l("left: " + this.viewport.left + ", top: " + this.viewport.top + ", width: " + this.viewport.width + ", height: " + this.viewport.height);
        a.u("}");
        a.u("}");
        return a.toString();
    };
    Object.defineProperty(GaugeVisualData.prototype, "viewport", {
        get: function () {
            return this._viewport;
        },
        set: function (a) {
            this._viewport = a;
        },
        enumerable: true,
        configurable: true
    });
    GaugeVisualData.$t = markType(GaugeVisualData, 'GaugeVisualData');
    return GaugeVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var ScaleLabelVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ScaleLabelVisualData, _super);
    function ScaleLabelVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._labelValue = null;
        _this._labelSize = null;
        _this._labelPosition = null;
        _this._appearance = null;
        return _this;
    }
    Object.defineProperty(ScaleLabelVisualData.prototype, "labelValue", {
        get: function () {
            return this._labelValue;
        },
        set: function (a) {
            this._labelValue = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleLabelVisualData.prototype, "labelSize", {
        get: function () {
            return this._labelSize;
        },
        set: function (a) {
            this._labelSize = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleLabelVisualData.prototype, "labelPosition", {
        get: function () {
            return this._labelPosition;
        },
        set: function (a) {
            this._labelPosition = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleLabelVisualData.prototype, "appearance", {
        get: function () {
            return this._appearance;
        },
        set: function (a) {
            this._appearance = a;
        },
        enumerable: true,
        configurable: true
    });
    ScaleLabelVisualData.prototype.scaleByViewport = function (a) {
        this.labelPosition = new PointData((this.labelPosition.x - a.left) / a.width, (this.labelPosition.y - a.top) / a.height);
        this.labelSize = new SizeData((this.labelSize.width) / a.width, (this.labelSize.height) / a.height);
    };
    ScaleLabelVisualData.prototype.serialize = function () {
        return "{ labelValue: '" + this.labelValue + "', labelSize: { width: " + this.labelSize.width + ", height: " + this.labelSize.height + "}, labelPosition: { x: " + this.labelPosition.x + ", y: " + this.labelPosition.y + "}, appearance: " + this.appearance.serialize() + "}";
    };
    ScaleLabelVisualData.$t = markType(ScaleLabelVisualData, 'ScaleLabelVisualData');
    return ScaleLabelVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var ScaleLabelVisualDataList = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ScaleLabelVisualDataList, _super);
    function ScaleLabelVisualDataList() {
        return _super.call(this, ScaleLabelVisualData.$, 0) || this;
    }
    ScaleLabelVisualDataList.$t = markType(ScaleLabelVisualDataList, 'ScaleLabelVisualDataList', List$1.$.specialize(ScaleLabelVisualData.$));
    return ScaleLabelVisualDataList;
}(List$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var ScaleTickmarkVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ScaleTickmarkVisualData, _super);
    function ScaleTickmarkVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._tickPath = null;
        return _this;
    }
    Object.defineProperty(ScaleTickmarkVisualData.prototype, "tickPath", {
        get: function () {
            return this._tickPath;
        },
        set: function (a) {
            this._tickPath = a;
        },
        enumerable: true,
        configurable: true
    });
    ScaleTickmarkVisualData.prototype.serialize = function () {
        return "{ tickPath: " + this.tickPath.serialize() + "}";
    };
    ScaleTickmarkVisualData.$t = markType(ScaleTickmarkVisualData, 'ScaleTickmarkVisualData');
    return ScaleTickmarkVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var ScaleTickmarkVisualDataList = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ScaleTickmarkVisualDataList, _super);
    function ScaleTickmarkVisualDataList() {
        return _super.call(this, ScaleTickmarkVisualData.$, 0) || this;
    }
    ScaleTickmarkVisualDataList.$t = markType(ScaleTickmarkVisualDataList, 'ScaleTickmarkVisualDataList', List$1.$.specialize(ScaleTickmarkVisualData.$));
    return ScaleTickmarkVisualDataList;
}(List$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RangeVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RangeVisualData, _super);
    function RangeVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._rangePath = null;
        return _this;
    }
    Object.defineProperty(RangeVisualData.prototype, "rangePath", {
        get: function () {
            return this._rangePath;
        },
        set: function (a) {
            this._rangePath = a;
        },
        enumerable: true,
        configurable: true
    });
    RangeVisualData.prototype.serialize = function () {
        return "{ rangePath: " + this.rangePath.serialize() + "}";
    };
    RangeVisualData.$t = markType(RangeVisualData, 'RangeVisualData');
    return RangeVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var RangeVisualDataList = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(RangeVisualDataList, _super);
    function RangeVisualDataList() {
        return _super.call(this, RangeVisualData.$, 0) || this;
    }
    RangeVisualDataList.$t = markType(RangeVisualDataList, 'RangeVisualDataList', List$1.$.specialize(RangeVisualData.$));
    return RangeVisualDataList;
}(List$1));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var NeedleVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(NeedleVisualData, _super);
    function NeedleVisualData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._angle = 0;
        return _this;
    }
    Object.defineProperty(NeedleVisualData.prototype, "angle", {
        get: function () {
            return this._angle;
        },
        set: function (a) {
            this._angle = a;
        },
        enumerable: true,
        configurable: true
    });
    NeedleVisualData.prototype.serialize = function () {
        return "{ angle: " + this.angle.toString() + "}";
    };
    NeedleVisualData.$t = markType(NeedleVisualData, 'NeedleVisualData');
    return NeedleVisualData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var XamRadialGauge = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(XamRadialGauge, _super);
    function XamRadialGauge() {
        var _this = _super.call(this) || this;
        _this.propertyChanged = null;
        _this._view = null;
        _this.ay = null;
        _this.bn = 0;
        _this.bm = 100;
        _this.a8 = false;
        _this.formatLabel = null;
        _this.aj = null;
        _this.alignLabel = null;
        _this.valueChanged = null;
        _this.a7 = false;
        _this.av = null;
        _this.io = new Size(1, NaN, NaN);
        _this.il = null;
        _this.bj = null;
        _this.bk = null;
        _this.aq = null;
        _this.ap = null;
        _this.ao = null;
        _this.bl = new Stack$1(TextBlock.$);
        _this.bi = new List$1(Path.$, 0);
        _this.bh = new List$1(Path.$, 0);
        _this.bg = new List$1(Path.$, 0);
        _this.bq = 0;
        _this.a5 = null;
        _this.a3 = null;
        _this.a2 = null;
        _this.a4 = null;
        _this.bp = NaN;
        _this.bo = 1;
        _this.view = new XamRadialGaugeView(_this);
        _this.view.av();
        _this.il = Rect.empty;
        _this.aq = new RadialGaugeFrame();
        _this.ap = new RadialGaugeFrame();
        _this.ao = new RadialGaugeFrame();
        _this.ranges = new RadialGaugeRangeCollection();
        _this.a7 = true;
        _this.ay = new DoubleAnimator(0, 1, _this.dn);
        var a = _this.ay;
        a.propertyChanged = delegateCombine(a.propertyChanged, runOn(_this, _this.fn));
        _this.ab = XamRadialGauge.$;
        _this.a2 = ((function () {
            var $ret = new StackPool$1(TextBlock.$);
            $ret.b = runOn(_this.view, _this.view.an);
            $ret.c = runOn(_this.view, _this.view.ao);
            $ret.d = runOn(_this.view, _this.view.ap);
            $ret.j = runOn(_this.view, _this.view.be);
            return $ret;
        })());
        _this.a5 = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.ay);
            $ret.c = runOn(_this.view, _this.view.az);
            $ret.d = runOn(_this.view, _this.view.a0);
            $ret.j = runOn(_this.view, _this.view.b0);
            return $ret;
        })());
        _this.a3 = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.ay);
            $ret.c = runOn(_this.view, _this.view.az);
            $ret.d = runOn(_this.view, _this.view.a0);
            $ret.j = runOn(_this.view, _this.view.b0);
            return $ret;
        })());
        _this.a4 = ((function () {
            var $ret = new StackPool$1(Path.$);
            $ret.b = runOn(_this.view, _this.view.a3);
            $ret.c = runOn(_this.view, _this.view.a4);
            $ret.d = runOn(_this.view, _this.view.a5);
            $ret.j = runOn(_this.view, _this.view.b1);
            return $ret;
        })());
        _this.av = new RadialGaugeScaler(_this.bs, _this.br, _this.da, _this.c5, _this.ii);
        return _this;
    }
    XamRadialGauge.prototype.fz = function (a) {
        this.f4(a);
    };
    XamRadialGauge.prototype.f4 = function (a) {
        var b = this.propertyChanged;
        if (b != null) {
            b(this, new PropertyChangedEventArgs(a));
        }
    };
    XamRadialGauge.prototype.onDetachedFromUI = function () {
        this.view.au();
    };
    XamRadialGauge.prototype.onAttachedToUI = function () {
        this.view.aq();
    };
    XamRadialGauge.prototype.dd = function (a) {
        return this.av.h(a);
    };
    XamRadialGauge.prototype.dl = function (a) {
        return this.av.j(a);
    };
    XamRadialGauge.prototype.b5 = function (a) {
        var b = this.im;
        var c = Math.min(b.width / 2, b.height / 2) * this.c0;
        var d = this.ij();
        var e = d.x;
        var f = d.y;
        var g = GeometryUtil.e({ $type: Point_$type, x: e, y: f }, a);
        if (this.av != null && g < this.av.i) {
            g += Math.PI * 2;
        }
        if (this.av != null && g > this.av.g) {
            g -= Math.PI * 2;
        }
        var h = this.dl(g);
        return h;
    };
    XamRadialGauge.prototype.ik = function (a, b) {
        var c = this.dd(a);
        var d = Math.min(this.im.width / 2, this.im.height / 2) * this.c0 * b;
        var e = this.ij();
        var f = e.x + Math.cos(c) * d;
        var g = e.y + Math.sin(c) * d;
        return { $type: Point_$type, x: f, y: g };
    };
    XamRadialGauge.prototype.h9 = function (a, b) {
        if (b != null && b.count > 0) {
            return b.item(a % b.count);
        }
        else {
            return null;
        }
    };
    Object.defineProperty(XamRadialGauge.prototype, "view", {
        get: function () {
            return this._view;
        },
        set: function (a) {
            this._view = a;
        },
        enumerable: true,
        configurable: true
    });
    XamRadialGauge.prototype.fn = function (a, b) {
        this.dk = this.ay.o;
    };
    Object.defineProperty(XamRadialGauge.prototype, "bs", {
        get: function () {
            return this.bn;
        },
        set: function (a) {
            this.bn = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamRadialGauge.prototype, "br", {
        get: function () {
            return this.bm;
        },
        set: function (a) {
            this.bm = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamRadialGauge.prototype, "cw", {
        get: function () {
            return this.c(XamRadialGauge.hl);
        },
        set: function (a) {
            this.h(XamRadialGauge.hl, a);
        },
        enumerable: true,
        configurable: true
    });
    XamRadialGauge.prototype.refresh = function () {
        this.a7 = true;
        this.view.a7();
    };
    XamRadialGauge.prototype.fy = function (a, b, c) {
        switch (a) {
            case XamRadialGauge.$$p[29]:
            case XamRadialGauge.$$p[32]:
            case XamRadialGauge.$$p[33]:
            case XamRadialGauge.$$p[35]:
            case XamRadialGauge.$$p[0]:
            case XamRadialGauge.$$p[4]:
            case XamRadialGauge.$$p[48]:
            case XamRadialGauge.$$p[56]:
            case XamRadialGauge.$$p[22]:
                this.view.ar(a, b, c);
                break;
            case XamRadialGauge.$$p[45]:
                this.view.aw(b, c);
                break;
            case XamRadialGauge.$$p[46]:
                this.view.ax(b, c);
                break;
            case "PixelScalingRatio":
                if (isNaN_(DeviceUtils.a(this.cz))) {
                    this.bt = 1;
                }
                else {
                    this.bt = DeviceUtils.a(this.cz);
                }
                break;
            case "ActualPixelScalingRatio":
                this.view.a1();
                break;
        }
        switch (a) {
            case XamRadialGauge.$$p[17]:
            case XamRadialGauge.$$p[18]:
                if (this.d9 != null) {
                    this.aj = new BindingFormatter();
                    this.aj.j = this.d9;
                    this.aj.d = this.ag;
                }
                else {
                    this.aj = null;
                }
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[62]:
                if (this.valueChanged != null) {
                    this.valueChanged(this, new DoubleValueChangedEventArgs(b, c));
                }
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[0]:
            case XamRadialGauge.$$p[4]:
            case XamRadialGauge.$$p[7]:
            case XamRadialGauge.$$p[6]:
            case XamRadialGauge.$$p[2]:
            case XamRadialGauge.$$p[3]:
            case XamRadialGauge.$$p[5]:
            case XamRadialGauge.$$p[1]:
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[55]:
            case XamRadialGauge.$$p[53]:
            case XamRadialGauge.$$p[49]:
            case XamRadialGauge.$$p[51]:
            case XamRadialGauge.$$p[52]:
                this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[21]:
            case XamRadialGauge.$$p[20]:
                var d = this.cc;
                var e = this.ca;
                if (isInfinity(d) || isNaN_(d)) {
                    d = 0;
                }
                if (isInfinity(e) || isNaN_(e)) {
                    e = 100;
                }
                this.bs = Math.min(d, e);
                this.br = Math.max(d, e);
                this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[13]:
            case XamRadialGauge.$$p[54]:
            case XamRadialGauge.$$p[50]:
            case XamRadialGauge.$$p[16]:
            case XamRadialGauge.$$p[58]:
            case XamRadialGauge.$$p[57]:
            case XamRadialGauge.$$p[56]:
            case XamRadialGauge.$$p[48]:
            case XamRadialGauge.$$p[19]:
            case XamRadialGauge.$$p[23]:
            case XamRadialGauge.$$p[59]:
            case XamRadialGauge.$$p[26]:
            case XamRadialGauge.$$p[22]:
            case XamRadialGauge.$$p[25]:
            case XamRadialGauge.$$p[24]:
            case XamRadialGauge.$$p[8]:
            case XamRadialGauge.$$p[9]:
            case XamRadialGauge.$$p[44]:
            case XamRadialGauge.$$p[10]:
                this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[42]:
            case XamRadialGauge.$$p[30]:
            case XamRadialGauge.$$p[29]:
            case XamRadialGauge.$$p[32]:
            case "NeedleStartWidth":
            case XamRadialGauge.$$p[31]:
            case XamRadialGauge.$$p[33]:
            case XamRadialGauge.$$p[35]:
            case XamRadialGauge.$$p[43]:
            case XamRadialGauge.$$p[37]:
            case XamRadialGauge.$$p[27]:
            case XamRadialGauge.$$p[28]:
            case XamRadialGauge.$$p[39]:
            case XamRadialGauge.$$p[40]:
            case XamRadialGauge.$$p[38]:
            case XamRadialGauge.$$p[34]:
            case XamRadialGauge.$$p[36]:
            case XamRadialGauge.$$p[41]:
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[60]:
                this.ay.r = this.dn;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[61]:
                this.ay.b = this.a0;
                break;
            case "TransitionProgress":
                if (this.dk >= 1) {
                    this.ay.w();
                    var f = this.ap;
                    this.ap = this.aq;
                    this.aq = f;
                    this.f1();
                    this.f2();
                    this.f3();
                    this.f9(this.ap);
                    this.ga(this.ap);
                    this.gb(this.ap);
                    this.view.ae();
                    return;
                }
                this.ao.e(this.dk, this.aq, this.ap);
                this.f9(this.ao);
                this.ga(this.ao);
                this.gb(this.ao);
                this.view.ae();
                break;
            case XamRadialGauge.$$p[47]:
                var g = b;
                var h = c;
                if (g != null) {
                    var i = g;
                    i.collectionChanged = delegateRemove(i.collectionChanged, runOn(this, this.f7));
                }
                if (h != null) {
                    var j = h;
                    j.collectionChanged = delegateCombine(j.collectionChanged, runOn(this, this.f7));
                }
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[46]:
            case XamRadialGauge.$$p[45]:
                this.a7 = true;
                this.view.a7();
                break;
            case XamRadialGauge.$$p[11]:
            case XamRadialGauge.$$p[12]:
                this.a7 = true;
                this.view.bd();
                this.view.a7();
                break;
        }
        this.fz(a);
    };
    XamRadialGauge.prototype.gd = function () {
        this.view.ba();
    };
    XamRadialGauge.prototype.f7 = function (a, b) {
        var e_1, _a, e_2, _b;
        if (b.oldItems != null) {
            try {
                for (var _c = __values(fromEn(b.oldItems)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var c = _d.value;
                    c.propertyChanged = delegateRemove(c.propertyChanged, runOn(this, this.f6));
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return))
                        _a.call(_c);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        }
        if (b.newItems != null) {
            try {
                for (var _e = __values(fromEn(b.newItems)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var d = _f.value;
                    d.propertyChanged = delegateCombine(d.propertyChanged, runOn(this, this.f6));
                }
            }
            catch (e_2_1) {
                e_2 = { error: e_2_1 };
            }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return))
                        _b.call(_e);
                }
                finally {
                    if (e_2)
                        throw e_2.error;
                }
            }
        }
        this.a7 = true;
        this.view.a7();
    };
    XamRadialGauge.prototype.f6 = function (a, b) {
        this.a7 = true;
        this.view.a7();
    };
    Object.defineProperty(XamRadialGauge.prototype, "im", {
        get: function () {
            return this.il;
        },
        set: function (a) {
            var b = this.il;
            this.il = a;
            if (!b.equals1(this.il)) {
                this.f0(b, this.il);
            }
        },
        enumerable: true,
        configurable: true
    });
    XamRadialGauge.prototype.f0 = function (a, b) {
        this.a7 = true;
        this.view.a7();
    };
    XamRadialGauge.prototype.bb = function () {
        return !isNaN_(this.bs) && !isNaN_(this.br) && !isNaN_(this.dm) && !this.im.isEmpty && this.view.n();
    };
    XamRadialGauge.prototype.fo = function () {
        if (!this.bb()) {
            return;
        }
        if (this.a7) {
            if (this.a6) {
                if (this.ay.g) {
                    this.ay.t();
                }
                var a = this.aq;
                this.aq = this.ao;
                this.ao = a;
            }
            else {
                var b = this.aq;
                this.aq = this.ap;
                this.ap = b;
            }
        }
        else if (this.a6) {
            this.ao.e(this.dk, this.aq, this.ap);
            this.f9(this.ao);
            this.ga(this.ao);
            this.gb(this.ao);
        }
        if (this.a7) {
            this.f2();
            this.f3();
            this.f1();
        }
        if (this.a7 && this.be) {
            this.gc();
            this.ao.e(this.dk, this.aq, this.ap);
            this.f9(this.ao);
            this.ga(this.ao);
            this.gb(this.ao);
        }
        else {
            if (this.a7) {
                this.f9(this.ap);
                this.ga(this.ap);
                this.gb(this.ap);
            }
        }
        this.a7 = false;
        this.view.ae();
    };
    XamRadialGauge.prototype.gc = function () {
        this.bq = 0;
        this.ay.w();
        this.ay.v();
    };
    Object.defineProperty(XamRadialGauge.prototype, "be", {
        get: function () {
            return this.dn > 0;
        },
        enumerable: true,
        configurable: true
    });
    XamRadialGauge.prototype.f9 = function (a) {
        var b = this.im;
        var c = this.view.bv();
        var d = a.a;
        var e = Math.min(b.width / 2, b.height / 2) * a.d;
        var f = this.ij();
        var g = f.x;
        var h = f.y;
        var i = d.n(e, g, h);
        c.ak = i;
        c._fill = d.l;
        c._stroke = d.m;
        c.ac = d.h;
    };
    XamRadialGauge.prototype.bc = function (a) {
        if (this.bj == null) {
            return false;
        }
        return PolygonUtil.a(this.bj, a);
    };
    XamRadialGauge.prototype.needleContainsPoint = function (a, b) {
        if (this.bj == null) {
            return false;
        }
        return b ? PolygonUtil.a(this.bk, a) : PolygonUtil.a(this.bj, a);
    };
    XamRadialGauge.prototype.ga = function (a) {
        var b = this.im;
        var c = a.b.ab;
        var d = a.b.aj;
        var e = a.b.ak;
        var f = a.b.ae;
        var g = a.b.ah;
        var h = a.b.ai;
        var i = a.b.aa;
        var j = this.view.bw();
        var k = this.view.bz();
        var l = this.view.bx();
        var m = a.b;
        var n = Math.min(b.width / 2, b.height / 2) * a.d;
        var o = this.ij();
        var p = o.x;
        var q = o.y;
        var r = m.am(n, p, q);
        var s = c * 180 / Math.PI;
        j.ak = r;
        var t = new TransformGroup();
        t.j.add(((function () {
            var $ret = new RotateTransform();
            $ret.k = p;
            $ret.l = q;
            $ret.j = s;
            return $ret;
        })()));
        j.j = t;
        j._fill = d;
        j._stroke = e;
        j.ac = f;
        k.ak = m.an(n, p, q);
        l.ak = m.al(n, p, q);
        k._fill = g;
        k._stroke = h;
        k.ac = i;
        l._fill = g;
        l._stroke = h;
        l.ac = i;
        var u = new List$1(Point_$type, 0);
        var v = Math.cos(c);
        var w = Math.sin(c);
        var x = m.af / 2;
        var y = { $type: Point_$type, x: m.ad * n, y: x * n };
        var z = { $type: Point_$type, x: m.ac * n, y: x * n };
        var aa = { $type: Point_$type, x: m.ac * n, y: -x * n };
        var ab = { $type: Point_$type, x: m.ad * n, y: -x * n };
        y = { $type: Point_$type, x: y.x * v - y.y * w + p, y: y.y * v + y.x * w + q };
        z = { $type: Point_$type, x: z.x * v - z.y * w + p, y: z.y * v + z.x * w + q };
        aa = { $type: Point_$type, x: aa.x * v - aa.y * w + p, y: aa.y * v + aa.x * w + q };
        ab = { $type: Point_$type, x: ab.x * v - ab.y * w + p, y: ab.y * v + ab.x * w + q };
        u.add(y);
        u.add(z);
        u.add(aa);
        u.add(ab);
        this.bj = u;
        x = (m.af / 2) * n;
        var ac = { $type: Point_$type, x: m.ad * n, y: x };
        var ad = { $type: Point_$type, x: m.ac * n, y: x };
        var ae = { $type: Point_$type, x: m.ac * n, y: -x };
        var af = { $type: Point_$type, x: m.ad * n, y: -x };
        ac = { $type: Point_$type, x: ac.x * v - ac.y * w + p, y: ac.y * v + ac.x * w + q };
        ad = { $type: Point_$type, x: ad.x * v - ad.y * w + p, y: ad.y * v + ad.x * w + q };
        ae = { $type: Point_$type, x: ae.x * v - ae.y * w + p, y: ae.y * v + ae.x * w + q };
        af = { $type: Point_$type, x: af.x * v - af.y * w + p, y: af.y * v + af.x * w + q };
        this.bk = new List$1(Point_$type, 0);
        this.bk.add(ac);
        this.bk.add(ad);
        this.bk.add(ae);
        this.bk.add(af);
    };
    XamRadialGauge.prototype.ij = function () {
        var a = this.im;
        var b = isNaN_(this.b3) ? 0.5 : this.b3;
        var c = isNaN_(this.b4) ? 0.5 : this.b4;
        var d = a.left + b * a.width;
        var e = a.top + c * a.height;
        return { $type: Point_$type, x: d, y: e };
    };
    XamRadialGauge.prototype.c2 = function (a) {
        if (isInfinity(a)) {
            return NaN;
        }
        return a;
    };
    XamRadialGauge.prototype.f2 = function () {
        var a = this.ap;
        a.d = this.c0;
        var b = this.im;
        var c = this.av;
        var d = this.c4(this.dm, 0);
        var e = this.av.h(d);
        var f = new RadialGaugeNeedlePreparer();
        var g = new RadialGaugeNeedleParameters();
        g.b = this.ar;
        g.o = this.c2(this.cx);
        g.t = this.ib;
        g.u = this.ic;
        g.m = this.c2(this.cv);
        g.k = this.c2(this.cn);
        g.d = this.c2(this.cl);
        g.e = this.c2(this.cm);
        g.p = this.c2(this.ct);
        g.q = this.c2(this.cu);
        g.i = this.c2(this.cs);
        g.f = this.c2(this.cp);
        g.r = this.id;
        g.s = this.ie;
        g.c = this.as;
        g.h = this.c2(this.cq);
        g.n = this.c2(this.cw);
        g.l = this.c2(this.co);
        if (isNaN_(g.o)) {
            g.o = XamRadialGauge.cy;
        }
        if (isNaN_(g.h)) {
            g.h = XamRadialGauge.cr;
        }
        f.b = g;
        f.e(a.b);
        a.b.ab = e;
    };
    XamRadialGauge.prototype.gb = function (a) {
        var e_3, _a;
        var b = this.im;
        var c = a.c;
        var d = c.c;
        var e = c.e;
        var f = c.g;
        var g = c.h;
        var h = c.f;
        var i = c.d;
        var j = c.l;
        var k = c.t;
        var l = c.q;
        var m = c.j;
        var n = c.i;
        var o = c.v;
        var p = c.u;
        var q = c.s;
        var r = c.p;
        var s = c.ab;
        var t = c.ac;
        var u = c.w;
        var v = c.aa;
        var w = c.n;
        var x = c.m;
        var y = c.o;
        var z = this.view.by();
        var aa = c.r;
        k = Math.max(0, k);
        l = Math.max(0, l);
        var ab = true;
        if (this.au == 1 || (this.au == 0 && this.am == 0)) {
            ab = false;
        }
        var ac = Math.min(b.width / 2, b.height / 2) * a.d;
        var ad = this.ij();
        var ae = ad.x;
        var af = ad.y;
        var ag = q;
        var ah = r;
        q -= aa;
        r += aa;
        var ai = false;
        if ((r - q) >= 2 * Math.PI) {
            ai = true;
            q = 0;
            r = Math.PI;
        }
        var aj = new PathGeometry();
        var ak = new PathFigure();
        var al = Math.cos(q);
        var am = Math.sin(q);
        var an = Math.cos(r);
        var ao = Math.sin(r);
        var ap = ae + (ac * k) * al;
        var aq = af + (ac * k) * am;
        var ar = ae + (ac * l) * al;
        var as = af + (ac * l) * am;
        var at = ae + (ac * k) * an;
        var au = af + (ac * k) * ao;
        var av = ae + (ac * l) * an;
        var aw = af + (ac * l) * ao;
        var ax = ai;
        if (aa != 0 && !ai && ab) {
            var ay = Math.cos(ag);
            var az = Math.sin(ag);
            var a0 = Math.cos(ah);
            var a1 = Math.sin(ah);
            var a2 = ae + (ac * k) * ay;
            var a3 = af + (ac * k) * az;
            var a4 = ae + (ac * l) * ay;
            var a5 = af + (ac * l) * az;
            var a6 = ae + (ac * k) * a0;
            var a7 = af + (ac * k) * a1;
            var a8 = ae + (ac * l) * a0;
            var a9 = af + (ac * l) * a1;
            var ba = aq;
            var bb = ar;
            if (a4 - a2 != 0) {
                bb = ae;
                var bc = (a5 - a3) / (a4 - a2);
                ba = bc * (ae - ar) + as;
            }
            var bd = { $type: Point_$type, x: bb, y: ba };
            var be = GeometryUtil.i(bd, { $type: Point_$type, x: ar, y: as }, { $type: Point_$type, x: ae, y: af }, ac * k);
            var bf = au;
            var bg = av;
            if (a8 - a6 != 0) {
                bg = ae;
                var bh = (a9 - a7) / (a8 - a6);
                bf = bh * (ae - av) + aw;
            }
            var bi = { $type: Point_$type, x: bg, y: bf };
            var bj = GeometryUtil.i(bi, { $type: Point_$type, x: av, y: aw }, { $type: Point_$type, x: ae, y: af }, ac * k);
            if (isNaN_(be.c.x) || isNaN_(be.c.y) || isNaN_(be.d.x) || isNaN_(be.d.y) || isNaN_(bj.c.x) || isNaN_(bj.c.y) || isNaN_(bj.d.x) || isNaN_(bj.d.y)) {
                ai = true;
                q = 0;
                r = Math.PI;
            }
            else {
                var bk = void 0;
                var bl = void 0;
                if ((Math.pow(be.c.x - ar, 2) + Math.pow(be.c.y - as, 2)) < (Math.pow(be.d.x - ar, 2) + Math.pow(be.d.y - as, 2))) {
                    bk = be.c;
                }
                else {
                    bk = be.d;
                }
                if ((Math.pow(bj.c.x - av, 2) + Math.pow(bj.c.y - aw, 2)) < (Math.pow(bj.d.x - av, 2) + Math.pow(bj.d.y - aw, 2))) {
                    bl = bj.c;
                }
                else {
                    bl = bj.d;
                }
                if ((Math.pow(bl.x - ar, 2) + Math.pow(bl.y - as, 2)) <= (Math.pow(bk.x - ar, 2) + Math.pow(bk.y - as, 2))) {
                    ai = true;
                    q = 0;
                    r = Math.PI;
                }
                else {
                    var bm = GeometryUtil.e({ $type: Point_$type, x: ae, y: af }, bk);
                    var bn = GeometryUtil.e({ $type: Point_$type, x: ae, y: af }, bl);
                    var bo = q;
                    var bp = r;
                    while (bo > Math.PI * 2) {
                        bo -= Math.PI * 2;
                    }
                    while (bp > Math.PI * 2) {
                        bp -= Math.PI * 2;
                    }
                    var bq = Math.min(Math.abs(bm - bo), Math.abs((Math.PI * 2 - bm) - bo));
                    var br = Math.min(Math.abs(bn - bp), Math.abs((Math.PI * 2 - bn) - bp));
                    if ((r - q) + bq + br >= 2 * Math.PI) {
                        ai = true;
                        q = 0;
                        r = Math.PI;
                    }
                    else {
                        ap = bk.x;
                        aq = bk.y;
                        at = bl.x;
                        au = bl.y;
                    }
                }
            }
        }
        if (ai && !ax) {
            al = Math.cos(q);
            am = Math.sin(q);
            an = Math.cos(r);
            ao = Math.sin(r);
            ap = ae + (ac * k) * al;
            aq = af + (ac * k) * am;
            ar = ae + (ac * l) * al;
            as = af + (ac * l) * am;
            at = ae + (ac * k) * an;
            au = af + (ac * k) * ao;
            av = ae + (ac * l) * an;
            aw = af + (ac * l) * ao;
        }
        if (ai) {
            ak._startPoint = { $type: Point_$type, x: ar, y: as };
            ak._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: av, y: aw };
                $ret.b = false;
                $ret.d = 1;
                $ret.f = new Size(1, ac * l, ac * l);
                return $ret;
            })()));
            ak._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: ar, y: as };
                $ret.b = false;
                $ret.d = 1;
                $ret.f = new Size(1, ac * l, ac * l);
                return $ret;
            })()));
            var bs = new PathFigure();
            bs._startPoint = { $type: Point_$type, x: ap, y: aq };
            bs._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: at, y: au };
                $ret.b = false;
                $ret.d = 0;
                $ret.f = new Size(1, ac * k, ac * k);
                return $ret;
            })()));
            bs._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: ap, y: aq };
                $ret.b = false;
                $ret.d = 0;
                $ret.f = new Size(1, ac * k, ac * k);
                return $ret;
            })()));
            aj.c.add(ak);
            aj.c.add(bs);
        }
        else {
            ak._startPoint = { $type: Point_$type, x: ap, y: aq };
            ak._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: ar, y: as };
                return $ret;
            })()));
            ak._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: av, y: aw };
                $ret.b = (r - q) > Math.PI;
                $ret.d = 1;
                $ret.f = new Size(1, ac * l, ac * l);
                return $ret;
            })()));
            ak._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: at, y: au };
                return $ret;
            })()));
            ak._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: ap, y: aq };
                $ret.b = (r - q) > Math.PI;
                $ret.d = 0;
                $ret.f = new Size(1, ac * k, ac * k);
                return $ret;
            })()));
            aj.c.add(ak);
        }
        z.ak = aj;
        z._fill = s;
        var bt = this.a2;
        bt.f = true;
        try {
            for (var _b = __values(fromEnum(this.bl)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var bu = _c.value;
                bt.n(bu);
            }
        }
        catch (e_3_1) {
            e_3 = { error: e_3_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_3)
                    throw e_3.error;
            }
        }
        this.bl.g();
        var bv = c.z;
        for (var bw = 0; bw < d.length; bw++) {
            var bx = ae + (ac * j) * Math.cos(d[bw]);
            var by = af + (ac * j) * Math.sin(d[bw]);
            var bz = bt.a();
            if (bz.ak != e[bw]) {
                bz.ak = e[bw];
            }
            this.view.a9(bz, bv);
            var b0 = h[bw];
            var b1 = i[bw];
            var b2 = f[bw];
            var b3 = g[bw];
            this.view.a2(bz, bx + b2, by + b3);
            this.bl.h(bz);
        }
        bt.f = false;
        var b4 = this.a5;
        b4.f = true;
        for (var b5 = 0; b5 < this.bi.count; b5++) {
            b4.n(this.bi._inner[b5]);
        }
        this.bi.clear();
        var _loop_1 = function (b6) {
            var b7 = ae + (ac * o) * Math.cos(m[b6]);
            var b8 = af + (ac * o) * Math.sin(m[b6]);
            var b9 = ae + (ac * p) * Math.cos(m[b6]);
            var ca = af + (ac * p) * Math.sin(m[b6]);
            var cb = b4.a();
            var cc = new PathGeometry();
            var cd = new PathFigure();
            cd._startPoint = { $type: Point_$type, x: b7, y: b8 };
            cd._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: b9, y: ca };
                return $ret;
            })()));
            cc.c.add(cd);
            cb.ak = cc;
            cb._stroke = t;
            cb.ac = u;
            this_1.bi.add(cb);
        };
        var this_1 = this;
        for (var b6 = 0; b6 < m.length; b6++) {
            _loop_1(b6);
        }
        b4.f = false;
        var ce = this.a3;
        ce.f = true;
        for (var cf = 0; cf < this.bg.count; cf++) {
            ce.n(this.bg._inner[cf]);
        }
        this.bg.clear();
        var _loop_2 = function (cg) {
            var ch = ae + (ac * w) * Math.cos(n[cg]);
            var ci = af + (ac * w) * Math.sin(n[cg]);
            var cj = ae + (ac * x) * Math.cos(n[cg]);
            var ck = af + (ac * x) * Math.sin(n[cg]);
            var cl = ce.a();
            var cm = new PathGeometry();
            var cn = new PathFigure();
            cn._startPoint = { $type: Point_$type, x: ch, y: ci };
            cn._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: cj, y: ck };
                return $ret;
            })()));
            cm.c.add(cn);
            cl.ak = cm;
            cl._stroke = v;
            cl.ac = y;
            this_2.bg.add(cl);
        };
        var this_2 = this;
        for (var cg = 0; cg < n.length; cg++) {
            _loop_2(cg);
        }
        ce.f = false;
        var co = this.a4;
        co.f = true;
        for (var cp = this.bh.count - 1; cp >= 0; cp--) {
            co.n(this.bh._inner[cp]);
        }
        this.bh.clear();
        for (var cq = 0; cq < c.k.count; cq++) {
            var cr = c.k._inner[cq];
            var cs = co.a();
            cs.ak = cr.m(ac, ae, af);
            cs._fill = cr.k;
            cs._stroke = cr.l;
            cs.ac = cr.h;
            this.bh.add(cs);
        }
        this.view.a8(this.bh);
        co.f = false;
    };
    XamRadialGauge.prototype.bf = function (a, b, c) {
        var d = c / 10000;
        if (isNaN_(d)) {
            d = 1E-05;
        }
        var e = Math.abs(a - b);
        if (e < d) {
            return true;
        }
        return false;
    };
    XamRadialGauge.prototype.c3 = function (a) {
        if (isInfinity(a)) {
            return NaN;
        }
        return a;
    };
    XamRadialGauge.prototype.c1 = function (a, b) {
        if (isInfinity(a)) {
            return b;
        }
        return a;
    };
    XamRadialGauge.prototype.c4 = function (a, b) {
        if (isInfinity(a) || isNaN_(a)) {
            return b;
        }
        return a;
    };
    XamRadialGauge.prototype.f3 = function () {
        var a = this.ap;
        a.d = this.c3(this.c0);
        if (isNaN_(a.d)) {
            a.d = 1;
        }
        var b = this.im;
        var c = this.av;
        var d = this.c3(this.b6);
        var e = this.c3(this.b9);
        var f = this.c3(this.ce);
        if (isNaN_(d)) {
            d = (this.br - this.bs) / 10;
        }
        if (isNaN_(e)) {
            e = d;
        }
        if (isNaN_(f)) {
            f = 3;
        }
        var g = new List$1(Tuple$2.$.specialize(Number_$type, Number_$type), 0);
        var h = c.i;
        var i = c.g;
        while (h >= Math.PI * 2) {
            h -= Math.PI * 2;
        }
        while (i >= Math.PI * 2) {
            i -= Math.PI * 2;
        }
        var j = Math.abs(i - h) < 0.0001;
        var k = this.an == 1 || this.an == 3;
        var l = this.an == 0 || this.an == 3;
        for (var m = this.bs; m <= this.br || this.bf(m, this.br, e); m += e) {
            if (j && this.bf(m, this.bs, e) && k) {
                continue;
            }
            if (j && this.bf(m, this.br, e) && l) {
                continue;
            }
            g.add(new Tuple$2(Number_$type, Number_$type, m, c.h(m)));
            if (e == 0) {
                break;
            }
        }
        var n = new List$1(Number_$type, 0);
        var o = new List$1(Number_$type, 0);
        for (var p = this.bs; p <= this.br || this.bf(p, this.br, d); p += d) {
            n.add(c.h(p));
            for (var q = 0; q < f; q++) {
                var r = (d / (f + 1)) * (q + 1);
                if (r + p > this.br) {
                    continue;
                }
                o.add(c.h(r + p));
            }
            if (d == 0) {
                break;
            }
        }
        if (a.c.c.length != g.count) {
            a.c.c = new Array(g.count);
            a.c.e = new Array(g.count);
            a.c.f = new Array(g.count);
            a.c.d = new Array(g.count);
            a.c.g = new Array(g.count);
            a.c.h = new Array(g.count);
        }
        if (a.c.j.length != n.count || a.c.i.length != o.count) {
            a.c.j = new Array(n.count);
            a.c.i = new Array(o.count);
        }
        var s = new FormatRadialGaugeLabelEventArgs();
        s.startAngle = this.av.i;
        s.endAngle = this.av.g;
        s.actualMinimumValue = this.bs;
        s.actualMaximumValue = this.br;
        var t = new AlignRadialGaugeLabelEventArgs();
        t.startAngle = s.startAngle;
        t.endAngle = s.endAngle;
        t.actualMinimumValue = s.actualMinimumValue;
        t.actualMaximumValue = s.actualMaximumValue;
        var _loop_3 = function (u) {
            s.angle = g._inner[u].d;
            t.angle = s.angle;
            a.c.c[u] = g._inner[u].d;
            var v = g._inner[u].c;
            s.value = v;
            var w = v;
            if (this_3.aj == null) {
                w = Math.round(v * 100) / 100;
            }
            s.label = (w).toString();
            if (this_3.aj != null) {
                s.label = this_3.aj.i(w);
            }
            if (this_3.formatLabel != null) {
                this_3.formatLabel(this_3, s);
            }
            t.value = s.value;
            t.label = s.label;
            var x = s.label;
            var y = this_3.view.b2(((function () {
                var $ret = new TextBlock();
                $ret.ak = x;
                return $ret;
            })()));
            t.width = y.width;
            t.height = y.height;
            t.offsetX = -1 * (y.width / 2);
            t.offsetY = -1 * (y.height / 2);
            if (this_3.alignLabel != null) {
                this_3.alignLabel(this_3, t);
            }
            a.c.f[u] = t.width;
            a.c.d[u] = t.height;
            a.c.g[u] = t.offsetX;
            a.c.h[u] = t.offsetY;
            a.c.e[u] = t.label;
        };
        var this_3 = this;
        for (var u = 0; u < g.count; u++) {
            _loop_3(u);
        }
        for (var z = 0; z < n.count; z++) {
            a.c.j[z] = n._inner[z];
        }
        for (var aa = 0; aa < o.count; aa++) {
            a.c.i[aa] = o._inner[aa];
        }
        a.c.t = this.c4(this.db, 0.5);
        a.c.q = this.c4(this.c6, 0.57);
        a.c.l = this.c4(this.b7, 0.65);
        a.c.v = this.c4(this.dg, 0.5);
        a.c.u = this.c4(this.de, 0.57);
        a.c.n = this.c4(this.ch, 0.54);
        a.c.m = this.c4(this.cf, 0.57);
        a.c.s = c.i;
        a.c.p = c.g;
        var ab = this.c8;
        if (isNaN_((ab))) {
            ab = 2.8;
        }
        var ac = ab * Math.PI / 180;
        if (ac < 0) {
            ac = 0;
        }
        a.c.r = ac;
        a.c.ac = this.ih;
        a.c.z = this.h8;
        a.c.aa = this.ia;
        a.c.ab = this.ig;
        a.c.w = this.c3(this.di);
        a.c.o = this.c3(this.cj);
        if (isNaN_(a.c.w)) {
            a.c.w = XamRadialGauge.dj;
        }
        if (isNaN_(a.c.o)) {
            a.c.o = XamRadialGauge.ck;
        }
        a.c.k.clear();
        for (var ad = 0; ad < this.ranges.count; ad++) {
            var ae = this.ranges._inner[ad];
            var af = this.c3(Math.min(ae.o, ae.j));
            var ag = this.c3(Math.max(ae.o, ae.j));
            if (isNaN_(af) || isNaN_(ag)) {
                continue;
            }
            var ah = c.h(af);
            var ai = c.h(ag);
            var aj = RadialGaugeScaler.k(ah, ai, this.ii);
            ah = aj.c;
            ai = aj.d;
            var ak = new RadialGaugeRangeFrame();
            ak.e = ah;
            ak.b = ai;
            ak.k = ae.ao != null ? ae.ao : this.h9(ad, this.ah);
            ak.l = ae.ap != null ? ae.ap : this.h9(ad, this.ai);
            ak.h = this.c4(ae.p, XamRadialGaugeRange.q);
            ak.f = this.c3(ae.l);
            if (isNaN_(ak.f)) {
                ak.f = Math.max(0, this.db);
            }
            ak.c = this.c3(ae.k);
            if (isNaN_(ak.c)) {
                ak.c = Math.max(0, this.db);
            }
            ak.g = this.c3(ae.n);
            if (isNaN_(ak.g)) {
                ak.g = Math.max(0, this.c6);
            }
            ak.d = this.c3(ae.m);
            if (isNaN_(ak.d)) {
                ak.d = Math.max(0, this.c6);
            }
            if (this.ii == 0) {
                var al = ak.f;
                ak.f = ak.c;
                ak.c = al;
                al = ak.g;
                ak.g = ak.d;
                ak.d = al;
            }
            a.c.k.add(ak);
        }
    };
    XamRadialGauge.prototype.f1 = function () {
        var a = this.ap;
        a.d = this.c0;
        var b = a.a;
        var c = this.h6;
        var d = this.h7;
        var e = this.c1(this.b1, XamRadialGauge.b2);
        var f = this.am;
        var g = this.by;
        var h = this.bw;
        if (isInfinity(h) || isNaN_(h)) {
            h = 0.12;
        }
        if (isInfinity(g) || isNaN_(g)) {
            g = 0.82;
        }
        var i = this.bu;
        if (isInfinity(i) || isNaN_(i)) {
            i = 4;
        }
        if (h > g) {
            var j = g;
            g = h;
            h = j;
        }
        var k = this.av;
        var l = k.i;
        var m = k.g;
        b.l = c;
        b.m = d;
        b.h = e;
        if (f == 0) {
            b.b = 0;
            b.g = 0;
            b.c = 0;
            b.d = 0;
            b.e = this.by;
        }
        else {
            b.b = i;
            var n = this.b0 * Math.PI / 180;
            if (n < 0) {
                n = 0;
            }
            if ((Math.PI * 2) - (m - l) < n) {
                b.f = 0;
                b.b = 0;
                b.g = 0;
                b.c = 0;
                b.d = 0;
                b.e = g;
            }
            else {
                b.f = n;
                b.g = l;
                b.c = m;
                b.b = i;
                b.d = h;
                b.e = g;
            }
        }
    };
    Object.defineProperty(XamRadialGauge.prototype, "a6", {
        get: function () {
            return this.ay.f();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamRadialGauge.prototype, "dk", {
        get: function () {
            return this.bq;
        },
        set: function (a) {
            var b = this.bq;
            this.bq = a;
            this.fy("TransitionProgress", b, this.bq);
        },
        enumerable: true,
        configurable: true
    });
    XamRadialGauge.prototype.fr = function (a, b) {
        var c = this.b5(a);
        if (this.a9) {
            var d = this.dl(this.av.g - Math.PI * 2);
            switch (this.ii) {
                case 1:
                    if (c < this.bs) {
                        c = c < d * 0.5 ? this.br : this.bs;
                    }
                    break;
                case 0:
                    if (c > this.br) {
                        c = c < (d + this.br) * 0.5 ? this.br : this.bs;
                    }
                    break;
            }
        }
        if (c != this.dm) {
            this.dm = c;
        }
    };
    XamRadialGauge.prototype.destroy = function () {
        this.provideContainer(null);
    };
    XamRadialGauge.prototype.provideContainer = function (a) {
        this.view.as(a);
    };
    XamRadialGauge.prototype.onMouseMove = function (a, b) {
        if (this.a8) {
            this.fr(a, b);
        }
    };
    XamRadialGauge.prototype.onMouseDown = function (a, b) {
        if (b === void 0) {
            b = false;
        }
        if (this.ba && this.needleContainsPoint(a, b) && !this.a8) {
            this.a8 = true;
        }
    };
    XamRadialGauge.prototype.onMouseUp = function (a) {
        if (this.a8) {
            this.a8 = false;
        }
    };
    XamRadialGauge.prototype.containerResized = function () {
        this.view.at();
    };
    XamRadialGauge.prototype.fs = function () {
        this.view.flush();
    };
    XamRadialGauge.prototype.aw = function () {
        var a = new GaugeVisualData();
        a.viewport = new RectData(this.im.left, this.im.top, this.im.width, this.im.height);
        a.scaleLabels = new ScaleLabelVisualDataList();
        a.scaleTickmarks = new ScaleTickmarkVisualDataList();
        a.ranges = new RangeVisualDataList();
        a.needle = new NeedleVisualData();
        this.view.aj(a);
        return a;
    };
    XamRadialGauge.prototype.d1 = function () {
        var a = this.aw();
        a.scaleByViewport();
        return a.serialize();
    };
    XamRadialGauge.prototype.a1 = function () {
        return FontUtil.toFontInfo(this.view.z, this.d2);
    };
    Object.defineProperty(XamRadialGauge.prototype, "cz", {
        get: function () {
            return this.bp;
        },
        set: function (a) {
            var b = this.bp;
            this.bp = a;
            this.fy("PixelScalingRatio", b, this.bp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XamRadialGauge.prototype, "bt", {
        get: function () {
            return this.bo;
        },
        set: function (a) {
            var b = this.bo;
            this.bo = a;
            this.fy("ActualPixelScalingRatio", b, this.bo);
        },
        enumerable: true,
        configurable: true
    });
    XamRadialGauge.$t = markType(XamRadialGauge, 'XamRadialGauge', Control.$, [INotifyPropertyChanged_$type]);
    XamRadialGauge.hl = DependencyProperty.i("NeedleStartWidth", Number_$type, XamRadialGauge.$, new PropertyMetadata(2, NaN, function (a, b) { return a.fy("NeedleStartWidth", b.oldValue, b.newValue); }));
    XamRadialGauge.cy = DeviceUtils.g(1);
    XamRadialGauge.cr = DeviceUtils.g(1);
    XamRadialGauge.dj = DeviceUtils.g(3);
    XamRadialGauge.ck = DeviceUtils.g(2);
    XamRadialGauge.b2 = DeviceUtils.g(12);
    XamRadialGauge.$$p = markDep(DependencyProperty, PropertyMetadata, XamRadialGauge, 'fy', ['BackingBrush:h6:ge', [Brush.$, null], 'BackingCornerRadius:bu:gf', [1, 4], 'BackingInnerExtent:bw:gg', [1, 0.12], 'BackingOuterExtent:by:gh', [1, 0.82], 'BackingOutline:h7:gi', [Brush.$, null], 'BackingOversweep:b0:gj', [1, 3], 'BackingShape:am:gk', [RadialGaugeBackingShape_$type, enumGetBox(RadialGaugeBackingShape_$type, 0)], 'BackingStrokeThickness:b1:gl', [1, XamRadialGauge.b2], 'CenterX:b3:gm', [1, 0.5], 'CenterY:b4:gn', [1, 0.5], 'DuplicateLabelOmissionStrategy:an:go', [RadialGaugeDuplicateLabelOmissionStrategy_$type, enumGetBox(RadialGaugeDuplicateLabelOmissionStrategy_$type, 0)], 'FontBrush:h8:gp', [Brush.$, null], 'Font:d2:gq', [2, null], 'Interval:b6:gr', [1, NaN], 'IsNeedleDraggingConstrained:a9:gs', [0, true], 'IsNeedleDraggingEnabled:ba:gt', [0, false], 'LabelExtent:b7:gu', [1, 0.65], 'LabelFormat:d9:gv', [2, null], 'LabelFormatSpecifiers:ag:gw', [Array_$type, null], 'LabelInterval:b9:gx', [1, NaN], 'MaximumValue:ca:gy', [1, 100], 'MinimumValue:cc:gz', [1, 0], 'MinorTickBrush:ia:g0', [Brush.$, null], 'MinorTickCount:ce:g1', [1, 3], 'MinorTickEndExtent:cf:g2', [1, 0.57], 'MinorTickStartExtent:ch:g3', [1, 0.54], 'MinorTickStrokeThickness:cj:g4', [1, XamRadialGauge.ck], 'NeedleBaseFeatureExtent:cl:g5', [1, NaN], 'NeedleBaseFeatureWidthRatio:cm:g6', [1, NaN], 'NeedleBrush:ib:g7', [Brush.$, null], 'NeedleEndExtent:cn:g8', [1, NaN], 'NeedleEndWidthRatio:co:g9', [1, NaN], 'NeedleOutline:ic:ha', [Brush.$, null], 'NeedlePivotBrush:id:hb', [Brush.$, null], 'NeedlePivotInnerWidthRatio:cp:hc', [1, NaN], 'NeedlePivotOutline:ie:hd', [Brush.$, null], 'NeedlePivotShape:as:he', [RadialGaugePivotShape_$type, enumGetBox(RadialGaugePivotShape_$type, 3)], 'NeedlePivotStrokeThickness:cq:hf', [1, XamRadialGauge.cr], 'NeedlePivotWidthRatio:cs:hg', [1, NaN], 'NeedlePointFeatureExtent:ct:hh', [1, NaN], 'NeedlePointFeatureWidthRatio:cu:hi', [1, NaN], 'NeedleShape:ar:hj', [RadialGaugeNeedleShape_$type, enumGetBox(RadialGaugeNeedleShape_$type, 4)], 'NeedleStartExtent:cv:hk', [1, NaN], 'NeedleStrokeThickness:cx:hm', [1, XamRadialGauge.cy], 'RadiusMultiplier:c0:hn', [1, 1], 'RangeBrushes:ah:ho', [BrushCollection.$, null], 'RangeOutlines:ai:hp', [BrushCollection.$, null], 'Ranges::hq', [RadialGaugeRangeCollection.$, null], 'ScaleBrush:ig:hr', [Brush.$, null], 'ScaleEndAngle:c5:hs', [1, 45], 'ScaleEndExtent:c6:ht', [1, 0.57], 'ScaleOversweep:c8:hu', [1, 2.8], 'ScaleOversweepShape:au:hv', [RadialGaugeScaleOversweepShape_$type, enumGetBox(RadialGaugeScaleOversweepShape_$type, 0)], 'ScaleStartAngle:da:hw', [1, 135], 'ScaleStartExtent:db:hx', [1, 0.5], 'ScaleSweepDirection:ii:hy', [SweepDirection_$type, enumGetBox(SweepDirection_$type, 1)], 'TickBrush:ih:hz', [Brush.$, null], 'TickEndExtent:de:h0', [1, 0.57], 'TickStartExtent:dg:h1', [1, 0.5], 'TickStrokeThickness:di:h2', [1, XamRadialGauge.dj], 'TransitionDuration:dn:h3', [1, 0], 'TransitionEasingFunction:a0:h4', [Delegate_$type, null], 'Value:dm:h5', [1, 0]]);
    return XamRadialGauge;
}(Control));
/**
 * @hidden
 */
var XamRadialGaugeView = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(XamRadialGaugeView, _super);
    function XamRadialGaugeView(a) {
        var _this = _super.call(this) || this;
        _this.h = null;
        _this.s = null;
        _this.r = null;
        _this.q = null;
        _this.br = new Path();
        _this.bt = new Path();
        _this.bq = new Path();
        _this.bs = new Path();
        _this.bu = new Path();
        _this.o = null;
        _this.a = ["needle", "needlePivot", "backing", "scale", "tick", "minorTick", "label"];
        _this.c = null;
        _this.d = null;
        _this.l = false;
        _this.m = false;
        _this.g = null;
        _this.aa = null;
        _this.k = null;
        _this.z = null;
        _this.i = null;
        _this.bf = new Brush();
        _this.bg = ((function () {
            var $ret = new Brush();
            $ret.fill = "black";
            return $ret;
        })());
        _this.t = NaN;
        _this.p = null;
        _this.ac = -1;
        _this.ab = -1;
        _this.bk = null;
        _this.bl = null;
        _this.bm = null;
        _this.bn = null;
        _this.bh = null;
        _this.bi = null;
        _this.bo = null;
        _this.bp = null;
        _this.bj = null;
        _this.e = null;
        _this.f = null;
        _this.u = 0;
        _this.h = a;
        _this.o = new Dictionary$2(String_$type, Dictionary$2.$.specialize(String_$type, String_$type), 0);
        _this.q = new List$1(TextBlock.$, 0);
        _this.r = new List$1(Path.$, 0);
        _this.s = new List$1(Path.$, 0);
        return _this;
    }
    XamRadialGaugeView.prototype.an = function (a) {
        a._visibility = 0;
    };
    XamRadialGaugeView.prototype.ao = function (a) {
        a._visibility = 1;
    };
    XamRadialGaugeView.prototype.ap = function (a) {
        this.q.remove(a);
    };
    XamRadialGaugeView.prototype.be = function () {
        var a = new TextBlock();
        this.q.add(a);
        return a;
    };
    XamRadialGaugeView.prototype.ay = function (a) {
        a._visibility = 0;
    };
    XamRadialGaugeView.prototype.az = function (a) {
        a._visibility = 1;
    };
    XamRadialGaugeView.prototype.a0 = function (a) {
        this.r.remove(a);
    };
    XamRadialGaugeView.prototype.b0 = function () {
        var a = new Path();
        this.r.add(a);
        return a;
    };
    XamRadialGaugeView.prototype.a3 = function (a) {
        a._visibility = 0;
    };
    XamRadialGaugeView.prototype.a4 = function (a) {
        a._visibility = 1;
    };
    XamRadialGaugeView.prototype.a5 = function (a) {
        this.s.remove(a);
    };
    XamRadialGaugeView.prototype.b1 = function () {
        var a = new Path();
        this.s.add(a);
        return a;
    };
    XamRadialGaugeView.prototype.n = function () {
        return true;
    };
    XamRadialGaugeView.prototype.bw = function () {
        return this.br;
    };
    XamRadialGaugeView.prototype.by = function () {
        return this.bt;
    };
    XamRadialGaugeView.prototype.w = function (a) {
        var b = typeCast(TextBlock.$, a);
        if (b != null && b.ak != null) {
            return this.k.e(b) + 0;
        }
        return 0;
    };
    XamRadialGaugeView.prototype.b2 = function (a) {
        if (isNaN_(this.t)) {
            this.t = this.v(null);
        }
        var b = this.w(a);
        var c = this.t;
        return new Size(1, b, c);
    };
    XamRadialGaugeView.prototype.al = function () {
        this.l = true;
        var a = ["#CED3D8", "#CED3D8", "#EBEDEF", "#FFC73C", "#617583", "rgba(100,107,114,.74)", "rgba(100,107,114,.74)"];
        var b = ["#B2B9C0", "#B2B9C0", "#B2B9C0", null, null, null, null];
        var c = ["background-color", "border-top-color"];
        var d = ((function () {
            var $ret = new List$1(Array_$type, 0);
            $ret.add(a);
            $ret.add(b);
            return $ret;
        })());
        this.o.clear();
        var e = this.a.length;
        for (var f = 0; f < e; f++) {
            var g = new Dictionary$2(String_$type, String_$type, 0);
            var h = this.a[f];
            var i = new Array(c.length);
            arrayCopy1(c, 0, i, 0, c.length);
            this.b("ui-radialgauge-" + h, i);
            for (var j = 0; j < i.length; j++) {
                g.item(c[j], (i[j] == null) ? d._inner[j][f] : i[j]);
            }
            this.o.item(h, g);
        }
        this.bc();
        var k;
        var l;
        var m = BrushUtil.e("radialgauge-range", this.z, k, l);
        k = m.p2;
        l = m.p3;
        this.c = k;
        this.d = l;
        if (this.e == null) {
            this.h.ah = this.c;
        }
        if (this.f == null) {
            this.h.ai = this.d;
        }
        this.l = false;
    };
    XamRadialGaugeView.prototype.aq = function () {
        this.am();
        if (this.g != null) {
            this.g.ap(this.z.rootWrapper, "");
        }
    };
    XamRadialGaugeView.prototype.au = function () {
        if (this.g != null) {
            this.g.bb(this.z.rootWrapper, "");
        }
    };
    XamRadialGaugeView.prototype.bc = function () {
        this.l = true;
        var a = this.a.length;
        for (var b = 0; b < a; b++) {
            var c = this.a[b];
            this.bb(c, this.o.item(c));
        }
        this.l = false;
    };
    XamRadialGaugeView.prototype.bb = function (a, b) {
        var e_4, _a;
        var c = null;
        var d = null;
        var e = b.count;
        try {
            for (var _b = __values(fromEnum(b.keys)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var f = _c.value;
                switch (f) {
                    case "background-color":
                        c = new Brush();
                        if (b.item(f) != null) {
                            c._fill = b.item(f);
                        }
                        break;
                    case "border-top-color":
                        d = new Brush();
                        if (b.item(f) != null) {
                            d._fill = b.item(f);
                        }
                        break;
                }
            }
        }
        catch (e_4_1) {
            e_4 = { error: e_4_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_4)
                    throw e_4.error;
            }
        }
        switch (a) {
            case "needle":
                if (this.bk == null) {
                    this.h.ib = c;
                }
                if (this.bl == null) {
                    this.h.ic = d;
                }
                break;
            case "needlePivot":
                if (this.bm == null) {
                    this.h.id = c;
                }
                if (this.bn == null) {
                    this.h.ie = d;
                }
                break;
            case "backing":
                if (this.bh == null) {
                    this.h.h6 = c;
                }
                if (this.bi == null) {
                    this.h.h7 = d;
                }
                break;
            case "scale":
                if (this.bo == null) {
                    this.h.ig = c;
                }
                break;
            case "tick":
                if (this.bp == null) {
                    this.h.ih = c;
                }
                break;
            case "minorTick":
                if (this.bj == null) {
                    this.h.ia = c;
                }
                break;
            case "label":
                this.bg = c;
                break;
        }
    };
    XamRadialGaugeView.prototype.b = function (a, b) {
        this.z.startCSSQuery();
        for (var c = 0; c < b.length; c++) {
            b[c] = this.z.getCssDefaultPropertyValue(a, b[c]);
        }
        this.z.endCSSQuery();
        return b;
    };
    XamRadialGaugeView.y = function (a, b) {
        var c = a == null ? 0 : a.length;
        if (c < 1) {
            return b;
        }
        var d = a.split('.');
        var e = (d[0].length > 0) ? parseInt(d[0]) : 0;
        if (d.length != 2) {
            return e;
        }
        c = d[1].length;
        var f = parseInt(d[1]);
        while (c-- > 0) {
            f /= 10;
        }
        return f + e;
    };
    XamRadialGaugeView.prototype.av = function () {
        this.l = true;
        this.h.ib = ((function () {
            var $ret = new Brush();
            $ret.fill = "#CED3D8";
            return $ret;
        })());
        this.h.ic = ((function () {
            var $ret = new Brush();
            $ret.fill = "#B2B9C0";
            return $ret;
        })());
        this.h.ih = ((function () {
            var $ret = new Brush();
            $ret.fill = "#617583";
            return $ret;
        })());
        this.h.ig = ((function () {
            var $ret = new Brush();
            $ret.fill = "#FFC73C";
            return $ret;
        })());
        this.h.h6 = ((function () {
            var $ret = new Brush();
            $ret.fill = "#EBEDEF";
            return $ret;
        })());
        this.h.h7 = ((function () {
            var $ret = new Brush();
            $ret.fill = "#B2B9C0";
            return $ret;
        })());
        this.h.id = ((function () {
            var $ret = new Brush();
            $ret.fill = "#CED3D8";
            return $ret;
        })());
        this.h.ie = ((function () {
            var $ret = new Brush();
            $ret.fill = "#B2B9C0";
            return $ret;
        })());
        this.h.ia = ((function () {
            var $ret = new Brush();
            $ret.fill = "rgba(100,107,114,.74)";
            return $ret;
        })());
        this.l = false;
        this.am();
    };
    XamRadialGaugeView.prototype.am = function () {
        var a = this.h.cz;
        var b = this.h.bt;
        if (!isNaN_(a) && a != 0) {
            return;
        }
        if (window.devicePixelRatio != undefined && window.devicePixelRatio != b) {
            this.h.bt = window.devicePixelRatio;
        }
    };
    XamRadialGaugeView.prototype.a7 = function () {
        if (!this.m) {
            this.m = true;
            if (this.z != null) {
                this.z.setTimeout(runOn(this, this.ad), 0);
            }
            else {
                window.setTimeout(runOn(this, this.ad), 0);
            }
        }
    };
    XamRadialGaugeView.prototype.ad = function () {
        if (this.m) {
            this.m = false;
            this.h.fo();
        }
    };
    XamRadialGaugeView.prototype.flush = function () {
        if (this.m) {
            this.ad();
        }
    };
    XamRadialGaugeView.prototype.a2 = function (a, b, c) {
        a.n = b;
        a.o = c;
    };
    XamRadialGaugeView.prototype.as = function (a) {
        var _this = this;
        if (a == null) {
            this.aa = null;
            this.z = null;
            this.k = null;
            this.af();
            return;
        }
        this.u = (isNaN_(this.h.cz) ? this.h.bt : this.h.cz);
        var b = a;
        this.z = b;
        this.h.ay.u(this.z);
        this.z.rootWrapper.addClass("ui-radialgauge-container");
        var c = this.u;
        var d = Math.round(b.rootWrapper.width());
        var e = Math.round(b.rootWrapper.height());
        var f = d * c;
        var g = e * c;
        this.z.rootWrapper.setStyleProperty("position", "relative");
        var h = this.z.createElement("canvas");
        h.setStyleProperty("position", "absolute");
        this.z.append(h);
        this.ac = truncate(Math.round(f));
        this.ab = truncate(Math.round(g));
        h.setAttribute("width", f.toString());
        h.setAttribute("height", g.toString());
        h.setStyleProperty("width", d.toString() + "px");
        h.setStyleProperty("height", e.toString() + "px");
        this.h.im = new Rect(0, 0, 0, d, e);
        this.aa = h;
        var i = this.z.get2DCanvasContext(this.aa);
        this.k = new RenderingContext(new CanvasViewRenderer(), i);
        this.al();
        this.bd();
        this.k.ac(this.i);
        this.af();
        if (TypeRegistrar.isRegistered("CanvasGestureDOMEventProxy")) {
            this.g = typeCast(EventProxy.$, TypeRegistrar.create("CanvasGestureDOMEventProxy", this.z.rootWrapper, this.z, false));
        }
        if (this.g != null) {
            var j = this.g;
            j.onContactStarted = delegateCombine(j.onContactStarted, runOn(this, this.ai));
            var k = this.g;
            k.onContactMoved = delegateCombine(k.onContactMoved, runOn(this, this.ah));
            var l = this.g;
            l.onContactCompleted = delegateCombine(l.onContactCompleted, runOn(this, this.ag));
            this.g.ak = function (m) { return _this.h.ba && (_this.h.a8 || _this.h.bc(m)); };
        }
        this.a6();
    };
    XamRadialGaugeView.prototype.ag = function (a, b) {
        if (this.h != null) {
            this.h.onMouseUp(a);
        }
    };
    XamRadialGaugeView.prototype.ah = function (a, b) {
        if (this.h != null) {
            this.h.onMouseMove(a, b);
        }
    };
    XamRadialGaugeView.prototype.ai = function (a, b) {
        if (this.h != null) {
            this.h.onMouseDown(a);
        }
    };
    XamRadialGaugeView.prototype.af = function () {
        if (this.g != null) {
            var a = this.g;
            a.onContactStarted = delegateRemove(a.onContactStarted, runOn(this, this.ai));
            var b = this.g;
            b.onContactMoved = delegateRemove(b.onContactMoved, runOn(this, this.ah));
            var c = this.g;
            c.onContactCompleted = delegateRemove(c.onContactCompleted, runOn(this, this.ag));
            this.g.ak = null;
            this.g.aq();
        }
    };
    XamRadialGaugeView.prototype.a9 = function (a, b) {
        if (b != null) {
            a.am = b;
        }
        else {
            a.am = this.bg;
        }
    };
    XamRadialGaugeView.prototype.ba = function () {
        this.al();
        this.bd();
        this.a7();
    };
    XamRadialGaugeView.prototype.bd = function () {
        this.i = FontUtil.getFont(this.z);
        if (this.h.d2 != null) {
            this.i = this.h.a1();
        }
        this.t = this.v(this.i);
        this.bf = new Brush();
        this.bf._fill = this.z.rootWrapper.getStyleProperty("color");
        if (this.k != null) {
            this.k.ac(this.i);
        }
    };
    XamRadialGaugeView.prototype.ae = function () {
        this.a6();
    };
    XamRadialGaugeView.prototype.a6 = function () {
        var a = this.h.im.width;
        var b = this.h.im.height;
        var c = Math.round(a * this.u);
        var d = Math.round(b * this.u);
        if (this.ac != c || this.ab != d) {
            this.aa.setAttribute("width", c.toString());
            this.aa.setAttribute("height", d.toString());
            this.aa.setStyleProperty("width", a.toString() + "px");
            this.aa.setStyleProperty("height", b.toString() + "px");
            this.ac = truncate(Math.round(c));
            this.ab = truncate(Math.round(d));
        }
        if (this.k.d && this.u != 1) {
            this.k.z();
            this.k.aa(this.u, this.u);
        }
        this.k.k(this.h.im.left, this.h.im.top, this.h.im.width, this.h.im.height);
        this.k.s(this.bq);
        this.k.s(this.bt);
        if (this.p != null) {
            for (var e = 0; e < this.p.count; e++) {
                this.k.s(this.p._inner[e]);
            }
        }
        for (var f = 0; f < this.q.count; f++) {
            this.k.ac(this.i);
            this.k.w(this.q._inner[f]);
        }
        for (var g = 0; g < this.r.count; g++) {
            this.k.s(this.r._inner[g]);
        }
        this.k.z();
        this.k.j(this.br.j);
        this.k.s(this.bu);
        this.k.s(this.br);
        this.k.s(this.bs);
        this.k.y();
        if (this.k.d && this.u != 1) {
            this.k.y();
        }
    };
    XamRadialGaugeView.prototype.v = function (a) {
        return FontUtil.getCurrentFontHeight(this.z, a);
    };
    XamRadialGaugeView.prototype.a8 = function (a) {
        this.p = a;
    };
    XamRadialGaugeView.prototype.bv = function () {
        return this.bq;
    };
    XamRadialGaugeView.prototype.bz = function () {
        return this.bu;
    };
    XamRadialGaugeView.prototype.bx = function () {
        return this.bs;
    };
    XamRadialGaugeView.prototype.at = function () {
        this.am();
        var a = Math.round(this.z.rootWrapper.width());
        var b = Math.round(this.z.rootWrapper.height());
        this.h.im = new Rect(0, 0, 0, a, b);
        if (this.g != null) {
            this.g.bf = this.h.im;
        }
    };
    XamRadialGaugeView.prototype.j = function (a, b) {
        return FontUtil.getFontInfo(this.z, a, b);
    };
    XamRadialGaugeView.prototype.aj = function (a) {
        var e_5, _a, e_6, _b, e_7, _c;
        a.scalePath = new PathVisualData(1, "Scale", this.bt);
        a.needlePath = new PathVisualData(1, "Needle", this.br);
        var b = this.br.j.j._inner[0].j;
        a.needle.angle = b;
        a.backingPath = new PathVisualData(1, "Backing", this.bq);
        a.overlayPath = new PathVisualData(1, "Overlay", this.bs);
        a.underlayPath = new PathVisualData(1, "Underlay", this.bu);
        var c = this.i;
        try {
            for (var _d = __values(fromEnum(this.q)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var d = _e.value;
                if (d._visibility == 0) {
                    var e = this.j(d, c);
                    var f = new ScaleLabelVisualData();
                    f.labelValue = d.ak;
                    f.labelPosition = PointData.b({ $type: Point_$type, x: d.n, y: d.o });
                    f.labelSize = SizeData.b(this.b2(d));
                    f.appearance = AppearanceHelper.c(d, e);
                    a.scaleLabels.add(f);
                }
            }
        }
        catch (e_5_1) {
            e_5 = { error: e_5_1 };
        }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return))
                    _a.call(_d);
            }
            finally {
                if (e_5)
                    throw e_5.error;
            }
        }
        try {
            for (var _f = __values(fromEnum(this.r)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var g = _g.value;
                if (g._visibility == 0) {
                    var h = new ScaleTickmarkVisualData();
                    h.tickPath = new PathVisualData(1, "tickmarks", g);
                    a.scaleTickmarks.add(h);
                }
            }
        }
        catch (e_6_1) {
            e_6 = { error: e_6_1 };
        }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return))
                    _b.call(_f);
            }
            finally {
                if (e_6)
                    throw e_6.error;
            }
        }
        try {
            for (var _h = __values(fromEnum(this.s)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var i = _j.value;
                if (i._visibility == 0) {
                    var j = new RangeVisualData();
                    var k = new PathVisualData(1, "range", i);
                    j.rangePath = k;
                    a.ranges.add(j);
                }
            }
        }
        catch (e_7_1) {
            e_7 = { error: e_7_1 };
        }
        finally {
            try {
                if (_j && !_j.done && (_c = _h.return))
                    _c.call(_h);
            }
            finally {
                if (e_7)
                    throw e_7.error;
            }
        }
    };
    XamRadialGaugeView.prototype.ar = function (a, b, c) {
        var d = b;
        var e = c;
        if (!this.l) {
            switch (a) {
                case XamRadialGauge.$$p[29]:
                    this.bk = e;
                    break;
                case XamRadialGauge.$$p[32]:
                    this.bl = e;
                    break;
                case XamRadialGauge.$$p[33]:
                    this.bm = e;
                    break;
                case XamRadialGauge.$$p[35]:
                    this.bn = e;
                    break;
                case XamRadialGauge.$$p[0]:
                    this.bh = e;
                    break;
                case XamRadialGauge.$$p[4]:
                    this.bi = e;
                    break;
                case XamRadialGauge.$$p[48]:
                    this.bo = e;
                    break;
                case XamRadialGauge.$$p[56]:
                    this.bp = e;
                    break;
                case XamRadialGauge.$$p[22]:
                    this.bj = e;
                    break;
            }
            if (e == null) {
                this.bc();
            }
        }
    };
    XamRadialGaugeView.prototype.aw = function (a, b) {
        if (!this.l) {
            this.e = b;
            if (this.e == null) {
                this.h.ah = this.c;
            }
        }
    };
    XamRadialGaugeView.prototype.ax = function (a, b) {
        if (!this.l) {
            this.f = b;
            if (this.f == null) {
                this.h.ai = this.d;
            }
        }
    };
    XamRadialGaugeView.prototype.a1 = function () {
        this.u = this.h.bt;
    };
    XamRadialGaugeView.$t = markType(XamRadialGaugeView, 'XamRadialGaugeView');
    return XamRadialGaugeView;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents event argument for FormatRadialGaugeLabel.
*/
var IgrFormatRadialGaugeLabelEventArgs = /** @class */ /*@__PURE__*/ (function () {
    function IgrFormatRadialGaugeLabelEventArgs() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    IgrFormatRadialGaugeLabelEventArgs.prototype.createImplementation = function () {
        return new FormatRadialGaugeLabelEventArgs();
    };
    Object.defineProperty(IgrFormatRadialGaugeLabelEventArgs.prototype, "i", {
        get: function () {
            return this._implementation;
        },
        enumerable: true,
        configurable: true
    });
    IgrFormatRadialGaugeLabelEventArgs.prototype.onImplementationCreated = function () {
    };
    IgrFormatRadialGaugeLabelEventArgs.prototype._provideImplementation = function (i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    };
    Object.defineProperty(IgrFormatRadialGaugeLabelEventArgs.prototype, "actualMinimumValue", {
        get: function () {
            return this.i.actualMinimumValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatRadialGaugeLabelEventArgs.prototype, "actualMaximumValue", {
        get: function () {
            return this.i.actualMaximumValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatRadialGaugeLabelEventArgs.prototype, "startAngle", {
        get: function () {
            return this.i.startAngle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatRadialGaugeLabelEventArgs.prototype, "endAngle", {
        get: function () {
            return this.i.endAngle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatRadialGaugeLabelEventArgs.prototype, "angle", {
        get: function () {
            return this.i.angle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatRadialGaugeLabelEventArgs.prototype, "value", {
        get: function () {
            return this.i.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrFormatRadialGaugeLabelEventArgs.prototype, "label", {
        get: function () {
            return this.i.label;
        },
        set: function (value) {
            this.i.label = value;
        },
        enumerable: true,
        configurable: true
    });
    return IgrFormatRadialGaugeLabelEventArgs;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents event argument for AlignRadialGaugeLabel.
*/
var IgrAlignRadialGaugeLabelEventArgs = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrAlignRadialGaugeLabelEventArgs, _super);
    function IgrAlignRadialGaugeLabelEventArgs() {
        return _super.call(this) || this;
    }
    IgrAlignRadialGaugeLabelEventArgs.prototype.createImplementation = function () {
        return new AlignRadialGaugeLabelEventArgs();
    };
    Object.defineProperty(IgrAlignRadialGaugeLabelEventArgs.prototype, "i", {
        get: function () {
            return this._implementation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrAlignRadialGaugeLabelEventArgs.prototype, "width", {
        get: function () {
            return this.i.width;
        },
        set: function (value) {
            this.i.width = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrAlignRadialGaugeLabelEventArgs.prototype, "height", {
        get: function () {
            return this.i.height;
        },
        set: function (value) {
            this.i.height = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrAlignRadialGaugeLabelEventArgs.prototype, "offsetX", {
        get: function () {
            return this.i.offsetX;
        },
        set: function (value) {
            this.i.offsetX = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrAlignRadialGaugeLabelEventArgs.prototype, "offsetY", {
        get: function () {
            return this.i.offsetY;
        },
        set: function (value) {
            this.i.offsetY = value;
        },
        enumerable: true,
        configurable: true
    });
    return IgrAlignRadialGaugeLabelEventArgs;
}(IgrFormatRadialGaugeLabelEventArgs));

var defaultFont$2 = "Verdana, Arial, \"Segoe UI\", \"Myriad Pro\", sans-serif";
var RadialGaugeStylingDefaults = {
    //"ui-radialgauge-needle": {
    //    "background-color": "#333"
    //},
    //"ui-radialgauge-needleCap": {
    //    "background-color": "#494949",
    //    "border-color": "#494949"
    //},
    "ui-radialgauge-backing": {
        "background-color": "#FFFFFF",
        "border-top-color": "#CCCCCC"
    },
    //"ui-radialgauge-scale": {
    //    "background-color": "#44ACD6",
    //    "border": "none"
    //},
    "ui-radialgauge-tick": {
        "background-color": "rgba(0, 0, 0, 0.35)",
        "border-top-color": "none"
    },
    "ui-radialgauge-minorTick": {
        "background-color": "rgba(0, 0, 0, 0.2)",
        "border-top-color": "none"
    },
    "ui-radialgauge-label": {
        "background-color": "#666666",
        "borde-top-color": "none"
    },
    "ui-radialgauge-range-palette-1": {
        "background-color": "#005E9C",
        "border-top-color": "none"
    },
    "ui-radialgauge-range-palette-2": {
        "background-color": "#0078C8",
        "border-top-color": "none"
    },
    "ui-radialgauge-range-palette-3": {
        "background-color": "#0092F4",
        "border-top-color": "none"
    },
    "ui-radialgauge-range-palette-4": {
        "background-color": "#21A7FF",
        "border-top-color": "none"
    },
    "ui-radialgauge-range-palette-5": {
        "background-color": "#4FB9FF",
        "border-top-color": "none"
    },
    "ui-radialgauge": {
        "font-family": defaultFont$2,
        "font-size": "11px"
    },
    "font-family": defaultFont$2,
    "font-style": "normal",
    "font-weight": "normal",
    "font-size": "11px",
    "color": "#666666",
    "font-variant": "",
    "line-height": ""
};

var IgrRadialGaugeRange = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrRadialGaugeRange, _super);
    function IgrRadialGaugeRange(props) {
        var _this = _super.call(this, props) || this;
        _this._renderer = null;
        _this.__p = null;
        _this._hasUserValues = new Set();
        _this._stylingContainer = null;
        _this._stylingParent = null;
        _this._inStyling = false;
        if (_this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(_this));
        }
        _this._implementation = _this.createImplementation();
        _this._implementation.externalObject = _this;
        _this.onImplementationCreated();
        return _this;
    }
    Object.defineProperty(IgrRadialGaugeRange.prototype, "i", {
        get: function () {
            return this._implementation;
        },
        enumerable: true,
        configurable: true
    });
    IgrRadialGaugeRange.prototype.onImplementationCreated = function () {
    };
    IgrRadialGaugeRange.prototype.componentDidMount = function () {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(this.props)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    {
                        this[p] = this.props[p];
                    }
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
    };
    IgrRadialGaugeRange.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var e_2, _a;
        var mod = getModifiedProps(this.props, nextProps);
        try {
            for (var _b = __values(Object.keys(mod)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    this[p] = mod[p];
                }
            }
        }
        catch (e_2_1) {
            e_2 = { error: e_2_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_2)
                    throw e_2.error;
            }
        }
        return true;
    };
    IgrRadialGaugeRange.prototype.render = function () {
        return null;
    };
    Object.defineProperty(IgrRadialGaugeRange.prototype, "rangeInternal", {
        get: function () {
            return this.i;
        },
        enumerable: true,
        configurable: true
    });
    IgrRadialGaugeRange.prototype.createImplementation = function () {
        return new XamRadialGaugeRange();
    };
    IgrRadialGaugeRange.prototype._provideRenderer = function (renderer) {
        this._renderer = renderer;
    };
    IgrRadialGaugeRange._createFromInternal = function (internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        var name = internal.$type.name;
        var externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    };
    Object.defineProperty(IgrRadialGaugeRange.prototype, "name", {
        /**
     * Gets or sets the name of the range.
    */
        get: function () {
            return this.i.v;
        },
        set: function (v) {
            this.i.v = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "brush", {
        /**
         * Gets or sets the brush to use to fill the range.
        */
        get: function () {
            return brushToString(this.i.ao);
        },
        set: function (v) {
            this.i.ao = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "outline", {
        /**
         * Gets or sets the outline to use when rendering the range.
        */
        get: function () {
            return brushToString(this.i.ap);
        },
        set: function (v) {
            this.i.ap = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "startValue", {
        /**
         * Gets or sets the value at which the range starts along the scale.
        */
        get: function () {
            return this.i.o;
        },
        set: function (v) {
            this.i.o = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "endValue", {
        /**
         * Gets or sets the value at which the range ends along the scale.
        */
        get: function () {
            return this.i.j;
        },
        set: function (v) {
            this.i.j = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "innerStartExtent", {
        /**
         * Gets or sets the distance from the center of the gauge (from 0 to 1) at which to start rendering the inner sweep of the range.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.l;
        },
        set: function (v) {
            this.i.l = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "innerEndExtent", {
        /**
         * Gets or sets the distance from the center of the gauge (from 0 to 1) at which to end rendering the inner sweep of the range.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.k;
        },
        set: function (v) {
            this.i.k = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "outerStartExtent", {
        /**
         * Gets or sets the distance from the center of the gauge (from 0 to 1) at which to start rendering the outer sweep of the range.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.n;
        },
        set: function (v) {
            this.i.n = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "outerEndExtent", {
        /**
         * Gets or sets the distance from the center of the gauge (from 0 to 1) at which to end rendering the outer sweep of the range.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.m;
        },
        set: function (v) {
            this.i.m = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGaugeRange.prototype, "strokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering this range's outline.
        */
        get: function () {
            return this.i.p;
        },
        set: function (v) {
            this.i.p = +v;
        },
        enumerable: true,
        configurable: true
    });
    IgrRadialGaugeRange.prototype.findByName = function (name) {
        return null;
    };
    Object.defineProperty(IgrRadialGaugeRange.prototype, "hasUserValues", {
        get: function () {
            return this._hasUserValues;
        },
        enumerable: true,
        configurable: true
    });
    IgrRadialGaugeRange.prototype.__m = function (propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    };
    IgrRadialGaugeRange.prototype._styling = function (container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        var genericPrefix = "";
        var typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("RadialGaugeRange");
        var additionalPrefixes = [];
        var prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        var b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            var basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            var parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            var parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    };
    return IgrRadialGaugeRange;
}(Component));

var IgrRadialGaugeRangeCollection = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrRadialGaugeRangeCollection, _super);
    function IgrRadialGaugeRangeCollection(list) {
        var _this = _super.call(this) || this;
        if (!IgrRadialGaugeRange.$type) {
            IgrRadialGaugeRange.$type = markType(IgrRadialGaugeRange, "IgrRadialGaugeRange");
        }
        if (list) {
            for (var i = 0; i < list.length; i++) {
                _this.add(list[i]);
            }
        }
        return _this;
    }
    IgrRadialGaugeRangeCollection.prototype._createInnerColl = function () {
        if (!IgrRadialGaugeRange.$type) {
            IgrRadialGaugeRange.$type = markType(IgrRadialGaugeRange, "IgrRadialGaugeRange");
        }
        var coll = new SyncableObservableCollection$2(IgrRadialGaugeRange.$type, XamRadialGaugeRange.$type, 0);
        coll.compare = function (ext, int) {
            var comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = function (ext) {
            return ext._implementation;
        };
        coll.createFrom = function (int) {
            var ext = int.externalObject;
            if (!ext) {
                ext = IgrRadialGaugeRange._createFromInternal(int);
                if (ext) {
                    ext._implementation = int;
                }
            }
            return ext;
        };
        return coll;
    };
    return IgrRadialGaugeRangeCollection;
}(IgCollection));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrRadialGauge = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrRadialGauge, _super);
    function IgrRadialGauge(props) {
        var _this = _super.call(this, props) || this;
        _this.contentRanges = [];
        /**
        * The ranges actually present in the chart. Do not directly modify this array.
        * This array's contents can be modified by causing Angular to reproject the child content.
        * Or adding and removing ranges from the manual ranges collection on the ranges property.
        */
        _this.actualRanges = [];
        _this._ranges = null;
        _this._rangesAdapter = null;
        _this.__p = null;
        _this._hasUserValues = new Set();
        _this._stylingContainer = null;
        _this._stylingParent = null;
        _this._inStyling = false;
        _this._formatLabel = null;
        _this._formatLabel_wrapped = null;
        _this._alignLabel = null;
        _this._alignLabel_wrapped = null;
        _this._valueChanged = null;
        _this._valueChanged_wrapped = null;
        _this._actualMinimumValueChange = null;
        _this._actualMinimumValueChange_wrapped = null;
        _this._actualMaximumValueChange = null;
        _this._actualMaximumValueChange_wrapped = null;
        if (_this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(_this));
        }
        _this._getMainRef = _this._getMainRef.bind(_this);
        _this._contentChildrenManager = new ContentChildrenManager(function (ch) { return ch.key || ch.props.name; }, function (ch) { return ch.key || ch.props.name; }, function () { return _this._updateContentChildren(); });
        var container = null;
        if (document) {
            container = document.createElement("div");
            container.style.display = "block";
            container.style.width = "100%";
            container.style.height = "100%";
        }
        var root;
        root = container;
        _this._renderer = new ReactRenderer(root, document, true, RadialGaugeStylingDefaults);
        _this._implementation = _this.createImplementation();
        _this._container = _this._renderer.getWrapper(container);
        //this._renderer.rootWrapper.append(this._container);
        //this._container.setStyleProperty("display", "block");
        //this._container.setStyleProperty("width", "100%");
        //this._container.setStyleProperty("height", "100%");
        _this._wrapper = _this._renderer;
        //var root: any;
        //root = this._container;
        //if (this._container.nativeElement != null) {
        //    root = this._container.nativeElement;
        //}
        var gauge = _this.i;
        _this._gauge = gauge;
        _this._rangesAdapter = new CollectionAdapter(_this.contentRanges, _this.i.ranges, _this.actualRanges, function (c) { return c.i; }, function (i) {
            i._provideRenderer(_this._wrapper);
            if (_this._container && _this._container.getNativeElement().parentElement) {
                i._styling(_this._container.getNativeElement(), _this, _this);
            }
        }, function (i) { i._provideRenderer(null); });
        gauge.provideContainer(_this._renderer);
        _this._renderer.addSizeWatcher(function () {
            _this._gauge.containerResized();
        });
        return _this;
    }
    Object.defineProperty(IgrRadialGauge.prototype, "height", {
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            if (this._elRef) {
                this._elRef.style.height = value;
                this.containerResized();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (value) {
            this._width = value;
            if (this._elRef) {
                this._elRef.style.width = value;
                this.containerResized();
            }
        },
        enumerable: true,
        configurable: true
    });
    IgrRadialGauge.prototype._updateContentChildren = function () {
        this.contentRanges.length = 0;
        var contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (var i = 0; i < contentChildrenActual.length; i++) {
            if ((XamRadialGaugeRange.$type).isAssignableFrom(contentChildrenActual[i].i.$type)) {
                this.contentRanges.push(contentChildrenActual[i]);
            }
        }
        if (this._rangesAdapter !== null) {
            this._rangesAdapter.notifyContentChanged();
        }
    };
    Object.defineProperty(IgrRadialGauge.prototype, "ranges", {
        /**
         * A collection or manually added axes for the chart.
        */
        get: function () {
            var _this = this;
            if (this._ranges === null) {
                var coll = new IgrRadialGaugeRangeCollection();
                var inner = coll._innerColl;
                inner.addListener(function (sender, e) {
                    switch (e.action) {
                        case NotifyCollectionChangedAction.Add:
                            _this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Remove:
                            _this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                            break;
                        case NotifyCollectionChangedAction.Replace:
                            _this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                            _this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                            break;
                        case NotifyCollectionChangedAction.Reset:
                            _this._rangesAdapter.clearManualItems();
                            break;
                    }
                });
                this._ranges = coll;
            }
            return this._ranges;
        },
        enumerable: true,
        configurable: true
    });
    IgrRadialGauge.prototype.render = function () {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        var children = this._contentChildrenManager.getChildren(this.props.children);
        var div = createElement("div", {
            className: "ig-radial-gauge igr-radial-gauge",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    };
    IgrRadialGauge.prototype.componentDidMount = function () {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(this.props)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    {
                        this[p] = this.props[p];
                    }
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container.getNativeElement());
        this.containerResized();
        this.initializeContent();
    };
    IgrRadialGauge.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var e_2, _a;
        var mod = getModifiedProps(this.props, nextProps);
        try {
            for (var _b = __values(Object.keys(mod)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    this[p] = mod[p];
                }
            }
        }
        catch (e_2_1) {
            e_2 = { error: e_2_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_2)
                    throw e_2.error;
            }
        }
        return true;
    };
    IgrRadialGauge.prototype._getMainRef = function (div) {
        this._elRef = div;
    };
    IgrRadialGauge.prototype.destroy = function () {
        this._gauge.destroy();
        this._wrapper.destroy();
    };
    IgrRadialGauge.prototype.createImplementation = function () {
        return new XamRadialGauge();
    };
    IgrRadialGauge.prototype.initializeContent = function () {
        this._styling(this._container.getNativeElement(), this);
        if (this.actualRanges && this.actualRanges.length > 0) {
            var currRange = this.actualRanges;
            for (var i = 0; i < currRange.length; i++) {
                currRange[i]._styling(this._container.getNativeElement(), this, this);
            }
        }
        this._updateContentChildren();
        this.i.containerResized();
    };
    IgrRadialGauge.prototype.componentWillUnmount = function () {
        //this._grid.destroy();
        this.destroy();
    };
    IgrRadialGauge.prototype.initializeProperties = function () {
        var e_3, _a;
        try {
            for (var _b = __values(Object.keys(this.props)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    this[p] = this.props[p];
                }
            }
        }
        catch (e_3_1) {
            e_3 = { error: e_3_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_3)
                    throw e_3.error;
            }
        }
    };
    Object.defineProperty(IgrRadialGauge.prototype, "i", {
        /**
         * @hidden
         */
        get: function () {
            return this._implementation;
        } /**
                                     * @hidden
                                     */,
        enumerable: true,
        configurable: true
    });
    IgrRadialGauge._createFromInternal = function (internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        var name = internal.$type.name;
        var externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    };
    Object.defineProperty(IgrRadialGauge.prototype, "rangeBrushes", {
        /**
     * Gets or sets a collection of brushes to be used as the palette for gauge ranges.
    */
        get: function () {
            return fromBrushCollection(this.i.ah);
        },
        set: function (v) {
            this.i.ah = toBrushCollection(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "rangeOutlines", {
        /**
         * Gets or sets a collection of brushes to be used as the palette for gauge outlines.
        */
        get: function () {
            return fromBrushCollection(this.i.ai);
        },
        set: function (v) {
            this.i.ai = toBrushCollection(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "minimumValue", {
        /**
         * Gets or sets the minimum value of the scale.
        */
        get: function () {
            return this.i.cc;
        },
        set: function (v) {
            this.i.cc = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "actualMinimumValue", {
        /**
         * Gets the resolved minimum value of the scale.
        */
        get: function () {
            return this.i.bs;
        },
        set: function (v) {
            this.i.bs = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "maximumValue", {
        /**
         * Gets or sets the maximum value of the scale.
        */
        get: function () {
            return this.i.ca;
        },
        set: function (v) {
            this.i.ca = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "actualMaximumValue", {
        /**
         * Gets the resolved maximum value of the scale.
        */
        get: function () {
            return this.i.br;
        },
        set: function (v) {
            this.i.br = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "interval", {
        /**
         * Gets or sets the interval to use for the scale.
        */
        get: function () {
            return this.i.b6;
        },
        set: function (v) {
            this.i.b6 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "centerX", {
        /**
         * Gets or sets the x position of the center of the gauge with the value ranging from 0 to 1.
        */
        get: function () {
            return this.i.b3;
        },
        set: function (v) {
            this.i.b3 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "centerY", {
        /**
         * Gets or sets the y position of the center of the gauge with the value ranging from 0 to 1.
        */
        get: function () {
            return this.i.b4;
        },
        set: function (v) {
            this.i.b4 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "value", {
        /**
         * Gets or sets the value at which to point the needle of the gauge.
        */
        get: function () {
            return this.i.dm;
        },
        set: function (v) {
            this.i.dm = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "scaleStartAngle", {
        /**
         * Gets or sets the start angle for the scale in degrees.
        */
        get: function () {
            return this.i.da;
        },
        set: function (v) {
            this.i.da = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "scaleEndAngle", {
        /**
         * Gets or sets the end angle for the scale in degrees.
        */
        get: function () {
            return this.i.c5;
        },
        set: function (v) {
            this.i.c5 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "scaleSweepDirection", {
        /**
         * Gets or sets the direction in which the scale sweeps around the center from the start angle to end angle.
        */
        get: function () {
            return this.i.ii;
        },
        set: function (v) {
            this.i.ii = ensureEnum(SweepDirection_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "transitionDuration", {
        /**
         * Gets or sets the number of milliseconds over which changes to the gauge should be animated.
        */
        get: function () {
            return this.i.dn;
        },
        set: function (v) {
            this.i.dn = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "transitionEasingFunction", {
        /**
         * Gets or sets the easing function used to morph the current series.
        */
        get: function () {
            return this.i.a0;
        },
        set: function (v) {
            this.i.a0 = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleBrush", {
        /**
         * Gets or sets the brush to use when rendering the fill of the needle.
        */
        get: function () {
            return brushToString(this.i.ib);
        },
        set: function (v) {
            this.i.ib = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleOutline", {
        /**
         * Gets or sets the brush to use when rendering the outline of the needle.
        */
        get: function () {
            return brushToString(this.i.ic);
        },
        set: function (v) {
            this.i.ic = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleStartExtent", {
        /**
         * Gets or sets the extent (from -1 to 1) at which to start rendering the needle, measured from the center of the gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.cv;
        },
        set: function (v) {
            this.i.cv = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleEndExtent", {
        /**
         * Gets or sets the extent (from -1 to 1) at which to end rendering the needle, measured from the center of the gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.cn;
        },
        set: function (v) {
            this.i.cn = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleShape", {
        /**
         * Gets or sets the shape to use when rendering the needle from a number of options.
        */
        get: function () {
            return this.i.ar;
        },
        set: function (v) {
            this.i.ar = ensureEnum(RadialGaugeNeedleShape_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleStartWidthRatio", {
        /**
         * Gets or sets the width of the needle at its point using a value from (0 to 1). Note: Only some needle shapes respect this property.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.cw;
        },
        set: function (v) {
            this.i.cw = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleEndWidthRatio", {
        /**
         * Gets or sets the width of the needle at its point using a value from (0 to 1). Note: Only some needle shapes respect this property.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.co;
        },
        set: function (v) {
            this.i.co = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleBaseFeatureWidthRatio", {
        /**
         * Gets or sets the width of the needle at its feature which is closest to the base (e.g. a bulb) with a value from 0 to 1. Note: Only some needle shapes respect this property, namely: NeedleWithBulb, RectangleWithBulb, TrapezoidWithBulb, and TriangleWithBulb.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.cm;
        },
        set: function (v) {
            this.i.cm = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleBaseFeatureExtent", {
        /**
         * Gets or sets the extent of the feature which is closest to the base (e.g. a bulb) with a value from -1 to 1. Note: Only some needle shapes respect this property, namely: NeedleWithBulb, RectangleWithBulb, TrapezoidWithBulb, and TriangleWithBulb.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.cl;
        },
        set: function (v) {
            this.i.cl = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needlePointFeatureWidthRatio", {
        /**
         * Gets or sets the width of the needle at its feature which is closest to the point (e.g. the tapering point of a needle) with a value from 0 to 1. Note: Only some needle shapes respect this property.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.cu;
        },
        set: function (v) {
            this.i.cu = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needlePointFeatureExtent", {
        /**
         * Gets or sets the extent of the feature which is closest to the point (e.g. the tapering point of a needle) with a value from -1 to 1. Note: Only some needle shapes respect this property.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.ct;
        },
        set: function (v) {
            this.i.ct = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needlePivotWidthRatio", {
        /**
         * Gets or sets the width of the cap of the needle with a value from 0 to 1. Note: Will only take effect if you have a cap set on the needle.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.cs;
        },
        set: function (v) {
            this.i.cs = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needlePivotInnerWidthRatio", {
        /**
         * Gets or sets the width of the inner cutout section of the needle cap with a value from 0 to 1. Note: Will only take effect if you have a cap set on the needle that has a cutout section.
        */
        get: function () {
            return this.i.cp;
        },
        set: function (v) {
            this.i.cp = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needlePivotShape", {
        /**
         * Gets or sets the shape to use for the needle cap.
        */
        get: function () {
            return this.i.as;
        },
        set: function (v) {
            this.i.as = ensureEnum(RadialGaugePivotShape_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "scaleStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the scale, measured from the center of the gauge as a value from 0 to 1.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.db;
        },
        set: function (v) {
            this.i.db = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needlePivotBrush", {
        /**
         * Gets or sets the brush to use for filling the needle cap. Note: this only applies to certain cap shapes.
        */
        get: function () {
            return brushToString(this.i.id);
        },
        set: function (v) {
            this.i.id = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needlePivotOutline", {
        /**
         * Gets or sets the brush to use for the outlines of the needle cap.
        */
        get: function () {
            return brushToString(this.i.ie);
        },
        set: function (v) {
            this.i.ie = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needleStrokeThickness", {
        /**
         * Gets or sets the stroke thickness of the needle outline.
        */
        get: function () {
            return this.i.cx;
        },
        set: function (v) {
            this.i.cx = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "needlePivotStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use for the outline of the needle cap.
        */
        get: function () {
            return this.i.cq;
        },
        set: function (v) {
            this.i.cq = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "scaleEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the scale as a value from 0 to 1 measured from the center of the gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.c6;
        },
        set: function (v) {
            this.i.c6 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "labelExtent", {
        /**
         * Gets or sets the position at which to put the labels as a value from 0 to 1, measured form the center of the gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.b7;
        },
        set: function (v) {
            this.i.b7 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "labelInterval", {
        /**
         * Gets or sets the interval to use for rendering labels. This defaults to be the same interval as the tickmarks on the scale.
        */
        get: function () {
            return this.i.b9;
        },
        set: function (v) {
            this.i.b9 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "tickStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the major tickmarks as a value from 0 to 1, measured from the center of the gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.dg;
        },
        set: function (v) {
            this.i.dg = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "tickEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the major tickmarks as a value from 0 to 1, measured from the center of the gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.de;
        },
        set: function (v) {
            this.i.de = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "tickStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering ticks.
        */
        get: function () {
            return this.i.di;
        },
        set: function (v) {
            this.i.di = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "tickBrush", {
        /**
         * Gets or sets the brush to use for the major tickmarks.
        */
        get: function () {
            return brushToString(this.i.ih);
        },
        set: function (v) {
            this.i.ih = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "fontBrush", {
        /**
         * Gets or sets the brush to use for the label font.
        */
        get: function () {
            return brushToString(this.i.h8);
        },
        set: function (v) {
            this.i.h8 = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "minorTickStartExtent", {
        /**
         * Gets or sets the position at which to start rendering the minor tickmarks as a value from 0 to 1, measured from the center of the gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.ch;
        },
        set: function (v) {
            this.i.ch = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "minorTickEndExtent", {
        /**
         * Gets or sets the position at which to stop rendering the minor tickmarks as a value from 0 to 1, measured from the center of the gauge.
         * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
        */
        get: function () {
            return this.i.cf;
        },
        set: function (v) {
            this.i.cf = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "minorTickStrokeThickness", {
        /**
         * Gets or sets the stroke thickness to use when rendering minor ticks.
        */
        get: function () {
            return this.i.cj;
        },
        set: function (v) {
            this.i.cj = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "minorTickBrush", {
        /**
         * Gets or sets the brush to use for the minor tickmarks.
        */
        get: function () {
            return brushToString(this.i.ia);
        },
        set: function (v) {
            this.i.ia = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "minorTickCount", {
        /**
         * Gets or sets the number of minor tickmarks to place between major tickmarks.
        */
        get: function () {
            return this.i.ce;
        },
        set: function (v) {
            this.i.ce = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "scaleBrush", {
        /**
         * Gets or sets the brush to use to fill the background of the scale.
        */
        get: function () {
            return brushToString(this.i.ig);
        },
        set: function (v) {
            this.i.ig = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "backingBrush", {
        /**
         * Gets or sets the brush to use to fill the backing of the gauge.
        */
        get: function () {
            return brushToString(this.i.h6);
        },
        set: function (v) {
            this.i.h6 = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "backingOutline", {
        /**
         * Gets or sets the brush to use for the outline of the backing.
        */
        get: function () {
            return brushToString(this.i.h7);
        },
        set: function (v) {
            this.i.h7 = stringToBrush(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "backingStrokeThickness", {
        /**
         * Gets or sets the stroke thickness of the backing outline.
        */
        get: function () {
            return this.i.b1;
        },
        set: function (v) {
            this.i.b1 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "backingOuterExtent", {
        /**
         * Gets or sets the outer extent of the gauge backing.
        */
        get: function () {
            return this.i.by;
        },
        set: function (v) {
            this.i.by = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "backingOversweep", {
        /**
         * Gets or sets the over sweep angle to apply to the backing if it is displaying fitted (in degrees). Must be greater or equal to 0.
        */
        get: function () {
            return this.i.b0;
        },
        set: function (v) {
            this.i.b0 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "scaleOversweep", {
        /**
         * Gets or sets the extra degrees of sweep to apply to the scale background. Must be greater or equal to 0.
        */
        get: function () {
            return this.i.c8;
        },
        set: function (v) {
            this.i.c8 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "scaleOversweepShape", {
        /**
         * Gets or sets the oversweep shape to use for the excess fill area for the scale.
        */
        get: function () {
            return this.i.au;
        },
        set: function (v) {
            this.i.au = ensureEnum(RadialGaugeScaleOversweepShape_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "backingCornerRadius", {
        /**
         * Gets or sets the corner rounding radius to use for the fitted scale backings.
        */
        get: function () {
            return this.i.bu;
        },
        set: function (v) {
            this.i.bu = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "backingInnerExtent", {
        /**
         * Gets or sets the inner extent of the gauge backing.
        */
        get: function () {
            return this.i.bw;
        },
        set: function (v) {
            this.i.bw = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "backingShape", {
        /**
         * Gets or sets the type of shape to use for the backing of the gauge.
        */
        get: function () {
            return this.i.am;
        },
        set: function (v) {
            this.i.am = ensureEnum(RadialGaugeBackingShape_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "radiusMultiplier", {
        /**
         * Gets or sets the multiplying factor to apply to the normal radius of the gauge.
         * The radius of the gauge is defined by the minimum of the width and height of the control divided by 2.0.
         * This introduces a multiplicative factor to that value.
        */
        get: function () {
            return this.i.c0;
        },
        set: function (v) {
            this.i.c0 = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "duplicateLabelOmissionStrategy", {
        /**
         * Gets or sets the strategy to use for omitting labels if the first and last label have the same value.
        */
        get: function () {
            return this.i.an;
        },
        set: function (v) {
            this.i.an = ensureEnum(RadialGaugeDuplicateLabelOmissionStrategy_$type, v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "isNeedleDraggingEnabled", {
        /**
         * Gets or sets whether needle dragging is enabled or not.
        */
        get: function () {
            return this.i.ba;
        },
        set: function (v) {
            this.i.ba = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "isNeedleDraggingConstrained", {
        /**
         * Gets or sets whether the needle is constrained within the minimum and maximum value range during dragging.
        */
        get: function () {
            return this.i.a9;
        },
        set: function (v) {
            this.i.a9 = ensureBool(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "font", {
        /**
         * Gets or sets the font.
        */
        get: function () {
            return this.i.d2;
        },
        set: function (v) {
            this.i.d2 = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "labelFormat", {
        /**
         * Gets or sets the label composite format used when creating label values.
        */
        get: function () {
            return this.i.d9;
        },
        set: function (v) {
            this.i.d9 = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "labelFormatSpecifiers", {
        /**
         * Gets or sets the format specifiers to use with the LabelFormat string.
        */
        get: function () {
            return this.i.ag;
        },
        set: function (v) {
            this.i.ag = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "animating", {
        /**
         * Gets a value indicating whether the radial gauge is currently animating.
        */
        get: function () {
            return this.i.a6;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "transitionProgress", {
        /**
         * Gets the transition progress of the animation when the control is animating.
        */
        get: function () {
            return this.i.dk;
        },
        set: function (v) {
            this.i.dk = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "pixelScalingRatio", {
        /**
         * Gets or sets the scaling value used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get: function () {
            return this.i.cz;
        },
        set: function (v) {
            this.i.cz = +v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "actualPixelScalingRatio", {
        /**
         * Gets the actual pixel scaling ratio used to affect the pixel density of the control.
         * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
         * to appear blurry.
        */
        get: function () {
            return this.i.bt;
        },
        set: function (v) {
            this.i.bt = +v;
        },
        enumerable: true,
        configurable: true
    });
    IgrRadialGauge.prototype.findByName = function (name) {
        if (this.ranges != null && this.ranges.findByName && this.ranges.findByName(name)) {
            return this.ranges.findByName(name);
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        return null;
    };
    Object.defineProperty(IgrRadialGauge.prototype, "hasUserValues", {
        get: function () {
            return this._hasUserValues;
        },
        enumerable: true,
        configurable: true
    });
    IgrRadialGauge.prototype.__m = function (propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    };
    IgrRadialGauge.prototype._styling = function (container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        var genericPrefix = "";
        var typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("RadialGauge");
        var additionalPrefixes = [];
        var prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        var b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            var basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            var parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            var parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    };
    /**
 * Scales a value on the gauge's main scale to an angle around the center point of the gauge, in radians.

* @param value  * The value to scale.
*/
    IgrRadialGauge.prototype.scaleValue = function (value) {
        var iv = this.i.dd(value);
        return (iv);
    };
    /**
     * Unscales a value from an angle in radians to the represented value along the main scale of the gauge.
    
    * @param angle  * The angle in radians to unscale to a value.
    */
    IgrRadialGauge.prototype.unscaleValue = function (angle) {
        var iv = this.i.dl(angle);
        return (iv);
    };
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
    
    * @param point  * The point for which to retrieve the associated value.
    */
    IgrRadialGauge.prototype.getValueForPoint = function (point) {
        var iv = this.i.b5(toPoint(point));
        return (iv);
    };
    IgrRadialGauge.prototype.getPointForValue = function (value, extent) {
        var iv = this.i.ik(value, extent);
        return fromPoint(iv);
    };
    IgrRadialGauge.prototype.styleUpdated = function () {
        this.i.gd();
    };
    IgrRadialGauge.prototype.needleContainsPoint = function (point, isFinger) {
        var iv = this.i.needleContainsPoint(toPoint(point), isFinger);
        return (iv);
    };
    /**
     * Called by the UI framework to provide a UI container for rendering this control.
    
    * @param container  * The UI container element.
    */
    IgrRadialGauge.prototype.provideContainer = function (container) {
        this.i.provideContainer(container);
    };
    IgrRadialGauge.prototype.containerResized = function () {
        this.i.containerResized();
    };
    /**
     * Use to force the radial gauge to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the radial gauge needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the radial gauge.
    
    */
    IgrRadialGauge.prototype.flush = function () {
        this.i.fs();
    };
    /**
     * Returns visuals as a serialized string.
    
    */
    IgrRadialGauge.prototype.exportSerializedVisualData = function () {
        var iv = this.i.d1();
        return (iv);
    };
    Object.defineProperty(IgrRadialGauge.prototype, "formatLabel", {
        /**
         * Event which is raised when a label of the gauge is formatted.
         * Function takes first argument null and second argument ui.
         * Use ui.owner to obtain reference to gauge widget.
         * Use ui.actualMinimumValue to obtain the minimum value of gauge scale.
         * Use ui.actualMaximumValue to obtain the maximum value of gauge scale.
         * Use ui.startAngle to obtain the starting angle of gauge scale.
         * Use ui.endAngle to obtain the ending angle of gauge scale.
         * Use ui.angle to obtain the angle on the gauge scale at which the label will be located.
         * Use ui.value to obtain the value on the gauge scale associated with the label.
         * Use ui.label to obtain the string value of the label.
        */
        get: function () {
            return this._formatLabel;
        },
        set: function (ev) {
            var _this = this;
            if (this._formatLabel_wrapped !== null) {
                this.i.formatLabel = delegateRemove(this.i.formatLabel, this._formatLabel_wrapped);
                this._formatLabel_wrapped = null;
                this._formatLabel = null;
            }
            this._formatLabel = ev;
            this._formatLabel_wrapped = function (o, e) {
                var outerArgs = new IgrFormatRadialGaugeLabelEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeFormatLabel) {
                    _this.beforeFormatLabel(_this, outerArgs);
                }
                if (_this._formatLabel) {
                    _this._formatLabel(_this, outerArgs);
                }
            };
            this.i.formatLabel = delegateCombine(this.i.formatLabel, this._formatLabel_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "alignLabel", {
        /**
         * Event which is raised when a label of the gauge is aligned along the scale.
         * Function takes first argument null and second argument ui.
         * Use ui.owner to obtain reference to gauge widget.
         * Use ui.actualMinimumValue to obtain the minimum value of gauge scale.
         * Use ui.actualMaximumValue to obtain the maximum value of gauge scale.
         * Use ui.startAngle to obtain the starting angle of gauge scale.
         * Use ui.endAngle to obtain the ending angle of gauge scale.
         * Use ui.angle to obtain the angle on the gauge scale at which the label will be located.
         * Use ui.value to obtain the value on the gauge scale associated with the label.
         * Use ui.label to obtain the string value of the label.
         * Use ui.width to obtain the width of the label.
         * Use ui.height to obtain the height of the label.
         * Use ui.offsetX to obtain the X offset of the label on the gauge scale.
         * Use ui.offsetY to obtain the Y offset of the label on the gauge scale.
        */
        get: function () {
            return this._alignLabel;
        },
        set: function (ev) {
            var _this = this;
            if (this._alignLabel_wrapped !== null) {
                this.i.alignLabel = delegateRemove(this.i.alignLabel, this._alignLabel_wrapped);
                this._alignLabel_wrapped = null;
                this._alignLabel = null;
            }
            this._alignLabel = ev;
            this._alignLabel_wrapped = function (o, e) {
                var outerArgs = new IgrAlignRadialGaugeLabelEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeAlignLabel) {
                    _this.beforeAlignLabel(_this, outerArgs);
                }
                if (_this._alignLabel) {
                    _this._alignLabel(_this, outerArgs);
                }
            };
            this.i.alignLabel = delegateCombine(this.i.alignLabel, this._alignLabel_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "valueChanged", {
        /**
         * Occurs when the Value property changes.
        */
        get: function () {
            return this._valueChanged;
        },
        set: function (ev) {
            var _this = this;
            if (this._valueChanged_wrapped !== null) {
                this.i.valueChanged = delegateRemove(this.i.valueChanged, this._valueChanged_wrapped);
                this._valueChanged_wrapped = null;
                this._valueChanged = null;
            }
            this._valueChanged = ev;
            this._valueChanged_wrapped = function (o, e) {
                var outerArgs = new IgrDoubleValueChangedEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeValueChanged) {
                    _this.beforeValueChanged(_this, outerArgs);
                }
                if (_this._valueChanged) {
                    _this._valueChanged(_this, outerArgs);
                }
            };
            this.i.valueChanged = delegateCombine(this.i.valueChanged, this._valueChanged_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "actualMinimumValueChange", {
        get: function () {
            return this._actualMinimumValueChange;
        },
        set: function (ev) {
            var _this = this;
            if (this._actualMinimumValueChange_wrapped !== null) {
                this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
                this._actualMinimumValueChange_wrapped = null;
                this._actualMinimumValueChange = null;
            }
            this._actualMinimumValueChange = ev;
            this._actualMinimumValueChange_wrapped = function (o, e) {
                var ext = _this.actualMinimumValue;
                if (_this.beforeActualMinimumValueChange) {
                    _this.beforeActualMinimumValueChange(_this, ext);
                }
                if (_this._actualMinimumValueChange) {
                    _this._actualMinimumValueChange(_this, ext);
                }
            };
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgrRadialGauge.prototype, "actualMaximumValueChange", {
        get: function () {
            return this._actualMaximumValueChange;
        },
        set: function (ev) {
            var _this = this;
            if (this._actualMaximumValueChange_wrapped !== null) {
                this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
                this._actualMaximumValueChange_wrapped = null;
                this._actualMaximumValueChange = null;
            }
            this._actualMaximumValueChange = ev;
            this._actualMaximumValueChange_wrapped = function (o, e) {
                var ext = _this.actualMaximumValue;
                if (_this.beforeActualMaximumValueChange) {
                    _this.beforeActualMaximumValueChange(_this, ext);
                }
                if (_this._actualMaximumValueChange) {
                    _this._actualMaximumValueChange(_this, ext);
                }
            };
            this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
        },
        enumerable: true,
        configurable: true
    });
    return IgrRadialGauge;
}(Component));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrRadialGaugeRangeModule = /** @class */ /*@__PURE__*/ (function () {
    function IgrRadialGaugeRangeModule() {
    }
    IgrRadialGaugeRangeModule.register = function () {
        TypeRegistrar.registerCons('IgrRadialGaugeRange', IgrRadialGaugeRange);
    };
    return IgrRadialGaugeRangeModule;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrRadialGaugeCoreModule = /** @class */ /*@__PURE__*/ (function () {
    function IgrRadialGaugeCoreModule() {
    }
    IgrRadialGaugeCoreModule.register = function () {
        TypeRegistrar.registerCons('IgrRadialGauge', IgrRadialGauge);
        IgrRadialGaugeRangeModule.register();
        IgrNumberFormatSpecifierModule.register();
    };
    return IgrRadialGaugeCoreModule;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IgrRadialGaugeModule = /** @class */ /*@__PURE__*/ (function () {
    function IgrRadialGaugeModule() {
    }
    IgrRadialGaugeModule.register = function () {
        IgrRadialGaugeCoreModule.register();
        IgrDVInteractivityModule.register();
    };
    return IgrRadialGaugeModule;
}());

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var CommonData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(CommonData, _super);
    function CommonData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._borderBrush = null;
        _this._borderThickness = null;
        return _this;
    }
    Object.defineProperty(CommonData.prototype, "borderBrush", {
        get: function () {
            return this._borderBrush;
        },
        set: function (a) {
            this._borderBrush = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommonData.prototype, "borderThickness", {
        get: function () {
            return this._borderThickness;
        },
        set: function (a) {
            this._borderThickness = a;
        },
        enumerable: true,
        configurable: true
    });
    CommonData.$t = markType(CommonData, 'CommonData');
    return CommonData;
}(Base));

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
var ScaleVisualData = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ScaleVisualData, _super);
    function ScaleVisualData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ScaleVisualData.$t = markType(ScaleVisualData, 'ScaleVisualData');
    return ScaleVisualData;
}(Base));

export { AlignLinearGraphLabelEventArgs, AlignRadialGaugeLabelEventArgs, BackingFrame, BulletGraphFrame, BulletGraphScaleFrame, BulletGraphStylingDefaults, BulletGraphTargetValueVisualData, BulletGraphVisualData, CommonData, FormatLinearGraphLabelEventArgs, FormatRadialGaugeLabelEventArgs, GaugeVisualData, IgrAlignLinearGraphLabelEventArgs, IgrAlignRadialGaugeLabelEventArgs, IgrBulletGraph, IgrBulletGraphCoreModule, IgrBulletGraphModule, IgrFormatLinearGraphLabelEventArgs, IgrFormatRadialGaugeLabelEventArgs, IgrLinearGauge, IgrLinearGaugeCoreModule, IgrLinearGaugeModule, IgrLinearGraphRange, IgrLinearGraphRangeCollection, IgrLinearGraphRangeModule, IgrRadialGauge, IgrRadialGaugeCoreModule, IgrRadialGaugeModule, IgrRadialGaugeRange, IgrRadialGaugeRangeCollection, IgrRadialGaugeRangeModule, LinearGaugeFrame, LinearGaugeScaleFrame, LinearGaugeStylingDefaults, LinearGaugeVisualData, LinearGraphBackingFrame, LinearGraphFrame, LinearGraphNeedleFrame, LinearGraphNeedleParameters, LinearGraphNeedlePreparer, LinearGraphNeedleShape, LinearGraphNeedleShape_$type, LinearGraphRangeCollection, LinearGraphRangeVisualData, LinearGraphRangeVisualDataList, LinearGraphRectFrame, LinearGraphScaleFrame, LinearGraphScaleLabelVisualData, LinearGraphScaleLabelVisualDataList, LinearGraphScaleTickmarkVisualData, LinearGraphScaleTickmarkVisualDataList, LinearGraphScaler, LinearGraphToolTipVisualData, LinearGraphTooltipDataContext, LinearGraphVisualData, LinearNeedleVisualData, LinearNeedleVisualDataList, LinearScaleOrientation, LinearScaleOrientation_$type, LinearScaleVisualData, MorphSegment, NeedleVisualData, RadialGaugeBackingShape, RadialGaugeBackingShape_$type, RadialGaugeDuplicateLabelOmissionStrategy, RadialGaugeDuplicateLabelOmissionStrategy_$type, RadialGaugeFrame, RadialGaugeNeedleFrame, RadialGaugeNeedleParameters, RadialGaugeNeedlePreparer, RadialGaugeNeedleShape, RadialGaugeNeedleShape_$type, RadialGaugePivotShape, RadialGaugePivotShape_$type, RadialGaugeRangeCollection, RadialGaugeRangeFrame, RadialGaugeScaleFrame, RadialGaugeScaleOversweepShape, RadialGaugeScaleOversweepShape_$type, RadialGaugeScaler, RadialGaugeStylingDefaults, RangeVisualData, RangeVisualDataList, ScaleLabelVisualData, ScaleLabelVisualDataList, ScaleTickmarkVisualData, ScaleTickmarkVisualDataList, ScaleVisualData, TitlesPosition, TitlesPosition_$type, ToolTipInfo, ToolTipItemVisualData, ValueVisualData, XamBulletGraph, XamBulletGraphView, XamLinearGauge, XamLinearGaugeView, XamLinearGraphRange, XamRadialGauge, XamRadialGaugeRange, XamRadialGaugeView };
//# sourceMappingURL=igniteui-react-gauges.js.map

import { Component, createElement } from 'react';
import { createPortal } from 'react-dom';
import { Base, PathGeometry, PathFigure, LineSegment, Point_$type, BrushUtil, markType, List$1, GeometryUtil, ArcSegment, Size, PolyLineSegment, InterpolationUtil, markEnum, DependencyObject, PropertyChangedEventArgs, INotifyPropertyChanged_$type, markDep, DependencyProperty, PropertyMetadata, Brush, ObservableCollection$1, EventArgs, fromEnum, StringBuilder, PointData, SizeData, String_$type, typeCast, Control, TextBlock, Path, delegateCombine, runOn, Rect, DoubleAnimator, StackPool$1, RectData, AppearanceHelper, PathVisualData, GetPointsSettings, PolygonUtil, isNaN_, Number_$type, Tuple$2, DeviceUtils, delegateRemove, BindingFormatter, fromEn, FontUtil, Array_$type, enumGetBox, BrushCollection, Dictionary$2, CanvasGestureDOMEventProxy, intDivide, arrayCopy1, RenderingContext, CanvasViewRenderer, TypeRegistrar, EventProxy, truncate, stringIsNullOrEmpty, NamePatcher, isValidProp, getModifiedProps, brushToString, stringToBrush, toSpinal, initializePropertiesFromCss, IgCollection, SyncableObservableCollection$2, ContentChildrenManager, ReactRenderer, CollectionAdapter, NotifyCollectionChangedAction, ReactWrapper, IgrDataContext, ensureEnum, fromBrushCollection, toBrushCollection, ensureBool, arrayFindByName, toPoint, IgrNumberFormatSpecifierModule, IgrDVInteractivityModule, DoubleValueChangedEventArgs, IgrDoubleValueChangedEventArgs, isInfinity, MathUtil, PathSegment, Stack$1, TransformGroup, RotateTransform, SweepDirection_$type, Delegate_$type, fromPoint } from 'igniteui-react-core';

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphBackingFrame = /*@__PURE__*/ (() => {
    class LinearGraphBackingFrame extends Base {
        constructor() {
            super();
            this.e = null;
            this.f = null;
            this.c = 0;
            this.b = 0;
            this.a = 0;
        }
        g(a, b, c) {
            let d = new PathGeometry();
            let e = new PathFigure();
            let f, g, h, i;
            if (c == 1) {
                f = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: a * this.a, y: 0 };
                    return $ret;
                })());
                g = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: a * this.b, y: 0 };
                    return $ret;
                })());
                h = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: a * this.b, y: b };
                    return $ret;
                })());
                i = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: a * this.a, y: b };
                    return $ret;
                })());
            }
            else {
                f = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: 0, y: a * (1 - this.b) };
                    return $ret;
                })());
                g = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: b, y: a * (1 - this.b) };
                    return $ret;
                })());
                h = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: b, y: a * (1 - this.a) };
                    return $ret;
                })());
                i = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: 0, y: a * (1 - this.a) };
                    return $ret;
                })());
            }
            e._startPoint = f.c;
            e._segments.add(g);
            e._segments.add(h);
            e._segments.add(i);
            e._isClosed = true;
            d.c.add(e);
            return d;
        }
        d(a, b, c) {
            this.c = b.c + (c.c - b.c) * a;
            this.e = BrushUtil.k(b.e, a, c.e, 0);
            this.f = BrushUtil.k(b.f, a, c.f, 0);
            this.b = b.b + (c.b - b.b) * a;
            this.a = b.a + (c.a - b.a) * a;
        }
    }
    LinearGraphBackingFrame.$t = /*@__PURE__*/ markType(LinearGraphBackingFrame, 'LinearGraphBackingFrame');
    return LinearGraphBackingFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphRectFrame = /*@__PURE__*/ (() => {
    class LinearGraphRectFrame extends Base {
        constructor() {
            super(...arguments);
            this.e = 0;
            this.f = 0;
            this.b = 0;
            this.c = 0;
            this.g = 0;
            this.d = 0;
            this.i = null;
            this.j = null;
            this.h = 0;
        }
        k(a, b, c, d) {
            let e = new PathGeometry();
            let f = new PathFigure();
            let g, h, i, j;
            if (d == 1) {
                g = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: a.x + b * this.b, y: c - this.d };
                    return $ret;
                })());
                h = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: a.x + b * this.c, y: c - this.d };
                    return $ret;
                })());
                i = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: a.x + b * this.f, y: c - this.g };
                    return $ret;
                })());
                j = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: a.x + b * this.e, y: c - this.g };
                    return $ret;
                })());
            }
            else {
                g = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: this.g, y: b * (1 - this.f) };
                    return $ret;
                })());
                h = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: this.d, y: b * (1 - this.c) };
                    return $ret;
                })());
                i = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: this.d, y: b * (1 - this.b) };
                    return $ret;
                })());
                j = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: this.g, y: b * (1 - this.e) };
                    return $ret;
                })());
            }
            f._startPoint = g.c;
            f._segments.add(h);
            f._segments.add(i);
            f._segments.add(j);
            f._isClosed = true;
            e.c.add(f);
            return e;
        }
        static a(a, b, c, d) {
            let e = new LinearGraphRectFrame();
            e.i = BrushUtil.k(c.i, a, d.i, 0);
            e.j = BrushUtil.k(c.j, a, d.j, 0);
            e.h = b * c.h + a * d.h;
            e.e = b * c.e + a * d.e;
            e.f = b * c.f + a * d.f;
            e.g = b * c.g + a * d.g;
            e.d = b * c.d + a * d.d;
            e.b = b * c.b + a * d.b;
            e.c = b * c.c + a * d.c;
            return e;
        }
    }
    LinearGraphRectFrame.$t = /*@__PURE__*/ markType(LinearGraphRectFrame, 'LinearGraphRectFrame');
    return LinearGraphRectFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphFrame = /*@__PURE__*/ (() => {
    class LinearGraphFrame extends Base {
        constructor() {
            super();
            this.a = null;
            this.b = null;
            this.a = new LinearGraphBackingFrame();
            this.b = new LinearGraphRectFrame();
        }
        d(a, b, c) {
            this.b = LinearGraphRectFrame.a(a, 1 - a, b.b, c.b);
            this.c.y(a, b.c, c.c);
            this.a.d(a, b.a, c.a);
        }
    }
    LinearGraphFrame.$t = /*@__PURE__*/ markType(LinearGraphFrame, 'LinearGraphFrame');
    return LinearGraphFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let MorphSegment = /*@__PURE__*/ (() => {
    class MorphSegment extends Base {
        constructor() {
            super();
            this.f = null;
            this.g = null;
            this.b = false;
            this.h = 0;
            this.e = false;
            this.a = false;
            this.d = false;
            this.c = false;
            this.f = new List$1(Point_$type, 0);
            this.g = new List$1(Point_$type, 0);
        }
        i(a) {
            this.g.clear();
            let b = 20;
            if (this.b) {
                let c;
                let d;
                let e;
                if (this.f.count == 0) {
                    d = { $type: Point_$type, x: 0, y: 0 };
                    e = { $type: Point_$type, x: 0, y: 0 };
                }
                else {
                    d = this.f._inner[0];
                    e = this.f._inner[1];
                }
                let f = GeometryUtil.l(d, e, this.h, !this.c, this.d);
                let g = GeometryUtil.e(f, d);
                let h = GeometryUtil.e(f, e);
                while (this.c && h < g) {
                    h += Math.PI * 2;
                }
                while (!this.c && h > g) {
                    h -= Math.PI * 2;
                }
                let i = 0;
                for (let j = 0; j < b; j++) {
                    c = j / b;
                    if (this.c) {
                        i = g + (h - g) * c;
                    }
                    else {
                        i = g - (g - h) * c;
                    }
                    this.g.add({ $type: Point_$type, x: f.x + Math.cos(i) * this.h, y: f.y + Math.sin(i) * this.h });
                }
            }
            else {
                let k;
                let l;
                let m;
                if (this.f.count == 0) {
                    l = { $type: Point_$type, x: 0, y: 0 };
                    m = { $type: Point_$type, x: 0, y: 0 };
                }
                else {
                    l = this.f._inner[0];
                    m = this.f._inner[1];
                }
                let n = l.x;
                let o = l.y;
                let p = m.x;
                let q = m.y;
                for (let r = 0; r < b; r++) {
                    k = r / b;
                    this.g.add({ $type: Point_$type, x: n + (p - n) * k, y: o + (q - o) * k });
                }
            }
            this.a = true;
        }
        l(a, b, c, d, e) {
            let f = this;
            let g = null;
            let h = f.f;
            let i = h.count;
            if (i == 0) {
                return a;
            }
            if (b._segments.count == 0) {
                let j = h._inner[0];
                b._startPoint = { $type: Point_$type, x: d + c * j.x, y: e + c * j.y };
            }
            if (f.b) {
                if (i > 1) {
                    let k = new ArcSegment();
                    g = k;
                    let l = h._inner[1];
                    k.e = { $type: Point_$type, x: d + c * l.x, y: e + c * l.y };
                    k.b = f.d;
                    k.d = f.c ? 1 : 0;
                    k.f = new Size(1, f.h * c, f.h * c);
                    a = k.e;
                }
            }
            else {
                let m = new PolyLineSegment();
                g = m;
                if (i > 1) {
                    let n;
                    let o = m._points;
                    for (let p = 1; p < i; p++) {
                        n = h._inner[p];
                        o.add({ $type: Point_$type, x: d + c * n.x, y: e + c * n.y });
                    }
                    a = m._points._inner[m._points.count - 1];
                }
            }
            b._segments.add(g);
            return a;
        }
        j(a, b, c) {
            let d = this;
            let e = b.f;
            let f = false;
            let g = c.f;
            let h = false;
            if (e.count == 0 && g.count == 0) {
                return;
            }
            d.b = false;
            d.e = false;
            d.a = false;
            d.d = false;
            d.c = false;
            if (b.e) {
                f = true;
            }
            if (c.e) {
                h = true;
            }
            if (b.b != c.b || b.e || c.e || b.d != c.d || b.c != c.c) {
                f = true;
                h = true;
                d.e = true;
            }
            if (f && !b.e) {
                if (!b.a) {
                    b.i(c.h);
                }
                e = b.g;
            }
            if (h && !c.e) {
                if (!c.a) {
                    c.i(b.h);
                }
                g = c.g;
            }
            if (b.e) {
                e = b.g;
            }
            if (c.e) {
                g = c.g;
            }
            d.g.clear();
            if (b.b && c.b) {
                d.b = true;
            }
            InterpolationUtil.b(d.f, a, e, g);
            if (d.e) {
                let i;
                let j = d.f.count;
                for (let k = 0; k < j; k++) {
                    i = d.f._inner[k];
                    d.g.add({ $type: Point_$type, x: i.x, y: i.y });
                }
                d.a = true;
            }
            if (b.d == c.d) {
                d.d = c.d;
            }
            if (b.c == c.c) {
                d.c = c.c;
            }
            if (d.b) {
                d.h = b.h + (c.h - b.h) * a;
            }
        }
        k() {
            this.f.clear();
            this.g.clear();
            this.e = false;
            this.a = false;
            this.b = false;
        }
    }
    MorphSegment.$t = /*@__PURE__*/ markType(MorphSegment, 'MorphSegment');
    return MorphSegment;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphNeedleFrame = /*@__PURE__*/ (() => {
    class LinearGraphNeedleFrame extends Base {
        constructor() {
            super();
            this.n = 0;
            this.m = 0;
            this.q = 0;
            this.p = 0;
            this.l = 0;
            this.r = null;
            this.s = null;
            this.o = 0;
            this.f = null;
            this.g = null;
            this.d = null;
            this.j = null;
            this.i = null;
            this.k = null;
            this.e = null;
            this.h = null;
            this.b = null;
            this.c = null;
            this.f = new MorphSegment();
            this.g = new MorphSegment();
            this.d = new MorphSegment();
            this.j = new MorphSegment();
            this.i = new MorphSegment();
            this.k = new MorphSegment();
            this.e = new MorphSegment();
            this.h = new MorphSegment();
            this.b = new MorphSegment();
            this.c = new MorphSegment();
        }
        static a(a, b, c, d) {
            let e = new LinearGraphNeedleFrame();
            e.n = c.n + (d.n - c.n) * a;
            e.m = c.m + (d.m - c.m) * a;
            e.q = c.q + (d.q - c.q) * a;
            e.l = c.l + (d.l - c.l) * a;
            e.p = c.p + (d.p - c.p) * a;
            e.r = BrushUtil.k(c.r, a, d.r, 0);
            e.s = BrushUtil.k(c.s, a, d.s, 0);
            e.o = c.o + (d.o - c.o) * a;
            e.f.j(a, c.f, d.f);
            e.g.j(a, c.g, d.g);
            e.d.j(a, c.d, d.d);
            e.j.j(a, c.j, d.j);
            e.i.j(a, c.i, d.i);
            e.k.j(a, c.k, d.k);
            e.e.j(a, c.e, d.e);
            e.h.j(a, c.h, d.h);
            e.b.j(a, c.b, d.b);
            e.c.j(a, c.c, d.c);
            return e;
        }
        t(a, b, c) {
            let d = new PathGeometry();
            let e = new PathFigure();
            let f = { $type: Point_$type, x: NaN, y: NaN };
            f = this.i.l(f, e, a, b, c);
            f = this.j.l(f, e, a, b, c);
            f = this.d.l(f, e, a, b, c);
            f = this.g.l(f, e, a, b, c);
            f = this.f.l(f, e, a, b, c);
            f = this.h.l(f, e, a, b, c);
            f = this.e.l(f, e, a, b, c);
            e._isClosed = true;
            d.c.add(e);
            let g = new PathFigure();
            if (this.b.f.count > 0 || this.c.f.count > 0) {
                f = this.b.l(f, g, a, b, c);
                f = this.c.l(f, g, a, b, c);
                g._isClosed = true;
                d.c.add(g);
            }
            return d;
        }
    }
    LinearGraphNeedleFrame.$t = /*@__PURE__*/ markType(LinearGraphNeedleFrame, 'LinearGraphNeedleFrame');
    return LinearGraphNeedleFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphScaleFrame = /*@__PURE__*/ (() => {
    class LinearGraphScaleFrame extends Base {
        constructor() {
            super();
            this.m = null;
            this.u = 0;
            this.r = 0;
            this.s = 0;
            this.t = 0;
            this.l = null;
            this.j = null;
            this.w = 0;
            this.v = 0;
            this.ad = null;
            this.x = 0;
            this.i = null;
            this.p = 0;
            this.o = 0;
            this.ac = null;
            this.q = 0;
            this.e = null;
            this.d = null;
            this.f = null;
            this.c = null;
            this.g = null;
            this.h = null;
            this.n = 0;
            this.ab = null;
            this.m = new List$1(LinearGraphRectFrame.$, 0);
            this.j = new Array(0);
            this.i = new Array(0);
            this.e = new Array(0);
            this.d = new Array(0);
            this.f = new Array(0);
            this.c = new Array(0);
            this.g = new Array(0);
            this.h = new Array(0);
            this.l = new LinearGraphRectFrame();
        }
        ae(a, b, c, d) {
            let e = new PathGeometry();
            let f = new PathFigure();
            let g = a.x;
            let h = a.y;
            let i, j, k, l;
            if (d == 1) {
                i = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + b * this.s, y: h };
                    return $ret;
                })());
                j = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + b * this.t, y: h };
                    return $ret;
                })());
                k = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + b * this.t, y: h + c };
                    return $ret;
                })());
                l = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + b * this.s, y: h + c };
                    return $ret;
                })());
            }
            else {
                i = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g, y: b * (1 - this.t) };
                    return $ret;
                })());
                j = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + c, y: b * (1 - this.t) };
                    return $ret;
                })());
                k = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g + c, y: b * (1 - this.s) };
                    return $ret;
                })());
                l = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: g, y: b * (1 - this.s) };
                    return $ret;
                })());
            }
            f._startPoint = i.c;
            f._segments.add(j);
            f._segments.add(k);
            f._segments.add(l);
            f._isClosed = true;
            e.c.add(f);
            return e;
        }
        y(a, b, c) {
            this.ad = BrushUtil.k(b.ad, a, c.ad, 0);
            this.ac = BrushUtil.k(b.ac, a, c.ac, 0);
            if (b.ab == null && c.ab == null) {
                this.ab = null;
            }
            else {
                this.ab = BrushUtil.k(b.ab, a, c.ab, 0);
            }
            this.u = b.u + (c.u - b.u) * a;
            this.r = b.r + (c.r - b.r) * a;
            this.s = b.s + (c.s - b.s) * a;
            this.t = b.t + (c.t - b.t) * a;
            this.n = b.n + (c.n - b.n) * a;
            this.w = b.w + (c.w - b.w) * a;
            this.v = b.v + (c.v - b.v) * a;
            this.p = b.p + (c.p - b.p) * a;
            this.o = b.o + (c.o - b.o) * a;
            this.x = b.x + (c.x - b.x) * a;
            this.q = b.q + (c.q - b.q) * a;
            this.j = this.a(a, this.j, b.j, c.j);
            this.i = this.a(a, this.i, b.i, c.i);
            this.e = this.a(a, this.e, b.e, c.e);
            this.f = this.a(a, this.f, b.f, c.f);
            this.c = this.a(a, this.c, b.c, c.c);
            this.g = this.a(a, this.g, b.g, c.g);
            this.h = this.a(a, this.h, b.h, c.h);
            this.d = this.b(a, this.d, b.d, c.d);
            this.aa(a, this.m, b.m, c.m);
            this.l = this.k(a, b.l, c.l);
        }
        a(a, b, c, d) {
            let e = Math.max(c.length, d.length);
            let f = Math.min(c.length, d.length);
            if (b.length != e) {
                b = new Array(e);
            }
            let g = 0;
            if (c.length > 0) {
                g = c[c.length - 1];
            }
            let h = 0;
            if (d.length > 0) {
                h = d[d.length - 1];
            }
            let i = c.length > d.length;
            let j = 0;
            for (j = 0; j < f; j++) {
                b[j] = c[j] + (d[j] - c[j]) * a;
            }
            let k;
            let l;
            for (j = f; j < e; j++) {
                if (i) {
                    k = c[j];
                    l = h;
                }
                else {
                    k = g;
                    l = d[j];
                }
                b[j] = k + (l - k) * a;
            }
            return b;
        }
        b(a, b, c, d) {
            let e = Math.max(c.length, d.length);
            let f = Math.min(c.length, d.length);
            if (b.length != e) {
                b = new Array(e);
            }
            let g = null;
            if (c.length > 0) {
                g = c[c.length - 1];
            }
            let h = null;
            if (d.length > 0) {
                h = d[d.length - 1];
            }
            let i = c.length > d.length;
            let j = 0;
            for (j = 0; j < f; j++) {
                b[j] = d[j];
            }
            let k;
            let l;
            for (j = f; j < e; j++) {
                if (i) {
                    k = c[j];
                    l = h;
                }
                else {
                    k = g;
                    l = d[j];
                }
                if (l != null) {
                    b[j] = l;
                }
                else {
                    b[j] = k;
                }
            }
            return b;
        }
        aa(a, b, c, d) {
            InterpolationUtil.c(LinearGraphRectFrame.$, b, a, c, d, () => new LinearGraphRectFrame(), LinearGraphRectFrame.a);
        }
        k(a, b, c) {
            let d = 1 - a;
            return LinearGraphRectFrame.a(a, d, b, c);
        }
        z(a, b, c, d) {
            InterpolationUtil.c(LinearGraphNeedleFrame.$, b, a, c, d, () => new LinearGraphNeedleFrame(), LinearGraphNeedleFrame.a);
        }
    }
    LinearGraphScaleFrame.$t = /*@__PURE__*/ markType(LinearGraphScaleFrame, 'LinearGraphScaleFrame');
    return LinearGraphScaleFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BulletGraphScaleFrame = /*@__PURE__*/ (() => {
    class BulletGraphScaleFrame extends LinearGraphScaleFrame {
        constructor() {
            super();
            this.af = null;
            this.af = new LinearGraphRectFrame();
        }
        y(a, b, c) {
            super.y(a, b, c);
            this.af = LinearGraphRectFrame.a(a, 1 - a, b.af, c.af);
        }
    }
    BulletGraphScaleFrame.$t = /*@__PURE__*/ markType(BulletGraphScaleFrame, 'BulletGraphScaleFrame', LinearGraphScaleFrame.$);
    return BulletGraphScaleFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BulletGraphFrame = /*@__PURE__*/ (() => {
    class BulletGraphFrame extends LinearGraphFrame {
        constructor() {
            super();
            this._c = null;
            this.c = new BulletGraphScaleFrame();
        }
        get_c() {
            return this._c;
        }
        set_c(a) {
            this._c = a;
        }
        get c() {
            return this.get_c();
        }
        set c(a) {
            this.set_c(a);
        }
    }
    BulletGraphFrame.$t = /*@__PURE__*/ markType(BulletGraphFrame, 'BulletGraphFrame', LinearGraphFrame.$);
    return BulletGraphFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphScaler = /*@__PURE__*/ (() => {
    class LinearGraphScaler extends Base {
        constructor(a, b, c, d, e) {
            super();
            this.f = 0;
            this.e = 0;
            this.d = 0;
            this.c = 0;
            this.a = false;
            this.g = 0;
            this.b = 0;
            this.f = c;
            this.e = d;
            this.a = e;
            this.d = a;
            this.c = b;
            this.g = c;
            this.b = d;
        }
        get j() {
            return this.g;
        }
        get h() {
            return this.b;
        }
        i(a) {
            let b = (a - this.d) / (this.c - this.d);
            if (this.a) {
                b = 1 - b;
            }
            let c = this.g + (this.b - this.g) * b;
            c = Math.round(c * 100) / 100;
            return c;
        }
        k(a) {
            let b = (a - this.g) / (this.b - this.g);
            if (this.a) {
                b = 1 - b;
            }
            let c = this.d + (this.c - this.d) * b;
            return c;
        }
    }
    LinearGraphScaler.$t = /*@__PURE__*/ markType(LinearGraphScaler, 'LinearGraphScaler');
    return LinearGraphScaler;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Describes the orientation of a linear scale.
 */
var LinearScaleOrientation = /*@__PURE__*/ (function (LinearScaleOrientation) {
    /**
     * The scale has a horizontal orientation.
     */
    LinearScaleOrientation[LinearScaleOrientation["Horizontal"] = 0] = "Horizontal";
    /**
     * The scale has a vertical orientation.
     */
    LinearScaleOrientation[LinearScaleOrientation["Vertical"] = 1] = "Vertical";
    return LinearScaleOrientation;
})({});
/**
 * @hidden
 */
let LinearScaleOrientation_$type = /*@__PURE__*/ markEnum('LinearScaleOrientation', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let XamLinearGraphRange = /*@__PURE__*/ (() => {
    class XamLinearGraphRange extends DependencyObject {
        constructor() {
            super();
            this.propertyChanged = null;
        }
        ac(a, b, c) {
        }
        ab(a, b, c) {
            this.ac(a, b, c);
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
        }
    }
    XamLinearGraphRange.$t = /*@__PURE__*/ markType(XamLinearGraphRange, 'XamLinearGraphRange', DependencyObject.$, [INotifyPropertyChanged_$type]);
    XamLinearGraphRange.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, XamLinearGraphRange, 'ab', ['Brush:an:ad', [Brush.$, null], 'EndValue:j:ae', [1, NaN], 'InnerEndExtent:k:af', [1, NaN], 'InnerStartExtent:l:ag', [1, NaN], 'Name:u:ah', [2, null], 'OuterEndExtent:m:ai', [1, NaN], 'OuterStartExtent:n:aj', [1, NaN], 'Outline:ao:ak', [Brush.$, null], 'StartValue:o:al', [1, NaN], 'StrokeThickness:p:am', [1, 1]]);
    return XamLinearGraphRange;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphRangeCollection = /*@__PURE__*/ (() => {
    class LinearGraphRangeCollection extends ObservableCollection$1 {
        constructor() {
            super(XamLinearGraphRange.$, 0);
        }
    }
    LinearGraphRangeCollection.$t = /*@__PURE__*/ markType(LinearGraphRangeCollection, 'LinearGraphRangeCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(XamLinearGraphRange.$));
    return LinearGraphRangeCollection;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FormatLinearGraphLabelEventArgs = /*@__PURE__*/ (() => {
    class FormatLinearGraphLabelEventArgs extends EventArgs {
        constructor() {
            super(...arguments);
            this.actualMinimumValue = 0;
            this.actualMaximumValue = 0;
            this.value = 0;
            this.label = null;
        }
    }
    FormatLinearGraphLabelEventArgs.$t = /*@__PURE__*/ markType(FormatLinearGraphLabelEventArgs, 'FormatLinearGraphLabelEventArgs', EventArgs.$);
    return FormatLinearGraphLabelEventArgs;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let AlignLinearGraphLabelEventArgs = /*@__PURE__*/ (() => {
    class AlignLinearGraphLabelEventArgs extends FormatLinearGraphLabelEventArgs {
        constructor() {
            super(...arguments);
            this.width = 0;
            this.height = 0;
            this.offsetX = 0;
            this.offsetY = 0;
        }
    }
    AlignLinearGraphLabelEventArgs.$t = /*@__PURE__*/ markType(AlignLinearGraphLabelEventArgs, 'AlignLinearGraphLabelEventArgs', FormatLinearGraphLabelEventArgs.$);
    return AlignLinearGraphLabelEventArgs;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphVisualData = /*@__PURE__*/ (() => {
    class LinearGraphVisualData extends Base {
        constructor() {
            super(...arguments);
            this._scalePath = null;
            this._backingPath = null;
            this._underlayPath = null;
            this._overlayPath = null;
            this._scale = null;
            this._scaleLabels = null;
            this._scaleTickmarks = null;
            this._ranges = null;
            this._toolTip = null;
            this._name = null;
            this._viewport = null;
        }
        get scalePath() {
            return this._scalePath;
        }
        set scalePath(a) {
            this._scalePath = a;
        }
        get backingPath() {
            return this._backingPath;
        }
        set backingPath(a) {
            this._backingPath = a;
        }
        get underlayPath() {
            return this._underlayPath;
        }
        set underlayPath(a) {
            this._underlayPath = a;
        }
        get overlayPath() {
            return this._overlayPath;
        }
        set overlayPath(a) {
            this._overlayPath = a;
        }
        get scale() {
            return this._scale;
        }
        set scale(a) {
            this._scale = a;
        }
        get scaleLabels() {
            return this._scaleLabels;
        }
        set scaleLabels(a) {
            this._scaleLabels = a;
        }
        get scaleTickmarks() {
            return this._scaleTickmarks;
        }
        set scaleTickmarks(a) {
            this._scaleTickmarks = a;
        }
        get ranges() {
            return this._ranges;
        }
        set ranges(a) {
            this._ranges = a;
        }
        get toolTip() {
            return this._toolTip;
        }
        set toolTip(a) {
            this._toolTip = a;
        }
        get name() {
            return this._name;
        }
        set name(a) {
            this._name = a;
        }
        scaleByViewport() {
            if (this.scalePath != null) {
                this.scalePath.scaleByViewport(this.viewport);
            }
            if (this.backingPath != null) {
                this.backingPath.scaleByViewport(this.viewport);
            }
            if (this.underlayPath != null) {
                this.underlayPath.scaleByViewport(this.viewport);
            }
            if (this.overlayPath != null) {
                this.overlayPath.scaleByViewport(this.viewport);
            }
            if (this.scaleLabels != null) {
                for (let a of fromEnum(this.scaleLabels)) {
                    a.scaleByViewport(this.viewport);
                }
            }
            if (this.scaleTickmarks != null) {
                for (let b of fromEnum(this.scaleTickmarks)) {
                    if (b.tickPath != null) {
                        b.tickPath.scaleByViewport(this.viewport);
                    }
                }
            }
            if (this.ranges != null) {
                for (let c of fromEnum(this.ranges)) {
                    if (c.rangePath != null) {
                        c.rangePath.scaleByViewport(this.viewport);
                    }
                }
            }
        }
        serialize() {
            let a = new StringBuilder(0);
            let b = true;
            a.u("{");
            if (this.scalePath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("scalePath: ");
                a.u(this.scalePath.serialize());
            }
            if (this.backingPath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("backingPath: ");
                a.u(this.backingPath.serialize());
            }
            if (this.underlayPath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("underlayPath: ");
                a.u(this.underlayPath.serialize());
            }
            if (this.overlayPath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("overlayPath: ");
                a.u(this.overlayPath.serialize());
            }
            if (this.scaleLabels != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                let c = true;
                a.l("scaleLabels: [");
                for (let d of fromEnum(this.scaleLabels)) {
                    if (c) {
                        c = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(d.serialize());
                }
                a.u("]");
            }
            if (this.scaleTickmarks != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                let e = true;
                a.l("scaleTickmarks: [");
                for (let f of fromEnum(this.scaleTickmarks)) {
                    if (e) {
                        e = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(f.serialize());
                }
                a.u("]");
            }
            if (this.ranges != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                let g = true;
                a.l("ranges: [");
                for (let h of fromEnum(this.ranges)) {
                    if (g) {
                        g = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(h.serialize());
                }
                a.u("]");
            }
            if (this.name != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("name: '");
                a.l(this.name);
                a.u("'");
            }
            if (this.toolTip != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("toolTip: ");
                a.l(this.toolTip.serialize());
            }
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("viewport: {");
            a.l("left: " + this.viewport.left + ", top: " + this.viewport.top + ", width: " + this.viewport.width + ", height: " + this.viewport.height);
            a.u("}");
            a.l("}");
            return a.toString();
        }
        get viewport() {
            return this._viewport;
        }
        set viewport(a) {
            this._viewport = a;
        }
    }
    LinearGraphVisualData.$t = /*@__PURE__*/ markType(LinearGraphVisualData, 'LinearGraphVisualData');
    return LinearGraphVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BulletGraphVisualData = /*@__PURE__*/ (() => {
    class BulletGraphVisualData extends LinearGraphVisualData {
        constructor() {
            super(...arguments);
            this._targetValuePath = null;
            this._valuePath = null;
            this._scaleBackgroundPath = null;
            this._targetValue = null;
            this._value = null;
        }
        get targetValuePath() {
            return this._targetValuePath;
        }
        set targetValuePath(a) {
            this._targetValuePath = a;
        }
        get valuePath() {
            return this._valuePath;
        }
        set valuePath(a) {
            this._valuePath = a;
        }
        get scaleBackgroundPath() {
            return this._scaleBackgroundPath;
        }
        set scaleBackgroundPath(a) {
            this._scaleBackgroundPath = a;
        }
        get targetValue() {
            return this._targetValue;
        }
        set targetValue(a) {
            this._targetValue = a;
        }
        get value() {
            return this._value;
        }
        set value(a) {
            this._value = a;
        }
        scaleByViewport() {
            super.scaleByViewport();
            if (this.targetValuePath != null) {
                this.targetValuePath.scaleByViewport(this.viewport);
            }
            if (this.valuePath != null) {
                this.valuePath.scaleByViewport(this.viewport);
            }
            if (this.scaleBackgroundPath != null) {
                this.scaleBackgroundPath.scaleByViewport(this.viewport);
            }
        }
        serialize() {
            let a = super.serialize();
            let b = new StringBuilder(0);
            let c = a.length == 0;
            if (this.targetValuePath != null) {
                if (c) {
                    c = false;
                }
                else {
                    b.l(", ");
                }
                b.l("targetValuePath: ");
                b.u(this.targetValuePath.serialize());
            }
            if (this.targetValue != null) {
                if (c) {
                    c = false;
                }
                else {
                    b.l(", ");
                }
                b.l("targetValue: ");
                b.u(this.targetValue.serialize());
            }
            if (this.valuePath != null) {
                if (c) {
                    c = false;
                }
                else {
                    b.l(", ");
                }
                b.l("valuePath: ");
                b.u(this.valuePath.serialize());
            }
            if (this.value != null) {
                if (c) {
                    c = false;
                }
                else {
                    b.l(", ");
                }
                b.l("value: ");
                b.u(this.value.serialize());
            }
            if (this.scaleBackgroundPath != null) {
                if (c) {
                    c = false;
                }
                else {
                    b.l(", ");
                }
                b.l("scaleBackgroundPath: ");
                b.u(this.scaleBackgroundPath.serialize());
            }
            if (c) {
                return a;
            }
            b.l("}");
            return a.substr(0, a.length - 1) + b.toString();
        }
    }
    BulletGraphVisualData.$t = /*@__PURE__*/ markType(BulletGraphVisualData, 'BulletGraphVisualData', LinearGraphVisualData.$);
    return BulletGraphVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ToolTipInfo = /*@__PURE__*/ (() => {
    class ToolTipInfo extends Base {
        constructor() {
            super(...arguments);
            this.c = null;
            this.b = 0;
            this.d = null;
            this.a = null;
        }
    }
    ToolTipInfo.$t = /*@__PURE__*/ markType(ToolTipInfo, 'ToolTipInfo');
    return ToolTipInfo;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphScaleLabelVisualData = /*@__PURE__*/ (() => {
    class LinearGraphScaleLabelVisualData extends Base {
        constructor() {
            super(...arguments);
            this._labelValue = null;
            this._labelSize = null;
            this._labelPosition = null;
            this._appearance = null;
        }
        get labelValue() {
            return this._labelValue;
        }
        set labelValue(a) {
            this._labelValue = a;
        }
        get labelSize() {
            return this._labelSize;
        }
        set labelSize(a) {
            this._labelSize = a;
        }
        get labelPosition() {
            return this._labelPosition;
        }
        set labelPosition(a) {
            this._labelPosition = a;
        }
        get appearance() {
            return this._appearance;
        }
        set appearance(a) {
            this._appearance = a;
        }
        scaleByViewport(a) {
            this.labelPosition = new PointData((this.labelPosition.x - a.left) / a.width, (this.labelPosition.y - a.top) / a.height);
            this.labelSize = new SizeData((this.labelSize.width) / a.width, (this.labelSize.height) / a.height);
        }
        serialize() {
            return "{ labelValue: '" + this.labelValue + "', labelSize: { width: " + this.labelSize.width + ", height: " + this.labelSize.height + "}, labelPosition: { x: " + this.labelPosition.x + ", y: " + this.labelPosition.y + "}, appearance: " + this.appearance.serialize() + "}";
        }
    }
    LinearGraphScaleLabelVisualData.$t = /*@__PURE__*/ markType(LinearGraphScaleLabelVisualData, 'LinearGraphScaleLabelVisualData');
    return LinearGraphScaleLabelVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphScaleLabelVisualDataList = /*@__PURE__*/ (() => {
    class LinearGraphScaleLabelVisualDataList extends List$1 {
        constructor() {
            super(LinearGraphScaleLabelVisualData.$, 0);
        }
    }
    LinearGraphScaleLabelVisualDataList.$t = /*@__PURE__*/ markType(LinearGraphScaleLabelVisualDataList, 'LinearGraphScaleLabelVisualDataList', /*@__PURE__*/ List$1.$.specialize(LinearGraphScaleLabelVisualData.$));
    return LinearGraphScaleLabelVisualDataList;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphScaleTickmarkVisualData = /*@__PURE__*/ (() => {
    class LinearGraphScaleTickmarkVisualData extends Base {
        constructor() {
            super(...arguments);
            this._tickPath = null;
        }
        get tickPath() {
            return this._tickPath;
        }
        set tickPath(a) {
            this._tickPath = a;
        }
        serialize() {
            return "{ tickPath: " + this.tickPath.serialize() + "}";
        }
    }
    LinearGraphScaleTickmarkVisualData.$t = /*@__PURE__*/ markType(LinearGraphScaleTickmarkVisualData, 'LinearGraphScaleTickmarkVisualData');
    return LinearGraphScaleTickmarkVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphScaleTickmarkVisualDataList = /*@__PURE__*/ (() => {
    class LinearGraphScaleTickmarkVisualDataList extends List$1 {
        constructor() {
            super(LinearGraphScaleTickmarkVisualData.$, 0);
        }
    }
    LinearGraphScaleTickmarkVisualDataList.$t = /*@__PURE__*/ markType(LinearGraphScaleTickmarkVisualDataList, 'LinearGraphScaleTickmarkVisualDataList', /*@__PURE__*/ List$1.$.specialize(LinearGraphScaleTickmarkVisualData.$));
    return LinearGraphScaleTickmarkVisualDataList;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ToolTipItemVisualData = /*@__PURE__*/ (() => {
    class ToolTipItemVisualData extends Base {
    }
    ToolTipItemVisualData.$t = /*@__PURE__*/ markType(ToolTipItemVisualData, 'ToolTipItemVisualData');
    return ToolTipItemVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphRangeVisualData = /*@__PURE__*/ (() => {
    class LinearGraphRangeVisualData extends ToolTipItemVisualData {
        constructor() {
            super(...arguments);
            this._rangePath = null;
        }
        get rangePath() {
            return this._rangePath;
        }
        set rangePath(a) {
            this._rangePath = a;
        }
        serialize() {
            return "{ rangePath: " + this.rangePath.serialize() + ", type: '" + this.type + "'}";
        }
        get_type() {
            return "range";
        }
        get type() {
            return this.get_type();
        }
    }
    LinearGraphRangeVisualData.$t = /*@__PURE__*/ markType(LinearGraphRangeVisualData, 'LinearGraphRangeVisualData', ToolTipItemVisualData.$);
    return LinearGraphRangeVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphRangeVisualDataList = /*@__PURE__*/ (() => {
    class LinearGraphRangeVisualDataList extends List$1 {
        constructor() {
            super(LinearGraphRangeVisualData.$, 0);
        }
    }
    LinearGraphRangeVisualDataList.$t = /*@__PURE__*/ markType(LinearGraphRangeVisualDataList, 'LinearGraphRangeVisualDataList', /*@__PURE__*/ List$1.$.specialize(LinearGraphRangeVisualData.$));
    return LinearGraphRangeVisualDataList;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ValueVisualData = /*@__PURE__*/ (() => {
    class ValueVisualData extends ToolTipItemVisualData {
        constructor() {
            super(...arguments);
            this._value = 0;
        }
        get value() {
            return this._value;
        }
        set value(a) {
            this._value = a;
        }
        serialize() {
            return "{ value: " + this.value.toString() + ", type: '" + this.type + "'}";
        }
        get_type() {
            return "value";
        }
        get type() {
            return this.get_type();
        }
    }
    ValueVisualData.$t = /*@__PURE__*/ markType(ValueVisualData, 'ValueVisualData', ToolTipItemVisualData.$);
    return ValueVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BulletGraphTargetValueVisualData = /*@__PURE__*/ (() => {
    class BulletGraphTargetValueVisualData extends ToolTipItemVisualData {
        constructor() {
            super(...arguments);
            this._value = 0;
        }
        get value() {
            return this._value;
        }
        set value(a) {
            this._value = a;
        }
        serialize() {
            return "{ value: " + this.value.toString() + ", type: '" + this.type + "'}";
        }
        get_type() {
            return "targetValue";
        }
        get type() {
            return this.get_type();
        }
    }
    BulletGraphTargetValueVisualData.$t = /*@__PURE__*/ markType(BulletGraphTargetValueVisualData, 'BulletGraphTargetValueVisualData', ToolTipItemVisualData.$);
    return BulletGraphTargetValueVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphToolTipVisualData = /*@__PURE__*/ (() => {
    class LinearGraphToolTipVisualData extends Base {
        constructor() {
            super(...arguments);
            this._item = null;
            this._outline = null;
            this._itemBrush = null;
            this._thickness = 0;
        }
        get item() {
            return this._item;
        }
        set item(a) {
            this._item = a;
        }
        get outline() {
            return this._outline;
        }
        set outline(a) {
            this._outline = a;
        }
        get itemBrush() {
            return this._itemBrush;
        }
        set itemBrush(a) {
            this._itemBrush = a;
        }
        get thickness() {
            return this._thickness;
        }
        set thickness(a) {
            this._thickness = a;
        }
        serialize() {
            let a = new StringBuilder(0);
            a.l("{ item: ");
            if (this.item != null) {
                a.l(this.item.serialize());
            }
            a.l(", ");
            a.l("outline: ");
            a.l(this.outline.serialize());
            a.l(", ");
            a.l("itemBrush: ");
            a.l(this.itemBrush.serialize());
            a.l(", ");
            a.l("thickness: ");
            a.l(this.thickness.toString());
            a.l("}");
            return a.toString();
        }
    }
    LinearGraphToolTipVisualData.$t = /*@__PURE__*/ markType(LinearGraphToolTipVisualData, 'LinearGraphToolTipVisualData');
    return LinearGraphToolTipVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphTooltipDataContext = /*@__PURE__*/ (() => {
    class LinearGraphTooltipDataContext extends DependencyObject {
        constructor() {
            super(...arguments);
            this.propertyChanged = null;
        }
        get item() {
            return this.c(LinearGraphTooltipDataContext.itemProperty);
        }
        set item(a) {
            this.h(LinearGraphTooltipDataContext.itemProperty, a);
        }
        get itemName() {
            return this.c(LinearGraphTooltipDataContext.itemNameProperty);
        }
        set itemName(a) {
            this.h(LinearGraphTooltipDataContext.itemNameProperty, a);
        }
        get brush() {
            return this.c(LinearGraphTooltipDataContext.itemBrushProperty);
        }
        set brush(a) {
            this.h(LinearGraphTooltipDataContext.itemBrushProperty, a);
        }
        get label() {
            return this.c(LinearGraphTooltipDataContext.labelProperty);
        }
        set label(a) {
            this.h(LinearGraphTooltipDataContext.labelProperty, a);
        }
        p(a, b, c) {
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
        }
    }
    LinearGraphTooltipDataContext.$t = /*@__PURE__*/ markType(LinearGraphTooltipDataContext, 'LinearGraphTooltipDataContext', DependencyObject.$, [INotifyPropertyChanged_$type]);
    LinearGraphTooltipDataContext.labelProperty = /*@__PURE__*/ DependencyProperty.i("Label", String_$type, LinearGraphTooltipDataContext.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => (typeCast(LinearGraphTooltipDataContext.$, a)).p("Label", b.oldValue, b.newValue)));
    LinearGraphTooltipDataContext.itemProperty = /*@__PURE__*/ DependencyProperty.i("Item", Base.$, LinearGraphTooltipDataContext.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => (typeCast(LinearGraphTooltipDataContext.$, a)).p("Item", b.oldValue, b.newValue)));
    LinearGraphTooltipDataContext.itemNameProperty = /*@__PURE__*/ DependencyProperty.i("ItemName", Base.$, LinearGraphTooltipDataContext.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => (typeCast(LinearGraphTooltipDataContext.$, a)).p("ItemName", b.oldValue, b.newValue)));
    LinearGraphTooltipDataContext.itemBrushProperty = /*@__PURE__*/ DependencyProperty.i("ItemBrush", Brush.$, LinearGraphTooltipDataContext.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => (typeCast(LinearGraphTooltipDataContext.$, a)).p("ItemBrush", b.oldValue, b.newValue)));
    LinearGraphTooltipDataContext.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, LinearGraphTooltipDataContext, 'p', ['Outline', [Brush.$, null], 'Thickness', [1, 0]]);
    return LinearGraphTooltipDataContext;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let XamBulletGraph = /*@__PURE__*/ (() => {
    class XamBulletGraph extends Control {
        constructor() {
            super();
            this.propertyChanged = null;
            this.av = null;
            this.bj = 0;
            this.formatLabel = null;
            this.alignLabel = null;
            this.an = null;
            this.am = null;
            this.al = null;
            this.aq = null;
            this.au = null;
            this.bg = 0;
            this.bf = 100;
            this.aj = null;
            this.a8 = false;
            this.a0 = null;
            this.ay = null;
            this.ax = null;
            this.a1 = null;
            this.az = null;
            this._view = null;
            this.ht = null;
            this.hs = null;
            this.hr = null;
            this.bi = NaN;
            this.bh = 1;
            this.ba = new List$1(TextBlock.$, 0);
            this.bd = new List$1(TextBlock.$, 0);
            this.bc = new List$1(Path.$, 0);
            this.bb = new List$1(Path.$, 0);
            this.a3 = false;
            this.bi = NaN;
            this.bh = 1;
            this.au = new XamLinearGraphRange();
            let a = this.au;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.ff));
            this.view = new XamBulletGraphView(this);
            this.view.a9();
            this.ht = Rect.empty;
            this.hs = Rect.empty;
            this.hr = Rect.empty;
            this.an = new BulletGraphFrame();
            this.am = new BulletGraphFrame();
            this.al = new BulletGraphFrame();
            this.ranges = new LinearGraphRangeCollection();
            this.a3 = true;
            this.av = new DoubleAnimator(0, 1, this.cy);
            let b = this.av;
            b.propertyChanged = delegateCombine(b.propertyChanged, runOn(this, this.ev));
            this.ab = XamBulletGraph.$;
            this.az = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.bj);
                $ret.c = runOn(this.view, this.view.bk);
                $ret.d = runOn(this.view, this.view.bl);
                $ret.j = runOn(this.view, this.view.cq);
                return $ret;
            })());
            this.a0 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.bc);
                $ret.c = runOn(this.view, this.view.bd);
                $ret.d = runOn(this.view, this.view.be);
                $ret.j = runOn(this.view, this.view.cp);
                return $ret;
            })());
            this.ay = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.bc);
                $ret.c = runOn(this.view, this.view.bd);
                $ret.d = runOn(this.view, this.view.be);
                $ret.j = runOn(this.view, this.view.cp);
                return $ret;
            })());
            this.ax = ((() => {
                let $ret = new StackPool$1(TextBlock.$);
                $ret.b = runOn(this.view, this.view.a1);
                $ret.c = runOn(this.view, this.view.a2);
                $ret.d = runOn(this.view, this.view.a3);
                $ret.j = runOn(this.view, this.view.b0);
                return $ret;
            })());
            this.a1 = ((() => {
                let $ret = new StackPool$1(TextBlock.$);
                $ret.b = runOn(this.view, this.view.bt);
                $ret.c = runOn(this.view, this.view.bu);
                $ret.d = runOn(this.view, this.view.bv);
                $ret.j = runOn(this.view, this.view.b1);
                return $ret;
            })());
        }
        e6(a) {
            this.fd(a);
        }
        fd(a) {
            let b = this.propertyChanged;
            if (b != null) {
                b(this, new PropertyChangedEventArgs(a));
            }
        }
        onDetachedFromUI() {
            this.view.a8();
        }
        onAttachedToUI() {
            this.view.a4();
        }
        ev(a, b) {
            this.cq = this.av.o;
        }
        get a2() {
            return this.av.f();
        }
        get cq() {
            return this.bj;
        }
        set cq(a) {
            let b = this.bj;
            this.bj = a;
            this.e5("TransitionProgress", b, this.bj);
        }
        fq() {
            this.bj = 0;
            this.av.w();
            this.av.v();
        }
        get a7() {
            return this.cy > 0;
        }
        get hj() {
            return this.c(XamBulletGraph.gl);
        }
        set hj(a) {
            this.h(XamBulletGraph.gl, a);
        }
        get hk() {
            return this.c(XamBulletGraph.gm);
        }
        set hk(a) {
            this.h(XamBulletGraph.gm, a);
        }
        get b8() {
            return this.c(XamBulletGraph.gn);
        }
        set b8(a) {
            this.h(XamBulletGraph.gn, a);
        }
        get bl() {
            return this.bg;
        }
        set bl(a) {
            this.bg = a;
        }
        get bk() {
            return this.bf;
        }
        set bk(a) {
            this.bf = a;
        }
        br(a) {
            let b = 0;
            let c = a.x;
            if (this.ar == 1) {
                b = a.y;
                c = this.hw.height;
            }
            return this.aq.k(c - b);
        }
        as() {
            let a = new BulletGraphVisualData();
            a.viewport = new RectData(this.hw.left, this.hw.top, this.hw.width, this.hw.height);
            a.scaleLabels = new LinearGraphScaleLabelVisualDataList();
            a.scaleTickmarks = new LinearGraphScaleTickmarkVisualDataList();
            a.ranges = new LinearGraphRangeVisualDataList();
            a.value = ((() => {
                let $ret = new ValueVisualData();
                $ret.value = this.cr;
                return $ret;
            })());
            a.targetValue = ((() => {
                let $ret = new BulletGraphTargetValueVisualData();
                $ret.value = this.ce;
                return $ret;
            })());
            this.view.aw(a);
            let b = this.view.l();
            if (b != null) {
                let c;
                switch (b.c) {
                    case "range":
                        c = a.ranges._inner[b.b];
                        break;
                    case "value":
                        c = a.value;
                        break;
                    default:
                        c = a.targetValue;
                        break;
                }
                a.toolTip = ((() => {
                    let $ret = new LinearGraphToolTipVisualData();
                    $ret.item = c;
                    $ret.itemBrush = AppearanceHelper.b(b.a.brush);
                    $ret.outline = AppearanceHelper.b(b.a.outline);
                    $ret.thickness = b.a.thickness;
                    return $ret;
                })());
            }
            return a;
        }
        c6() {
            let a = this.as();
            a.scaleByViewport();
            return a.serialize();
        }
        destroy() {
            this.provideContainer(null);
        }
        provideContainer(a) {
            this.view.a6(a);
        }
        onMouseOver(a, b, c) {
            if (this.a8) {
                this.fp(a, null);
            }
        }
        onMouseLeave() {
            if (this.a8) {
                this.fp({ $type: Point_$type, x: -10000, y: -10000 }, null);
            }
        }
        containerResized() {
            this.view.a7();
        }
        fr() {
            this.view.bs();
        }
        ez() {
            this.view.flush();
        }
        be(a) {
            let b = new List$1(Point_$type, 0);
            for (let c = 0; c < a.count; c++) {
                b.add({ $type: Point_$type, x: a._inner[c].x, y: a._inner[c].y });
            }
            return b;
        }
        fp(a, b) {
            let c = new PathVisualData(1, "targetValue", this.view.cn());
            let d = c.getPoints(new GetPointsSettings());
            if (d.count > 0) {
                let e = PolygonUtil.a(this.be(d._inner[0]), a);
                if (e == true) {
                    this.view.br(a, b, -1, "targetvalue");
                    return;
                }
            }
            let f = new PathVisualData(1, "value", this.view.co());
            let g = f.getPoints(new GetPointsSettings());
            if (g.count > 0) {
                let h = PolygonUtil.a(this.be(g._inner[0]), a);
                if (h == true) {
                    this.view.br(a, b, -1, "value");
                    return;
                }
            }
            for (let i = 0; i < this.bb.count; i++) {
                let j = new PathVisualData(1, "range", this.bb._inner[i]);
                let k = j.getPoints(new GetPointsSettings());
                if (k.count > 0) {
                    let l = PolygonUtil.a(this.be(k._inner[0]), a);
                    if (l == true) {
                        this.view.br(a, b, i, "range");
                        return;
                    }
                }
            }
            this.view.az();
        }
        fi() {
            if (!this.a3) {
                return;
            }
            let a = this.am.c;
            if (this.ar == 0) {
                let b = 0;
                for (let c = 0; c < a.c.length; c++) {
                    b = Math.max(b, a.c[c]);
                }
                let d = this.hw.height >= b ? this.hw.height - b : this.hw.height;
                this.hv = new Rect(0, 0, 0, this.hw.width, d);
            }
            else {
                let e = 0;
                for (let f = 0; f < a.f.length; f++) {
                    e = Math.max(e, a.f[f]);
                }
                let g = this.hw.width >= e ? this.hw.width - e : this.hw.width;
                this.hv = new Rect(0, e, 0, g, this.hw.height);
            }
        }
        get view() {
            return this._view;
        }
        set view(a) {
            this._view = a;
        }
        get hw() {
            return this.ht;
        }
        set hw(a) {
            let b = this.ht;
            this.ht = a;
            if (!b.equals1(this.ht)) {
                this.e7(b, this.ht);
            }
        }
        get hv() {
            return this.hs;
        }
        set hv(a) {
            this.hs = a;
        }
        get hu() {
            return this.hr;
        }
        set hu(a) {
            this.hr = a;
        }
        get b5() {
            return this.bi;
        }
        set b5(a) {
            let b = this.bi;
            this.bi = a;
            this.e5("PixelScalingRatio", b, this.bi);
        }
        get bm() {
            return this.bh;
        }
        set bm(a) {
            let b = this.bh;
            this.bh = a;
            this.e5("ActualPixelScalingRatio", b, this.bh);
        }
        a5() {
            return !isNaN_(this.bl) && !isNaN_(this.bk) && !this.hw.isEmpty && this.view.s();
        }
        ew() {
            if (!this.a5()) {
                return;
            }
            let a = this.cc();
            this.aq = new LinearGraphScaler(this.bl, this.bk, a, a + this.cb(), this.a4);
            if (this.a3) {
                if (this.a2) {
                    if (this.av.g) {
                        this.av.t();
                    }
                    let b = this.an;
                    this.an = this.al;
                    this.al = b;
                }
                else {
                    let c = this.an;
                    this.an = this.am;
                    this.am = c;
                }
            }
            else if (this.a2) {
                this.al.d(this.cq, this.an, this.am);
                this.fj(this.al);
                this.fl(this.al);
                this.fm(this.al);
                this.fo(this.al);
            }
            if (this.a3) {
                this.e9();
                this.fi();
                this.fb();
                this.fc();
                this.fa();
                this.e8();
            }
            if (this.a3 && this.a7) {
                this.fq();
                this.al.d(this.cq, this.an, this.am);
                this.fj(this.al);
                this.fl(this.al);
                this.fm(this.al);
                this.fo(this.al);
                this.fn(this.al);
                this.fk(this.al);
            }
            else {
                if (this.a3) {
                    this.fj(this.am);
                    this.fl(this.am);
                    this.fm(this.am);
                    this.fo(this.am);
                    this.fn(this.am);
                    this.fk(this.am);
                }
            }
            this.a3 = false;
            this.view.as();
        }
        fa() {
            let a = this.am;
            let b = a.c;
            let c = this.aq;
            let d = this.bz;
            let e = this.hv;
            if (isNaN_(d)) {
                d = 3;
            }
            b.u = this.cd;
            b.r = this.ca;
            b.s = 0;
            b.t = 1;
            b.m.clear();
            for (let f = 0; f < this.ranges.count; f++) {
                let g = this.ranges._inner[f];
                if (g.j <= this.bl || g.o > this.bk) {
                    continue;
                }
                let h = g.o;
                let i = g.j;
                if (h < this.bl) {
                    h = this.bl;
                }
                if (i > this.bk) {
                    i = this.bk;
                }
                let j = new LinearGraphRectFrame();
                j.i = g.an != null ? g.an : this.hh(f, this.ah);
                j.j = g.ao != null ? g.ao : this.hh(f, this.ai);
                j.h = g.p;
                j.g = c.i(h);
                j.d = c.i(i);
                j.e = g.l;
                j.b = g.k;
                j.f = g.n;
                j.c = g.m;
                if (isNaN_(j.e)) {
                    j.e = this.b6;
                }
                j.b = g.k;
                if (isNaN_(j.b)) {
                    j.b = this.b6;
                }
                j.f = g.n;
                if (isNaN_(j.f)) {
                    j.f = this.b7;
                }
                j.c = g.m;
                if (isNaN_(j.c)) {
                    j.c = this.b7;
                }
                b.m.add(j);
            }
            b.l.i = this.hj;
            b.l.j = this.hk;
            b.l.h = this.b8;
            b.l.g = c.i(this.bl);
            b.l.d = c.i(this.bk);
            b.l.e = this.b6;
            b.l.b = this.b6;
            b.l.f = this.b7;
            b.l.c = this.b7;
            b.ab = this.hg;
            b.ad = this.hn;
            b.x = this.cp;
            b.w = this.cn;
            b.v = this.cj;
            b.ac = this.hi;
            b.q = this.b4;
            b.p = this.b2;
            b.o = this.b0;
            let k = this.bs;
            if (isNaN_(k)) {
                k = (this.bk - this.bl) / 10;
            }
            if (k == 0) {
                k = this.bk - this.bl;
            }
            let l = new List$1(Number_$type, 0);
            let m = new List$1(Number_$type, 0);
            if (k > 0) {
                let n = this.bl + this.cl;
                let o = this.bk - this.cm;
                let p = 100000;
                let q = Math.abs(o - n) / p;
                if (k >= q) {
                    for (let r = n; r <= o || this.a9(r, o, k); r = r + k) {
                        l.add(c.i(r));
                        for (let s = 0; s < d; s++) {
                            let t = (k / (d + 1)) * (s + 1);
                            if (t + r > o) {
                                continue;
                            }
                            m.add(c.i(t + r));
                        }
                    }
                }
            }
            if (b.j.length != l.count || b.i.length != m.count) {
                b.j = new Array(l.count);
                b.i = new Array(m.count);
            }
            for (let u = 0; u < l.count; u++) {
                b.j[u] = l._inner[u];
            }
            for (let v = 0; v < m.count; v++) {
                b.i[v] = m._inner[v];
            }
        }
        hx() {
            let a = this.bs;
            let b = this.bu;
            if (isNaN_(a)) {
                a = (this.bk - this.bl) / 10;
            }
            if (isNaN_(b)) {
                b = a;
            }
            if (b == 0) {
                b = this.bk - this.bl;
            }
            let c = new List$1(Number_$type, 0);
            if (b > 0) {
                let d = this.bv + this.bl;
                let e = this.bk - this.bw;
                let f = 100000;
                let g = Math.abs(e - d) / f;
                if (b >= g) {
                    for (let h = d; h <= e || this.a9(h, e, a); h += b) {
                        c.add(h);
                    }
                }
            }
            let i = new Array(c.count);
            let j = new Array(c.count);
            for (let k = 0; k < c.count; k++) {
                let l = c._inner[k];
                if (this.formatLabel == null && this.aj == null) {
                    l = (Math.round(l * 100) / 100);
                }
                let m = l.toString();
                if (this.aj != null) {
                    m = this.aj.i(l);
                }
                let n = new FormatLinearGraphLabelEventArgs();
                n.value = l;
                n.label = m;
                if (this.formatLabel != null) {
                    this.formatLabel(this, n);
                }
                m = n.label;
                let o = this.view.cr(((() => {
                    let $ret = new TextBlock();
                    $ret.ak = m;
                    return $ret;
                })()));
                i[k] = o.width;
                j[k] = o.height;
            }
            let p = 0;
            let q = 0;
            let r = 1 - this.ca + this.cd;
            if (this.ar == 0) {
                for (let s = 0; s < j.length; s++) {
                    q = Math.max(q, j[s]);
                }
                for (let t = 0; t < i.length; t++) {
                    p += i[t];
                }
                if (i.length > 0) {
                    p += i[0] / 2;
                }
                if (i.length > 1) {
                    p += i[i.length - 1] / 2;
                }
                if (i.length > 0) {
                    p += (i.length - 1) * 5;
                }
                if (r > 0) {
                    p = p / Math.abs(1 - r);
                }
            }
            else {
                for (let u = 0; u < i.length; u++) {
                    p = Math.max(p, i[u]);
                }
                for (let v = 0; v < j.length; v++) {
                    q += j[v];
                }
                if (j.length > 0) {
                    q -= j[0] / 2;
                }
                if (j.length > 1) {
                    q -= j[j.length - 1] / 2;
                }
                if (r > 0) {
                    q = q / Math.abs(1 - r);
                }
                if (j.length > 0) {
                    q += (j.length - 1) * 5;
                }
            }
            return new Size(1, p, q);
        }
        e9() {
            let a = this.am;
            let b = a.c;
            let c = this.aq;
            let d = this.bs;
            let e = this.bu;
            let f = this.bz;
            if (isNaN_(d)) {
                d = (this.bk - this.bl) / 10;
            }
            if (isNaN_(e)) {
                e = d;
            }
            if (e == 0) {
                e = this.bk - this.bl;
            }
            let g = new List$1(Tuple$2.$.specialize(Number_$type, Number_$type), 0);
            if (e > 0) {
                let h = this.bv + this.bl;
                let i = this.bk - this.bw;
                let j = 100000;
                let k = Math.abs(i - h) / j;
                if (e >= k) {
                    for (let l = h; l <= i || this.a9(l, i, e); l = l + e) {
                        g.add(new Tuple$2(Number_$type, Number_$type, l, c.i(l)));
                    }
                }
            }
            if (b.d.length != g.count) {
                b.e = new Array(g.count);
                b.d = new Array(g.count);
                b.f = new Array(g.count);
                b.c = new Array(g.count);
                b.g = new Array(g.count);
                b.h = new Array(g.count);
            }
            b.n = this.bt;
            let m = new FormatLinearGraphLabelEventArgs();
            m.actualMinimumValue = this.bl;
            m.actualMaximumValue = this.bk;
            let n = new AlignLinearGraphLabelEventArgs();
            n.actualMinimumValue = this.bl;
            n.actualMaximumValue = this.bk;
            for (let o = 0; o < g.count; o++) {
                let p = g._inner[o].c;
                if (this.formatLabel == null) {
                    p = (Math.round(p * 100) / 100);
                }
                let q = (p).toString();
                if (this.aj != null) {
                    q = this.aj.i(p);
                }
                m.value = p;
                n.value = p;
                m.label = q;
                if (this.formatLabel != null) {
                    this.formatLabel(this, m);
                }
                q = m.label;
                n.label = q;
                let r = this.view.cr(((() => {
                    let $ret = new TextBlock();
                    $ret.ak = q;
                    return $ret;
                })()));
                n.width = r.width;
                n.height = r.height;
                if (this.ar == 0) {
                    n.offsetX = -1 * (r.width / 2);
                    n.offsetY = -1 * (r.height);
                }
                else {
                    n.offsetX = -1 * r.width;
                    n.offsetY = -1 * (r.height / 2);
                }
                if (this.alignLabel != null) {
                    this.alignLabel(this, n);
                }
                b.f[o] = n.width;
                b.c[o] = n.height;
                b.g[o] = n.offsetX;
                ;
                b.h[o] = n.offsetY;
                b.d[o] = q;
                b.e[o] = g._inner[o].d;
            }
        }
        a9(a, b, c) {
            let d = c / 10000;
            if (isNaN_(d)) {
                d = 1E-05;
            }
            let e = Math.abs(a - b);
            if (e < d) {
                return true;
            }
            return false;
        }
        e8() {
            let a = this.am;
            let b = a.a;
            b.e = this.he;
            b.f = this.hf;
            b.c = this.bp;
            b.a = this.bn;
            b.b = this.bo;
        }
        fb() {
            let a = this.am;
            let b = a.b;
            let c = this.aq;
            b.e = this.cg;
            b.b = this.cg;
            b.f = this.ch;
            b.c = this.ch;
            b.i = this.hl;
            b.j = this.hm;
            b.h = this.ci;
            if (isNaN_(this.ce)) {
                return;
            }
            let d = c.i(this.ce);
            let e = (this.cf / 2);
            b.g = d - e;
            b.d = d + e;
        }
        fc() {
            let a = this.am.c;
            let b = this.aq;
            let c = this.cr;
            if (isNaN_(c)) {
                return;
            }
            let d = this.bl;
            if (isNaN_(d)) {
                d = this.bl;
            }
            let e = this.cr;
            let f = new LinearGraphRectFrame();
            f.i = this.ho;
            f.j = this.hp;
            f.h = this.cu;
            f.g = b.i(d);
            f.d = b.i(e);
            f.e = this.cs;
            f.b = this.cs;
            f.f = this.ct;
            f.c = this.ct;
            a.af = f;
        }
        hh(a, b) {
            if (b != null && b.count > 0) {
                return b.item(a % b.count);
            }
            else {
                return null;
            }
        }
        fn(a) {
            let b = this.hv;
            let c = a.c;
            let d = this.a0;
            let e = c.j;
            let f = c.w;
            let g = c.v;
            let h = c.ad;
            let i = c.x;
            let j = this.ay;
            let k = c.i;
            let l = c.p;
            let m = c.o;
            let n = c.ac;
            let o = c.q;
            d.f = true;
            for (let p = 0; p < this.bc.count; p++) {
                d.n(this.bc._inner[p]);
            }
            this.bc.clear();
            let q = this.b9();
            let r = this.cw();
            for (let s = 0; s < e.length; s++) {
                let t, u, v, w;
                if (this.ar == 1) {
                    t = b.left + q * f;
                    u = r - e[s];
                    v = b.left + q * g;
                    w = u;
                }
                else {
                    t = b.left + e[s];
                    u = q * (1 - f);
                    v = t;
                    w = q * (1 - g);
                }
                let x = d.a();
                let y = new PathGeometry();
                let z = new PathFigure();
                z._startPoint = { $type: Point_$type, x: t, y: u };
                z._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: v, y: w };
                    return $ret;
                })()));
                y.c.add(z);
                x.ak = y;
                x._stroke = h;
                x.ac = i;
                this.bc.add(x);
            }
            for (let aa = 0; aa < k.length; aa++) {
                let ab, ac, ad, ae;
                if (this.ar == 1) {
                    ab = b.left + q * l;
                    ac = r - k[aa];
                    ad = b.left + q * m;
                    ae = ac;
                }
                else {
                    ab = k[aa];
                    ac = q * (1 - l);
                    ad = ab;
                    ae = q * (1 - m);
                }
                let af = d.a();
                let ag = new PathGeometry();
                let ah = new PathFigure();
                ah._startPoint = { $type: Point_$type, x: ab, y: ac };
                ah._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: ad, y: ae };
                    return $ret;
                })()));
                ag.c.add(ah);
                af.ak = ag;
                af._stroke = n;
                af.ac = o;
                this.bc.add(af);
            }
            d.f = false;
        }
        fk(a) {
            let b = this.hv;
            let c = a.c;
            let d = c.e;
            let e = c.d;
            let f = c.g;
            let g = c.h;
            let h = c.f;
            let i = c.c;
            let j = c.n;
            let k = this.ax;
            k.f = true;
            for (let l = 0; l < this.ba.count; l++) {
                k.n(this.ba._inner[l]);
            }
            this.ba.clear();
            let m = c.ab;
            let n = this.cv();
            let o = this.cw();
            for (let p = 0; p < e.length; p++) {
                let q, r;
                if (this.ar == 1) {
                    q = b.left + n * j;
                    r = b.top + o - d[p];
                }
                else {
                    q = b.left + d[p];
                    r = b.top + n * (1 - j);
                }
                let s = k.a();
                s.ak = e[p];
                this.view.bq(s, m);
                let t = h[p];
                let u = i[p];
                let v = f[p];
                let w = g[p];
                this.view.bh(s, q + v, r + w);
                this.ba.add(s);
            }
            k.f = false;
        }
        fl(a) {
            let b = a.c;
            let c = this.az;
            c.f = true;
            for (let d = 0; d < this.bb.count; d++) {
                c.n(this.bb._inner[d]);
            }
            this.bb.clear();
            let e = this.b9();
            let f = this.cw();
            let g = this.hq();
            let h = this.view.cm();
            h.ak = b.ae(g, e, f, this.ar);
            for (let i = 0; i < b.m.count; i++) {
                let j = b.m._inner[i];
                let k = c.a();
                k.ak = j.k(g, e, f, this.ar);
                k._fill = j.i;
                k._stroke = j.j;
                k.ac = j.h;
                this.bb.add(k);
            }
            this.view.bp(this.bb);
            c.f = false;
            let l = this.view.cl();
            l.ak = b.l.k(g, e, f, this.ar);
            l._fill = b.l.i;
            l._stroke = b.l.j;
            l.ac = b.l.h;
        }
        fj(a) {
            let b = this.hu;
            let c = this.view.ck();
            let d = a.a;
            let e = this.ar == 0 ? b.height : b.width;
            let f = this.ar == 0 ? b.width : b.height;
            let g = d.g(e, f, this.ar);
            c.ak = g;
            c._fill = d.e;
            c._stroke = d.f;
            c.ac = d.c;
        }
        fm(a) {
            let b = this.view.cn();
            if (isNaN_(this.ce) || this.ce < this.bl || this.ce > this.bk) {
                b.ak = null;
                return;
            }
            let c = a.b;
            let d = this.b9();
            let e = this.cw();
            let f = this.hq();
            let g = c.k(f, d, e, this.ar);
            b.ak = g;
            b._fill = c.i;
            b._stroke = c.j;
            b.ac = c.h;
        }
        fo(a) {
            let b = this.view.co();
            let c = this.cr;
            if (c <= this.bl || c > this.bk || isNaN_(c)) {
                b.ak = null;
                return;
            }
            let d = a.c;
            let e = this.b9();
            let f = this.cw();
            let g = this.hq();
            let h = d.af;
            b.ak = h.k(g, e, f, this.ar);
            b._fill = h.i;
            b._stroke = h.j;
            b.ac = h.h;
        }
        e7(a, b) {
            this.a3 = true;
            this.view.bo();
        }
        e2(a, b) {
            this.a3 = true;
            this.view.bo();
        }
        b9() {
            if (this.ar == 0) {
                return this.a6 ? this.hw.height : this.hv.height;
            }
            return this.a6 ? this.hw.width : this.hv.width;
        }
        cb() {
            if (this.ar == 0) {
                return this.hw.width * (this.ca - this.cd);
            }
            return this.hw.height * (this.ca - this.cd);
        }
        cv() {
            if (this.ar == 0) {
                return this.hw.height;
            }
            return this.hw.width;
        }
        cw() {
            if (this.ar == 0) {
                return this.hw.width;
            }
            return this.hw.height;
        }
        cc() {
            let a = this.cd;
            if (this.ar == 0) {
                if (this.a4) {
                    a = 1 - this.ca;
                }
                return this.hw.left + this.hw.width * a;
            }
            if (this.a4) {
                a = 1 - this.ca;
            }
            return this.hw.top + this.hw.height * a;
        }
        hq() {
            let a = this.hv.left;
            if (this.a6) {
                a = 0;
            }
            let b = this.cd;
            if (this.ar == 0) {
                if (this.a4) {
                    b = 1 - this.ca;
                }
                return { $type: Point_$type, x: a + this.hv.width * b, y: this.hv.top };
            }
            if (!this.a4) {
                b = 1 - this.ca;
            }
            return { $type: Point_$type, x: a, y: this.hv.top + this.hv.height * b };
        }
        e5(a, b, c) {
            switch (a) {
                case XamBulletGraph.$$p[48]:
                case XamBulletGraph.$$p[33]:
                case XamBulletGraph.$$p[37]:
                case XamBulletGraph.$$p[0]:
                case XamBulletGraph.$$p[3]:
                case XamBulletGraph.$$p[52]:
                case XamBulletGraph.$$p[40]:
                case XamBulletGraph.$$p[18]:
                    this.view.a5(a, b, c);
                    break;
                case XamBulletGraph.$$p[24]:
                    this.view.ba(b, c);
                    break;
                case XamBulletGraph.$$p[27]:
                    this.view.bb(b, c);
                    break;
            }
            switch (a) {
                case XamBulletGraph.$$p[10]:
                case XamBulletGraph.$$p[11]:
                    if (this.dd != null) {
                        this.aj = new BindingFormatter();
                        this.aj.j = this.dd;
                        this.aj.d = this.ag;
                    }
                    else {
                        this.aj = null;
                    }
                    this.a3 = true;
                    this.view.bo();
                    break;
                case XamBulletGraph.$$p[47]:
                    this.av.r = this.cy;
                    this.view.bo();
                    break;
                case "TransitionProgress":
                    if (this.cq >= 1) {
                        this.av.w();
                        let d = this.am;
                        this.am = this.an;
                        this.an = d;
                        this.e9();
                        this.fb();
                        this.fc();
                        this.fa();
                        this.e8();
                        this.fj(this.am);
                        this.fl(this.am);
                        this.fm(this.am);
                        this.fo(this.am);
                        this.fn(this.am);
                        this.fk(this.am);
                    }
                    this.al.d(this.cq, this.an, this.am);
                    this.fj(this.al);
                    this.fl(this.al);
                    this.fm(this.al);
                    this.fo(this.al);
                    this.fn(this.al);
                    this.fk(this.al);
                    this.view.as();
                    break;
                case XamBulletGraph.$$p[53]:
                case XamBulletGraph.$$p[49]:
                case XamBulletGraph.$$p[51]:
                case XamBulletGraph.$$p[48]:
                case XamBulletGraph.$$p[52]:
                case XamBulletGraph.$$p[54]:
                case XamBulletGraph.$$p[33]:
                case XamBulletGraph.$$p[37]:
                case XamBulletGraph.$$p[39]:
                case XamBulletGraph.$$p[32]:
                case XamBulletGraph.$$p[34]:
                case XamBulletGraph.$$p[36]:
                case XamBulletGraph.$$p[0]:
                case XamBulletGraph.$$p[3]:
                case XamBulletGraph.$$p[40]:
                case XamBulletGraph.$$p[18]:
                case XamBulletGraph.$$p[24]:
                case XamBulletGraph.$$p[27]:
                case XamBulletGraph.$$p[16]:
                case XamBulletGraph.$$p[38]:
                case XamBulletGraph.$$p[35]:
                case XamBulletGraph.$$p[25]:
                case XamBulletGraph.$$p[26]:
                case XamBulletGraph.$$p[4]:
                case XamBulletGraph.$$p[1]:
                case XamBulletGraph.$$p[2]:
                case XamBulletGraph.$$p[7]:
                case XamBulletGraph.$$p[12]:
                case XamBulletGraph.$$p[9]:
                case XamBulletGraph.$$p[13]:
                case XamBulletGraph.$$p[14]:
                case XamBulletGraph.$$p[42]:
                case XamBulletGraph.$$p[43]:
                case XamBulletGraph.$$p[44]:
                case XamBulletGraph.$$p[41]:
                case XamBulletGraph.$$p[45]:
                case XamBulletGraph.$$p[21]:
                case XamBulletGraph.$$p[20]:
                case XamBulletGraph.$$p[19]:
                case XamBulletGraph.$$p[22]:
                case "ScaleBackgroundBrush":
                case "ScaleBackgroundOutline":
                case "ScaleBackgroundThickness":
                    this.a3 = true;
                    this.view.bo();
                    break;
                case XamBulletGraph.$$p[28]:
                    let e = b;
                    let f = c;
                    if (e != null) {
                        let g = e;
                        g.collectionChanged = delegateRemove(g.collectionChanged, runOn(this, this.fg));
                    }
                    if (f != null) {
                        let h = f;
                        h.collectionChanged = delegateCombine(h.collectionChanged, runOn(this, this.fg));
                    }
                    this.a3 = true;
                    this.view.bo();
                    break;
                case XamBulletGraph.$$p[23]:
                case XamBulletGraph.$$p[8]:
                case XamBulletGraph.$$p[17]:
                case XamBulletGraph.$$p[15]:
                case XamBulletGraph.$$p[29]:
                case XamBulletGraph.$$p[30]:
                    this.bl = Math.min(this.by, this.bx);
                    this.bk = Math.max(this.by, this.bx);
                    let i = this.cc();
                    this.aq = new LinearGraphScaler(this.bl, this.bk, i, i + this.cb(), this.a4);
                    this.a3 = true;
                    this.view.bo();
                    break;
                case XamBulletGraph.$$p[5]:
                case XamBulletGraph.$$p[6]:
                    this.view.by();
                    this.a3 = true;
                    this.view.bo();
                    break;
                case "PixelScalingRatio":
                    if (isNaN_(DeviceUtils.a(this.b5))) {
                        this.bm = 1;
                    }
                    else {
                        this.bm = DeviceUtils.a(this.b5);
                    }
                    break;
                case "ActualPixelScalingRatio":
                    this.view.bf();
                    break;
            }
            this.e6(a);
        }
        fg(a, b) {
            if (b.oldItems != null) {
                for (let c of fromEn(b.oldItems)) {
                    c.propertyChanged = delegateRemove(c.propertyChanged, runOn(this, this.ff));
                }
            }
            if (b.newItems != null) {
                for (let d of fromEn(b.newItems)) {
                    d.propertyChanged = delegateCombine(d.propertyChanged, runOn(this, this.ff));
                }
            }
            this.a3 = true;
            this.view.bo();
        }
        ff(a, b) {
            this.a3 = true;
            this.view.bo();
        }
        refresh() {
            this.a3 = true;
            this.view.bo();
        }
        aw() {
            return FontUtil.toFontInfo(this.view.ag, this.c7);
        }
    }
    XamBulletGraph.$t = /*@__PURE__*/ markType(XamBulletGraph, 'XamBulletGraph', Control.$, [INotifyPropertyChanged_$type]);
    XamBulletGraph.gl = /*@__PURE__*/ DependencyProperty.i("ScaleBackgroundBrush", Brush.$, XamBulletGraph.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => a.e5("ScaleBackgroundBrush", b.oldValue, b.newValue)));
    XamBulletGraph.gm = /*@__PURE__*/ DependencyProperty.i("ScaleBackgroundOutline", Brush.$, XamBulletGraph.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => a.e5("ScaleBackgroundOutline", b.oldValue, b.newValue)));
    XamBulletGraph.gn = /*@__PURE__*/ DependencyProperty.i("ScaleBackgroundThickness", Number_$type, XamBulletGraph.$, /*@__PURE__*/ new PropertyMetadata(2, 1, (a, b) => a.e5("ScaleBackgroundThickness", b.oldValue, b.newValue)));
    XamBulletGraph.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, XamBulletGraph, 'e5', ['BackingBrush:he:fs', [Brush.$, null], 'BackingInnerExtent:bn:ft', [1, 0], 'BackingOuterExtent:bo:fu', [1, 1], 'BackingOutline:hf:fv', [Brush.$, null], 'BackingStrokeThickness:bp:fw', [1, 2], 'FontBrush:hg:fx', [Brush.$, null], 'Font:c7:fy', [2, null], 'Interval:bs:fz', [1, NaN], 'IsScaleInverted:a4:f0', [0, false], 'LabelExtent:bt:f1', [1, 0], 'LabelFormat:dd:f2', [2, null], 'LabelFormatSpecifiers:ag:f3', [Array_$type, null], 'LabelInterval:bu:f4', [1, NaN], 'LabelsPostInitial:bv:f5', [1, 0], 'LabelsPreTerminal:bw:f6', [1, 0], 'MaximumValue:bx:f7', [1, 100], 'MergeViewPorts:a6:f8', [0, false], 'MinimumValue:by:f9', [1, 0], 'MinorTickBrush:hi:ga', [Brush.$, null], 'MinorTickCount:bz:gb', [1, 3], 'MinorTickEndExtent:b0:gc', [1, 0.2], 'MinorTickStartExtent:b2:gd', [1, 0.1], 'MinorTickStrokeThickness:b4:ge', [1, 1], 'Orientation:ar:gf', [LinearScaleOrientation_$type, /*@__PURE__*/ enumGetBox(LinearScaleOrientation_$type, 0)], 'RangeBrushes:ah:gg', [BrushCollection.$, null], 'RangeInnerExtent:b6:gh', [1, 0.2], 'RangeOuterExtent:b7:gi', [1, 0.95], 'RangeOutlines:ai:gj', [BrushCollection.$, null], 'Ranges::gk', [LinearGraphRangeCollection.$, null], 'ScaleEndExtent:ca:go', [1, 0.95], 'ScaleStartExtent:cd:gp', [1, 0.05], 'ShowToolTipTimeout:cx:gq', [1, 500], 'TargetValueBreadth:cf:gr', [1, 3], 'TargetValueBrush:hl:gs', [Brush.$, null], 'TargetValueInnerExtent:cg:gt', [1, 0.3], 'TargetValueName:d8:gu', [2, null], 'TargetValueOuterExtent:ch:gv', [1, 0.85], 'TargetValueOutline:hm:gw', [Brush.$, null], 'TargetValue:ce:gx', [1, NaN], 'TargetValueStrokeThickness:ci:gy', [1, 1], 'TickBrush:hn:gz', [Brush.$, null], 'TickEndExtent:cj:g0', [1, 0.2], 'TicksPostInitial:cl:g1', [1, 0], 'TicksPreTerminal:cm:g2', [1, 0], 'TickStartExtent:cn:g3', [1, 0.06], 'TickStrokeThickness:cp:g4', [1, 2], 'ToolTip::g5', [4, null], 'TransitionDuration:cy:g6', [1, 0], 'ValueBrush:ho:g7', [Brush.$, null], 'ValueInnerExtent:cs:g8', [1, 0.5], 'ValueName:ep:g9', [2, null], 'ValueOuterExtent:ct:ha', [1, 0.65], 'ValueOutline:hp:hb', [Brush.$, null], 'Value:cr:hc', [1, NaN], 'ValueStrokeThickness:cu:hd', [1, 1]]);
    return XamBulletGraph;
})();
/**
 * @hidden
 */
let XamBulletGraphView = /*@__PURE__*/ (() => {
    class XamBulletGraphView extends Base {
        constructor(a) {
            super();
            this.ao = 0;
            this.an = 0;
            this.ap = 0;
            this.m = null;
            this.i = null;
            this.ai = null;
            this.p = null;
            this.ag = null;
            this.aa = null;
            this.z = null;
            this.y = null;
            this.ab = null;
            this.cj = null;
            this.ci = null;
            this.ch = null;
            this.cf = null;
            this.cg = null;
            this.b7 = null;
            this.b8 = null;
            this.b4 = null;
            this.b5 = null;
            this.b9 = null;
            this.ca = null;
            this.b6 = null;
            this.c = null;
            this.d = null;
            this.e = null;
            this.f = null;
            this.cb = null;
            this.cc = null;
            this.q = false;
            this.v = null;
            this.a = ["value", "targetvalue", "backing", "scale", "tick", "minortick", "label"];
            this.u = false;
            this.t = false;
            this.ah = null;
            this.k = null;
            this.aj = 0;
            this.al = 0;
            this.aq = null;
            this.am = -1;
            this.cd = null;
            this.ak = 0;
            this.x = null;
            this.b3 = ((() => {
                let $ret = new Brush();
                $ret.fill = "black";
                return $ret;
            })());
            this.r = false;
            this.n = null;
            this.b2 = null;
            this.ac = 0;
            this.m = a;
            this.v = new Dictionary$2(String_$type, Dictionary$2.$.specialize(String_$type, Brush.$), 0);
            this.ci = new Path();
            this.cj = new Path();
            this.ch = new Path();
            this.cf = new Path();
            this.cg = new Path();
            this.aa = new List$1(Path.$, 0);
            this.z = new List$1(Path.$, 0);
            this.y = new List$1(TextBlock.$, 0);
            this.ab = new List$1(TextBlock.$, 0);
        }
        a4() {
            this.a0();
            if (this.i != null) {
                this.i.ap(this.ag.rootWrapper, "");
            }
        }
        a8() {
            if (this.i != null) {
                this.i.bb(this.ag.rootWrapper, "");
            }
        }
        a9() {
            this.k = new LinearGraphTooltipDataContext();
            this.ak = this.m.cx;
            this.a0();
        }
        a0() {
            let a = this.m.b5;
            let b = this.m.bm;
            if (!isNaN_(a) && a != 0) {
                return;
            }
            if (window.devicePixelRatio != undefined && window.devicePixelRatio != b) {
                this.m.bm = window.devicePixelRatio;
            }
        }
        s() {
            return true;
        }
        cn() {
            return this.ci;
        }
        co() {
            return this.cj;
        }
        cm() {
            return this.ch;
        }
        ck() {
            return this.cf;
        }
        cl() {
            return this.cg;
        }
        ay() {
            this.q = true;
            let a = ["#778899", "black", "#EBEDEF", "#617583", "#617583", "rgba(100,107,114,.74)", "rgba(100,107,114,.74)"];
            let b = ["#778899", "black", "#B2B9C0", "#B2B9C0", null, null, null];
            let c = ((() => {
                let $ret = new List$1(Array_$type, 0);
                $ret.add(a);
                $ret.add(b);
                return $ret;
            })());
            this.v.clear();
            let d = this.a.length;
            for (let e = 0; e < d; e++) {
                let f = this.a[e];
                let g = "ui-bulletgraph-" + f;
                let h = "ui-bulletgraph-" + f + "-fill";
                let i = "ui-bulletgraph-" + f + "-outline";
                let j;
                if (!((() => { let k = XamBulletGraphView.w.tryGetValue(h, j); j = k.p1; return k.ret; })())) {
                    j = BrushUtil.j(h, g, "background-color", this.ag, a[e]);
                    XamBulletGraphView.w.addItem(h, j);
                }
                let k;
                if (!((() => { let l = XamBulletGraphView.w.tryGetValue(i, k); k = l.p1; return l.ret; })())) {
                    k = BrushUtil.j(i, g, "border-top-color", this.ag, b[e]);
                    XamBulletGraphView.w.addItem(i, k);
                }
                let l = new Dictionary$2(String_$type, Brush.$, 0);
                l.item("fill", j);
                l.item("outline", k);
                this.v.item(this.a[e], l);
            }
            this.bx();
            if (XamBulletGraphView.g == null || XamBulletGraphView.h == null) {
                let m = BrushUtil.f("ui-bulletgraph-range-fill-palette-", "ui-bulletgraph-range-outline-palette-", "ui-bulletgraph-range-palette-", this.ag, XamBulletGraphView.g, XamBulletGraphView.h, ["#216E99", "#216E99", "#44acd6", "#44acd6", "#cecece", "#cecece"]);
                XamBulletGraphView.g = m.p4;
                XamBulletGraphView.h = m.p5;
            }
            this.c = XamBulletGraphView.g;
            this.d = XamBulletGraphView.h;
            if (this.e == null) {
                this.m.ah = this.c;
            }
            if (this.f == null) {
                this.m.ai = this.d;
            }
            this.q = false;
        }
        bx() {
            this.q = true;
            let a = this.a.length;
            for (let b = 0; b < a; b++) {
                let c = this.a[b];
                this.bw(c, this.v.item(c));
            }
            this.q = false;
        }
        bw(a, b) {
            let c = b.item("fill");
            let d = b.item("outline");
            switch (a) {
                case "targetvalue":
                    if (this.b7 == null) {
                        this.m.hl = c;
                    }
                    if (this.b8 == null) {
                        this.m.hm = d;
                    }
                    break;
                case "value":
                    if (this.cb == null) {
                        this.m.ho = c;
                    }
                    if (this.cc == null) {
                        this.m.hp = d;
                    }
                    break;
                case "backing":
                    if (this.b4 == null) {
                        this.m.he = c;
                    }
                    if (this.b5 == null) {
                        this.m.hf = d;
                    }
                    break;
                case "tick":
                    if (this.ca == null) {
                        this.m.hn = c;
                    }
                    break;
                case "minortick":
                    if (this.b6 == null) {
                        this.m.hi = c;
                    }
                    break;
                case "label":
                    this.b3 = c;
                    break;
            }
        }
        a5(a, b, c) {
            let d = b;
            let e = c;
            if (!this.q) {
                switch (a) {
                    case XamBulletGraph.$$p[33]:
                        this.b7 = e;
                        break;
                    case XamBulletGraph.$$p[37]:
                        this.b8 = e;
                        break;
                    case XamBulletGraph.$$p[0]:
                        this.b4 = e;
                        break;
                    case XamBulletGraph.$$p[3]:
                        this.b5 = e;
                        break;
                    case XamBulletGraph.$$p[48]:
                        this.cb = e;
                        break;
                    case XamBulletGraph.$$p[52]:
                        this.cc = e;
                        break;
                    case XamBulletGraph.$$p[40]:
                        this.ca = e;
                        break;
                    case XamBulletGraph.$$p[18]:
                        this.b6 = e;
                        break;
                }
                if (e == null) {
                    this.bx();
                }
            }
        }
        ba(a, b) {
            if (!this.q) {
                this.e = b;
                if (this.e == null) {
                    this.m.ah = this.c;
                }
            }
        }
        bb(a, b) {
            if (!this.q) {
                this.f = b;
                if (this.f == null) {
                    this.m.ai = this.d;
                }
            }
        }
        b(a, b) {
            this.ag.startCSSQuery();
            for (let c = 0; c < b.length; c++) {
                b[c] = this.ag.getCssDefaultPropertyValue(a, b[c]);
            }
            this.ag.endCSSQuery();
            return b;
        }
        bs() {
            this.ay();
            this.by();
            this.bo();
        }
        ce(a) {
            let b = CanvasGestureDOMEventProxy.cy(this.ag.rootWrapper);
            return { $type: Point_$type, x: a.x - b.left, y: a.y - b.top };
        }
        br(a, b, c, d) {
            this.cd = a;
            this.am = c;
            this.aq = d;
            this.bn();
            this.al = window.setTimeout(runOn(this, this.bz), this.ak);
            this.t = true;
        }
        az() {
            if (this.t) {
                window.clearTimeout(this.al);
                this.t = false;
            }
            if (this.u) {
                let a = this.m.toolTip;
                window.clearTimeout(this.aj);
                a.hide();
                this.u = false;
                this.k = null;
            }
            this.ak = this.m.cx;
        }
        bn() {
            if (this.t) {
                window.clearTimeout(this.al);
            }
            if (this.u) {
                let a = this.m.toolTip;
                window.clearTimeout(this.aj);
                a.hide();
                this.u = false;
                this.ak = intDivide(this.m.cx, 2);
            }
        }
        bz() {
            if (this.t) {
                window.clearTimeout(this.al);
                this.t = false;
            }
            let a = this.am;
            let b = this.aq;
            let c = this.cd;
            if (this.ag != null) {
                this.aj = this.ag.setTimeout(runOn(this, this.az), 10 * this.m.cx);
            }
            else {
                this.aj = window.setTimeout(runOn(this, this.az), 10 * this.m.cx);
            }
            let d = this.m.ranges._inner[a];
            if (this.ah != this.m.toolTip) {
                if (this.ah != null) {
                    this.ah.remove();
                }
                this.ah = this.m.toolTip;
                this.ah.setStyleProperty("z-index", "10000");
                this.ah.setStyleProperty("position", "absolute");
                this.ag.append(this.ah);
            }
            this.k = this.j(b, a);
            let context_ = this.k;
            let tooltip_ = this.ah;
            let tooltipType_ = b;
            if (tooltip_.updateToolTip) {
                tooltip_.updateToolTip(context_, tooltipType_);
            }
            ;
            let e = this.ah.findByClass(".ui-tooltip-container");
            if (e != null && e.length > 0) {
                e[0].setAttribute("style", null);
            }
            let f = "ui-simple-default-tooltip-content";
            let g = this.ah.findByClass("." + f);
            if (g != null && g.length > 0) {
                let h = ["border-top-color", "border-top-width", "border-top-style", "border-top-left-radius", "background-color", "padding-top", "font-weight"];
                let i = ["border-color", "border-width", "border-style", "border-radius", "background-color", "padding", "font-weight"];
                let j = ((() => {
                    let $ret = new List$1(String_$type, 0);
                    $ret.add(this.k.brush.color.colorString);
                    $ret.add("2px");
                    $ret.add("solid");
                    $ret.add("4px");
                    $ret.add("rgba(230, 230, 230, 0.74)");
                    $ret.add("4px");
                    $ret.add("bold");
                    return $ret;
                })());
                let k = new Dictionary$2(String_$type, String_$type, 0);
                let l = new Array(h.length);
                arrayCopy1(h, 0, l, 0, h.length);
                this.b(f, l);
                for (let m = 0; m < l.length; m++) {
                    this.ah.setStyleProperty(i[m], (l[m] == null) ? j._inner[m] : l[m]);
                }
            }
            this.ah.setStyleProperty("top", (c.y + 15).toString() + "px").setStyleProperty("left", (c.x + 15).toString() + "px");
            this.ah.show();
            this.u = true;
        }
        j(a, b) {
            let c = new LinearGraphTooltipDataContext();
            switch (a) {
                case "range":
                    let d = this.m.ranges._inner[b];
                    c.item = d;
                    c.itemName = d.u;
                    c.label = d.u + ": " + d.o.toString() + "-" + d.j.toString();
                    let e = d.an;
                    let f = d.ao;
                    c.brush = e != null ? e : this.m.hh(b, this.c);
                    c.outline = f != null ? f : this.m.hh(b, this.d);
                    c.thickness = d.p;
                    break;
                case "value":
                    c.item = this.m.cr;
                    c.itemName = this.m.ep;
                    c.label = this.m.ep != null ? this.m.ep + ": " + this.m.cr.toString() : this.m.cr.toString();
                    c.brush = this.m.ho;
                    c.outline = this.m.hp;
                    c.thickness = this.m.cu;
                    break;
                case "targetvalue":
                    c.item = this.m.ce;
                    c.itemName = this.m.d8;
                    c.label = this.m.d8 != null ? this.m.d8 + ": " + this.m.ce.toString() : this.m.ce.toString();
                    c.brush = this.m.hl;
                    c.outline = this.m.hm;
                    c.thickness = this.m.ci;
                    break;
            }
            return c;
        }
        a6(a) {
            if (a == null) {
                this.ai = null;
                this.ag = null;
                this.ah = null;
                this.p = null;
                this.at();
                return;
            }
            let b = a;
            this.ag = b;
            this.m.av.u(this.ag);
            this.ag.rootWrapper.addClass("ui-bulletgraph-container");
            this.ap = (isNaN_(this.m.b5) ? this.m.bm : this.m.b5);
            let c = this.ap;
            let d = Math.round(b.rootWrapper.width());
            let e = Math.round(b.rootWrapper.height());
            let f = d * c;
            let g = e * c;
            this.ag.rootWrapper.setStyleProperty("position", "relative");
            let h = this.ag.createElement("canvas");
            h.setStyleProperty("position", "absolute");
            this.ag.append(h);
            this.ao = f;
            this.an = g;
            h.setAttribute("width", f.toString());
            h.setAttribute("height", g.toString());
            h.setStyleProperty("width", d.toString());
            h.setStyleProperty("height", e.toString());
            this.m.hw = new Rect(0, 0, 0, d, e);
            this.m.hu = new Rect(0, 0, 0, d, e);
            this.ai = h;
            let i = this.ag.get2DCanvasContext(this.ai);
            this.p = new RenderingContext(new CanvasViewRenderer(), i);
            this.ay();
            this.by();
            this.p.ac(this.n);
            this.at();
            if (TypeRegistrar.isRegistered("CanvasGestureDOMEventProxy")) {
                this.i = typeCast(EventProxy.$, TypeRegistrar.create("CanvasGestureDOMEventProxy", this.ag.rootWrapper, this.ag, false));
            }
            if (this.i != null) {
                let j = this.i;
                j.onMouseOver = delegateCombine(j.onMouseOver, runOn(this, this.av));
                let k = this.i;
                k.onMouseLeave = delegateCombine(k.onMouseLeave, runOn(this, this.au));
            }
            this.bm();
        }
        at() {
            if (this.i != null) {
                let a = this.i;
                a.onMouseOver = delegateRemove(a.onMouseOver, runOn(this, this.av));
                let b = this.i;
                b.onMouseLeave = delegateRemove(b.onMouseLeave, runOn(this, this.au));
                this.i.aq();
            }
        }
        av(a, b, c) {
            if (this.m != null) {
                this.m.onMouseOver(a, b, c);
            }
        }
        au(a) {
            if (this.m != null) {
                this.m.onMouseLeave();
            }
        }
        a7() {
            this.a0();
            let a = Math.round(this.ag.rootWrapper.width());
            let b = Math.round(this.ag.rootWrapper.height());
            this.m.hw = new Rect(0, 0, 0, a, b);
            this.m.hu = new Rect(0, 0, 0, a, b);
            if (this.i != null) {
                this.i.bf = this.m.hw;
            }
        }
        as() {
            this.bm();
        }
        bp(a) {
            this.x = a;
        }
        bm() {
            let a = this.m.hw.width;
            let b = this.m.hw.height;
            let c = a * this.ap;
            let d = b * this.ap;
            if (this.ao != c || this.an != d) {
                this.ai.setAttribute("width", c.toString());
                this.ai.setAttribute("height", d.toString());
                this.ai.setStyleProperty("width", a.toString() + "px");
                this.ai.setStyleProperty("height", b.toString() + "px");
                this.ao = truncate(Math.round(c));
                this.an = truncate(Math.round(d));
            }
            if (this.p.d && this.ap != 1) {
                this.p.z();
                this.p.aa(this.ap, this.ap);
            }
            this.p.k(this.m.hw.left, this.m.hw.top, this.m.hw.width, this.m.hw.height);
            this.p.s(this.cf);
            this.p.s(this.cg);
            if (this.x != null) {
                for (let e = 0; e < this.x.count; e++) {
                    this.p.s(this.x._inner[e]);
                }
            }
            for (let f = 0; f < this.y.count; f++) {
                this.p.ac(this.n);
                this.p.w(this.y._inner[f]);
            }
            for (let g = 0; g < this.z.count; g++) {
                this.p.s(this.z._inner[g]);
            }
            this.p.s(this.cj);
            this.p.s(this.ci);
            if (this.p.d && this.ap != 1) {
                this.p.y();
            }
        }
        by() {
            if (this.m.c7 != null) {
                this.n = this.m.aw();
            }
            else {
                this.n = FontUtil.getFont(this.ag);
            }
            this.ac = this.ad(this.n);
            if (this.m.hg == null) {
                let a = this.ag.rootWrapper.getStyleProperty("color");
                if (stringIsNullOrEmpty(a) == false) {
                    this.b2 = new Brush();
                    this.b2._fill = a;
                    this.m.hg = this.b2;
                }
            }
            if (this.p != null) {
                this.p.ac(this.n);
            }
        }
        ae(a) {
            let b = typeCast(TextBlock.$, a);
            if (b != null && b.ak != null) {
                return this.p.e(b) + 0;
            }
            return 0;
        }
        cr(a) {
            if (isNaN_(this.ac)) {
                this.ac = this.ad(null);
            }
            let b = this.ae(a);
            let c = this.ac;
            return new Size(1, b, c);
        }
        bq(a, b) {
            if (b != null) {
                a.am = b;
            }
            else {
                a.am = this.b3;
            }
        }
        bh(a, b, c) {
            a.n = b;
            a.o = c;
        }
        bg(a, b) {
        }
        bi(a, b) {
        }
        ad(a) {
            return FontUtil.getCurrentFontHeight(this.ag, a);
        }
        bo() {
            if (!this.r) {
                this.r = true;
                if (this.ag != null) {
                    this.ag.setTimeout(runOn(this, this.ar), 0);
                }
                else {
                    window.setTimeout(runOn(this, this.ar), 0);
                }
            }
        }
        ar() {
            if (this.r) {
                this.r = false;
                this.m.ew();
            }
        }
        flush() {
            if (this.r) {
                this.ar();
            }
        }
        o(a, b) {
            return FontUtil.getFontInfo(this.ag, a, b);
        }
        aw(a) {
            a.scalePath = new PathVisualData(1, "Scale", this.ch);
            a.targetValuePath = new PathVisualData(1, "TargetValue", this.ci);
            a.valuePath = new PathVisualData(1, "Value", this.cj);
            a.backingPath = new PathVisualData(1, "Backing", this.cf);
            a.scaleBackgroundPath = new PathVisualData(1, "ScaleBackground", this.cg);
            let b = this.n;
            for (let c of fromEnum(this.y)) {
                if (c._visibility == 0) {
                    let d = this.o(c, b);
                    let e = new LinearGraphScaleLabelVisualData();
                    e.labelValue = c.ak;
                    e.labelPosition = PointData.b({ $type: Point_$type, x: c.n, y: c.o });
                    e.labelSize = SizeData.b(this.cr(c));
                    e.appearance = AppearanceHelper.c(c, d);
                    a.scaleLabels.add(e);
                }
            }
            for (let f of fromEnum(this.z)) {
                if (f._visibility == 0) {
                    let g = new LinearGraphScaleTickmarkVisualData();
                    g.tickPath = new PathVisualData(1, "tickmarks", f);
                    a.scaleTickmarks.add(g);
                }
            }
            for (let h of fromEnum(this.x)) {
                if (h._visibility == 0) {
                    let i = new LinearGraphRangeVisualData();
                    let j = new PathVisualData(1, "range", h);
                    i.rangePath = j;
                    a.ranges.add(i);
                }
            }
        }
        bj(a) {
            a._visibility = 0;
        }
        bk(a) {
            a._visibility = 1;
        }
        bl(a) {
            this.aa.remove(a);
        }
        cq() {
            let a = new Path();
            this.aa.add(a);
            return a;
        }
        bt(a) {
            a._visibility = 0;
        }
        bu(a) {
            a._visibility = 1;
        }
        bv(a) {
            this.ab.remove(a);
        }
        b1() {
            let a = new TextBlock();
            this.ab.add(a);
            return a;
        }
        bc(a) {
            a._visibility = 0;
        }
        bd(a) {
            a._visibility = 1;
        }
        be(a) {
            this.z.remove(a);
        }
        cp() {
            let a = new Path();
            this.z.add(a);
            return a;
        }
        a1(a) {
            a._visibility = 0;
        }
        a2(a) {
            a._visibility = 1;
        }
        a3(a) {
            this.y.remove(a);
        }
        b0() {
            let a = new TextBlock();
            this.y.add(a);
            return a;
        }
        l() {
            if (this.k == null) {
                return null;
            }
            return ((() => {
                let $ret = new ToolTipInfo();
                $ret.b = this.am;
                $ret.d = this.cd;
                $ret.c = this.aq;
                $ret.a = this.k;
                return $ret;
            })());
        }
        bf() {
            this.ap = this.m.bm;
        }
    }
    XamBulletGraphView.$t = /*@__PURE__*/ markType(XamBulletGraphView, 'XamBulletGraphView');
    XamBulletGraphView.w = /*@__PURE__*/ new Dictionary$2(String_$type, Brush.$, 0);
    XamBulletGraphView.g = null;
    XamBulletGraphView.h = null;
    return XamBulletGraphView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

let defaultFont = "Verdana, Arial, \"Segoe UI\", \"Myriad Pro\", sans-serif";
let BulletGraphStylingDefaults = /*@__PURE__*/ (function () {
    let BulletGraphStylingDefaults = {
        //"ui-bulletgraph-backing": {
        //    "background-color": "#ffffff",
        //    "border-color": "#ffffff"
        //},
        "ui-bulletgraph-targetvalue": {
            "background-color": "#333333",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-tick": {
            "background-color": "rgba(0, 0, 0, 0.35)",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-minortick": {
            "background-color": "rgba(0, 0, 0, 0.2)",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-label": {
            "background-color": "#666666",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-1": {
            "background-color": "#0078C8",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-2": {
            "background-color": "#0099FF",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-3": {
            "background-color": "#21A7FF",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-4": {
            "background-color": "#4FB9FF",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-range-palette-5": {
            "background-color": "#79C9FF",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph-value": {
            "background-color": "#333",
            "border-top-color": "transparent"
        },
        "ui-bulletgraph": {
            "font-family": defaultFont,
            "font-size": "11px",
            "color": "#494949"
        },
        "font-family": defaultFont,
        "font-style": "normal",
        "font-weight": "normal",
        "font-size": "11px",
        "color": "#666666",
        "font-variant": "",
        "line-height": ""
    };
    return BulletGraphStylingDefaults;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents event argument for FormatLinearGraphLabel.
*/
class IgrFormatLinearGraphLabelEventArgs {
    createImplementation() {
        return new FormatLinearGraphLabelEventArgs();
    }
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    get actualMinimumValue() {
        return this.i.actualMinimumValue;
    }
    get actualMaximumValue() {
        return this.i.actualMaximumValue;
    }
    get value() {
        return this.i.value;
    }
    get label() {
        return this.i.label;
    }
    set label(value) {
        this.i.label = value;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents event argument for AlignLinearGraphLabel.
*/
class IgrAlignLinearGraphLabelEventArgs extends IgrFormatLinearGraphLabelEventArgs {
    createImplementation() {
        return new AlignLinearGraphLabelEventArgs();
    }
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    get width() {
        return this.i.width;
    }
    set width(value) {
        this.i.width = value;
    }
    get height() {
        return this.i.height;
    }
    set height(value) {
        this.i.height = value;
    }
    get offsetX() {
        return this.i.offsetX;
    }
    set offsetX(value) {
        this.i.offsetX = value;
    }
    get offsetY() {
        return this.i.offsetY;
    }
    set offsetY(value) {
        this.i.offsetY = value;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrLinearGraphRange extends Component {
    constructor(props) {
        super(props);
        this._renderer = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    render() {
        return null;
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                {
                    this[p] = this.props[p];
                }
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    get rangeInternal() {
        return this.i;
    }
    createImplementation() {
        return new XamLinearGraphRange();
    }
    ngOnInit() {
    }
    _provideRenderer(renderer) {
        this._renderer = renderer;
    }
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets or sets the name of the range.
*/
    get name() {
        return this.i.u;
    }
    set name(v) {
        this.i.u = v;
    }
    /**
     * Gets or sets the brush to use to fill the range.
    */
    get brush() {
        return brushToString(this.i.an);
    }
    set brush(v) {
        this.i.an = stringToBrush(v);
    }
    /**
     * Gets or sets the outline to use when rendering the range.
    */
    get outline() {
        return brushToString(this.i.ao);
    }
    set outline(v) {
        this.i.ao = stringToBrush(v);
    }
    /**
     * Gets or sets the value at which the range starts along the scale.
    */
    get startValue() {
        return this.i.o;
    }
    set startValue(v) {
        this.i.o = +v;
    }
    /**
     * Gets or sets the value at which the range ends along the scale.
    */
    get endValue() {
        return this.i.j;
    }
    set endValue(v) {
        this.i.j = +v;
    }
    /**
     * Gets or sets the distance measured from the front/bottom of the bullet graph (from 0 to 1) at which to start rendering the inner edge of the range.
     * Values further from zero than 1 can be used to make this extend further than the normal width/height of the bullet graph.
    */
    get innerStartExtent() {
        return this.i.l;
    }
    set innerStartExtent(v) {
        this.i.l = +v;
    }
    /**
     * Gets or sets the distance measured from the front/bottom of the bullet graph (from 0 to 1) at which to end rendering the inner edge of the range.
     * Values further from zero than 1 can be used to make this extend further than the normal width/height of the bullet graph.
    */
    get innerEndExtent() {
        return this.i.k;
    }
    set innerEndExtent(v) {
        this.i.k = +v;
    }
    /**
     * Gets or sets the distance measured from the front/bottom of the bullet graph (from 0 to 1) at which to start rendering the outer edge of the range.
     * Values further from zero than 1 can be used to make this extend further than the normal width/height of the bullet graph.
    */
    get outerStartExtent() {
        return this.i.n;
    }
    set outerStartExtent(v) {
        this.i.n = +v;
    }
    /**
     * Gets or sets the distance measured from the front/bottom of the bullet graph (from 0 to 1) at which to end rendering the outer edge of the range.
     * Values further from zero than 1 can be used to make this extend further than the normal width/height of the bullet graph.
    */
    get outerEndExtent() {
        return this.i.m;
    }
    set outerEndExtent(v) {
        this.i.m = +v;
    }
    /**
     * Gets or sets the stroke thickness to use when rendering this range's outline.
    */
    get strokeThickness() {
        return this.i.p;
    }
    set strokeThickness(v) {
        this.i.p = +v;
    }
    findByName(name) {
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("LinearGraphRange");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
}

class IgrLinearGraphRangeCollection extends IgCollection {
    constructor(list) {
        super();
        if (!IgrLinearGraphRange.$type) {
            IgrLinearGraphRange.$type = markType(IgrLinearGraphRange, "IgrLinearGraphRange");
        }
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        if (!IgrLinearGraphRange.$type) {
            IgrLinearGraphRange.$type = markType(IgrLinearGraphRange, "IgrLinearGraphRange");
        }
        let coll = new SyncableObservableCollection$2(IgrLinearGraphRange.$type, XamLinearGraphRange.$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext._implementation;
        };
        coll.createFrom = (int) => {
            let ext = int.externalObject;
            if (!ext) {
                ext = IgrLinearGraphRange._createFromInternal(int);
                if (ext) {
                    ext._implementation = int;
                }
            }
            return ext;
        };
        return coll;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents a bullet graph.
*/
class IgrBulletGraph extends Component {
    constructor(props) {
        super(props);
        this.contentRanges = [];
        /**
        * The ranges actually present in the chart. Do not directly modify this array.
        * This array's contents can be modified by causing Angular to reproject the child content.
        * Or adding and removing ranges from the manual ranges collection on the ranges property.
        */
        this.actualRanges = [];
        this._ranges = null;
        this._rangesAdapter = null;
        this._tooltipTemplate = null;
        this._tooltipContent = null;
        this._defaultTooltips = null;
        this._uniqueTooltipId = 0;
        this._initialized = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._formatLabel = null;
        this._formatLabel_wrapped = null;
        this._alignLabel = null;
        this._alignLabel_wrapped = null;
        this._actualMinimumValueChange = null;
        this._actualMinimumValueChange_wrapped = null;
        this._actualMaximumValueChange = null;
        this._actualMaximumValueChange_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        this._tooltipRef = this._tooltipRef.bind(this);
        this._activeTooltipElements = new Map();
        this._activeTooltips = new Map();
        this._currentTooltips = [];
        this._contentChildrenManager = new ContentChildrenManager((ch) => ch.key || ch.props.name, (ch) => ch.key || ch.props.name, () => this._updateContentChildren());
        let container = null;
        if (document) {
            container = document.createElement("div");
            container.style.display = "block";
            container.style.width = "100%";
            container.style.height = "100%";
        }
        var root;
        root = container;
        this._renderer = new ReactRenderer(root, document, true, BulletGraphStylingDefaults);
        this._container = this._renderer.getWrapper(container);
        this._implementation = this.createImplementation();
        //this._container = this._renderer.createElement("div");
        //this._renderer.rootWrapper.append(this._container);
        //this._container.setStyleProperty("display", "block");
        //this._container.setStyleProperty("width", "100%");
        //this._container.setStyleProperty("height", "100%");
        this._wrapper = this._renderer;
        //var root: any;
        //root = this._container;
        //if (this._container.nativeElement != null) {
        //    root = this._container.nativeElement;
        //}
        var gauge = this.i;
        this._gauge = gauge;
        this._rangesAdapter = new CollectionAdapter(this.contentRanges, this.i.ranges, this.actualRanges, (c) => c.i, (i) => {
            i._provideRenderer(this._wrapper);
            if (this._container && this._container.getNativeElement().parentElement) {
                i._styling(this._container.getNativeElement(), this, this);
            }
        }, (i) => { i._provideRenderer(null); });
        gauge.provideContainer(this._renderer);
        this._renderer.addSizeWatcher(() => {
            this._gauge.containerResized();
        });
        this._initialized = true;
    }
    set height(value) {
        this._height = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this.containerResized();
        }
    }
    get height() {
        return this._height;
    }
    set width(value) {
        this._width = value;
        if (this._elRef) {
            this._elRef.style.width = value;
            this.containerResized();
        }
    }
    get width() {
        return this._width;
    }
    _updateContentChildren() {
        this.contentRanges.length = 0;
        let contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (let i = 0; i < contentChildrenActual.length; i++) {
            if ((XamLinearGraphRange.$type).isAssignableFrom(contentChildrenActual[i].i.$type)) {
                this.contentRanges.push(contentChildrenActual[i]);
            }
        }
        if (this._rangesAdapter !== null) {
            this._rangesAdapter.notifyContentChanged();
        }
    }
    /**
     * A collection or manually added axes for the chart.
    */
    get ranges() {
        if (this._ranges === null) {
            let coll = new IgrLinearGraphRangeCollection();
            let inner = coll._innerColl;
            inner.addListener((sender, e) => {
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._rangesAdapter.clearManualItems();
                        break;
                }
            });
            this._ranges = coll;
        }
        return this._ranges;
    }
    _tooltipRef(t) {
        //console.log(t);
        if (t === null) {
            return;
        }
        if (t.currentOwner &&
            t.currentOwner.tooltipTemplate) {
            t.template = t.currentOwner.tooltipTemplate;
        }
        this._activeTooltips.set(t.currentOwner, t);
    }
    render() {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        let children = this._contentChildrenManager.getChildren(this.props.children);
        if (this._currentTooltips && this._currentTooltips.length > 0) {
            for (let i = 0; i < this._currentTooltips.length; i++) {
                let t = this._currentTooltips[i];
                if (this._activeTooltipElements.has(t)) {
                    children.push(this._activeTooltipElements.get(t));
                }
                else {
                    if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
                        continue;
                    }
                    let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
                    let tEle = createElement(Tooltip, {
                        ref: this._tooltipRef,
                        key: this._currentTooltips[i].key,
                        owner: this._currentTooltips[i]
                    });
                    let portal = createPortal(tEle, t, this._currentTooltips[i].key);
                    this._activeTooltipElements.set(t, portal);
                    children.push(portal);
                }
            }
        }
        let div = createElement("div", {
            className: "ig-bullet-graph igr-bullet-graph",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                {
                    this[p] = this.props[p];
                }
            }
        }
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container.getNativeElement());
        this.containerResized();
        this.initializeContent();
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    _getMainRef(div) {
        this._elRef = div;
    }
    destroy() {
        this._wrapper.rootWrapper.unlistenAll();
        this._gauge.destroy();
        this._wrapper.destroy();
    }
    createImplementation() {
        return new XamBulletGraph();
    }
    initializeContent() {
        this._styling(this._container.getNativeElement(), this);
        if (this.actualRanges && this.actualRanges.length > 0) {
            var currRange = this.actualRanges;
            for (var i = 0; i < currRange.length; i++) {
                currRange[i]._styling(this._container.getNativeElement(), this, this);
            }
        }
        this._updateContentChildren();
        this.i.containerResized();
    }
    componentWillUnmount() {
        //this._grid.destroy();
        this.destroy();
    }
    set tooltipTemplate(value) {
        this._tooltipTemplate = value;
        if (value == null) {
            if (this._tooltipContent !== null) {
                this._tooltipContent.destroy();
                this._tooltipContent = null;
            }
        }
        if (this._tooltipContent != null) {
            this._tooltipContent.instance.template = this._tooltipTemplate;
        }
        else {
            this._ensureTooltipCreated();
        }
    }
    get tooltipTemplate() {
        return this._tooltipTemplate;
    }
    createWrapper(ele) {
        let wrapper = new ReactWrapper(ele, this._renderer);
        wrapper.updateToolTip = ele.updateToolTip;
        wrapper.hideToolTip = ele.hideToolTip;
        return wrapper;
    }
    _ensureDefaultTooltip() {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips["ensureDefaultTooltip"](this);
    }
    _onDefaultTooltipsReady(cr) {
        this._ensureDefaultTooltip();
    }
    createTooltip() {
        // if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
        // 	return null;
        // }
        // let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
        let wrapper = this._wrapper.createElement("div");
        let ele = wrapper.getNativeElement();
        ele.key = "__tooltip_" + this._uniqueTooltipId;
        this._uniqueTooltipId++;
        this._currentTooltips = this._currentTooltips.slice(0);
        this._currentTooltips.push(ele);
        //let element = React.createElement(Tooltip,  );
        //let portal = ReactDOM.createPortal(element, ele);
        let self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                let ext = new IgrDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container.getNativeElement()) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.getNativeElement().appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            if (self._activeTooltips.has(ele)) {
                let t = self._activeTooltips.get(ele);
                if (t.template === null &&
                    ele.tooltipTemplate !== null) {
                    t.template = ele.tooltipTemplate;
                }
                t.dataContext = c;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        this._updateTooltipState();
        return ele;
    }
    _updateTooltipState() {
        if (this._initialized) {
            this.setState({ tooltips: this._currentTooltips });
        }
    }
    _ensureTooltipCreated() {
        if (this.i.toolTip == null) {
            let tooltip = this.createTooltip();
            let ele = tooltip;
            if (tooltip == null) {
                return;
            }
            this._tooltipContent = tooltip;
            //(<any>tooltip.instance).template = this._tooltipTemplate;
            this.i.toolTip = this.createWrapper(tooltip);
            if (this._activeTooltips.has(ele)) {
                let tCont = this._activeTooltips.get(ele);
                tCont.template = ele.tooltipTemplate;
            }
        }
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets a value indicating whether the bullet graph is currently animating.
*/
    get animating() {
        return this.i.a2;
    }
    /**
     * Gets the transition progress of the animation when the control is animating.
    */
    get transitionProgress() {
        return this.i.cq;
    }
    set transitionProgress(v) {
        this.i.cq = +v;
    }
    /**
     * Gets or sets the orientation of the scale.
    */
    get orientation() {
        return this.i.ar;
    }
    set orientation(v) {
        this.i.ar = ensureEnum(LinearScaleOrientation_$type, v);
    }
    /**
     * Gets or sets the background brush for the scale.
    */
    get scaleBackgroundBrush() {
        return brushToString(this.i.hj);
    }
    set scaleBackgroundBrush(v) {
        this.i.hj = stringToBrush(v);
    }
    /**
     * Gets or sets the background outline for the scale.
    */
    get scaleBackgroundOutline() {
        return brushToString(this.i.hk);
    }
    set scaleBackgroundOutline(v) {
        this.i.hk = stringToBrush(v);
    }
    /**
     * Gets or sets the background outline thickness for the scale.
    */
    get scaleBackgroundThickness() {
        return this.i.b8;
    }
    set scaleBackgroundThickness(v) {
        this.i.b8 = +v;
    }
    /**
     * Gets or sets a collection of brushes to be used as the palette for bullet graph ranges.
    */
    get rangeBrushes() {
        return fromBrushCollection(this.i.ah);
    }
    set rangeBrushes(v) {
        this.i.ah = toBrushCollection(v);
    }
    /**
     * Gets or sets a collection of brushes to be used as the palette for bullet graph outlines.
    */
    get rangeOutlines() {
        return fromBrushCollection(this.i.ai);
    }
    set rangeOutlines(v) {
        this.i.ai = toBrushCollection(v);
    }
    /**
     * Gets or sets the minimum value of the scale.
    */
    get minimumValue() {
        return this.i.by;
    }
    set minimumValue(v) {
        this.i.by = +v;
    }
    /**
     * Gets the resolved minimum value of the scale.
    */
    get actualMinimumValue() {
        return this.i.bl;
    }
    set actualMinimumValue(v) {
        this.i.bl = +v;
    }
    /**
     * Gets or sets the maximum value of the scale.
    */
    get maximumValue() {
        return this.i.bx;
    }
    set maximumValue(v) {
        this.i.bx = +v;
    }
    /**
     * Gets the resolved maximum value of the scale.
    */
    get actualMaximumValue() {
        return this.i.bk;
    }
    set actualMaximumValue(v) {
        this.i.bk = +v;
    }
    /**
     * Gets or sets the value indicated by the target value bar.
    */
    get targetValue() {
        return this.i.ce;
    }
    set targetValue(v) {
        this.i.ce = +v;
    }
    /**
     * Gets or sets the name used for the target value. The name is displayed in the default target value tooltip.
    */
    get targetValueName() {
        return this.i.d8;
    }
    set targetValueName(v) {
        this.i.d8 = v;
    }
    /**
     * Gets or sets the value at which the bar ends.
    */
    get value() {
        return this.i.cr;
    }
    set value(v) {
        this.i.cr = +v;
    }
    /**
     * Gets or sets the name used for actual value.
    */
    get valueName() {
        return this.i.ep;
    }
    set valueName(v) {
        this.i.ep = v;
    }
    /**
     * Gets or sets the position at which to start rendering the ranges, measured from the front/bottom of the control as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get rangeInnerExtent() {
        return this.i.b6;
    }
    set rangeInnerExtent(v) {
        this.i.b6 = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the range as a value from 0 to 1 measured from the front/bottom of the bullet graph.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get rangeOuterExtent() {
        return this.i.b7;
    }
    set rangeOuterExtent(v) {
        this.i.b7 = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the actual value geometries, measured from the front/bottom of the bullet graph as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get valueInnerExtent() {
        return this.i.cs;
    }
    set valueInnerExtent(v) {
        this.i.cs = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the actual value geometries as a value from 0 to 1 measured from the front/bottom of the bullet graph.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get valueOuterExtent() {
        return this.i.ct;
    }
    set valueOuterExtent(v) {
        this.i.ct = +v;
    }
    /**
     * Gets or sets the interval to use for the scale.
    */
    get interval() {
        return this.i.bs;
    }
    set interval(v) {
        this.i.bs = +v;
    }
    /**
     * A value to start adding tickmarks, added to the scale's MinimumValue.
    */
    get ticksPostInitial() {
        return this.i.cl;
    }
    set ticksPostInitial(v) {
        this.i.cl = +v;
    }
    /**
     * A value to stop adding tickmarks, subtracted from the scale's MaximumValue.
    */
    get ticksPreTerminal() {
        return this.i.cm;
    }
    set ticksPreTerminal(v) {
        this.i.cm = +v;
    }
    /**
     * Gets or sets the interval to use for rendering labels. This defaults to be the same interval as the tickmarks on the scale.
    */
    get labelInterval() {
        return this.i.bu;
    }
    set labelInterval(v) {
        this.i.bu = +v;
    }
    /**
     * Gets or sets the position at which to put the labels as a value from 0 to 1, measured from the bottom of the scale.
     * Values further from zero than 1 can be used to hide the labels of the bullet graph.
    */
    get labelExtent() {
        return this.i.bt;
    }
    set labelExtent(v) {
        this.i.bt = +v;
    }
    /**
     * A value to start adding labels, added to the scale's MinimumValue.
    */
    get labelsPostInitial() {
        return this.i.bv;
    }
    set labelsPostInitial(v) {
        this.i.bv = +v;
    }
    /**
     * A value to stop adding labels, subtracted from the scale's MaximumValue.
    */
    get labelsPreTerminal() {
        return this.i.bw;
    }
    set labelsPreTerminal(v) {
        this.i.bw = +v;
    }
    /**
     * Gets or sets the number of minor tickmarks to place between major tickmarks.
    */
    get minorTickCount() {
        return this.i.bz;
    }
    set minorTickCount(v) {
        this.i.bz = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the major tickmarks as a value from 0 to 1, measured from the front/bottom of the bullet graph.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get tickStartExtent() {
        return this.i.cn;
    }
    set tickStartExtent(v) {
        this.i.cn = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the major tickmarks as a value from 0 to 1, measured from the front/bottom of the bullet graph.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get tickEndExtent() {
        return this.i.cj;
    }
    set tickEndExtent(v) {
        this.i.cj = +v;
    }
    /**
     * Gets or sets the stroke thickness to use when rendering ticks.
    */
    get tickStrokeThickness() {
        return this.i.cp;
    }
    set tickStrokeThickness(v) {
        this.i.cp = +v;
    }
    /**
     * Gets or sets the brush to use for the major tickmarks.
    */
    get tickBrush() {
        return brushToString(this.i.hn);
    }
    set tickBrush(v) {
        this.i.hn = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the label font.
    */
    get fontBrush() {
        return brushToString(this.i.hg);
    }
    set fontBrush(v) {
        this.i.hg = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the actual value element.
    */
    get valueBrush() {
        return brushToString(this.i.ho);
    }
    set valueBrush(v) {
        this.i.ho = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the outline of actual value element.
    */
    get valueOutline() {
        return brushToString(this.i.hp);
    }
    set valueOutline(v) {
        this.i.hp = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness to use when rendering single actual value element.
    */
    get valueStrokeThickness() {
        return this.i.cu;
    }
    set valueStrokeThickness(v) {
        this.i.cu = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the minor tickmarks as a value from 0 to 1, measured from the front/bottom of the bullet graph.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get minorTickStartExtent() {
        return this.i.b2;
    }
    set minorTickStartExtent(v) {
        this.i.b2 = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the minor tickmarks as a value from 0 to 1, measured from the front/bottom of the bullet graph.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get minorTickEndExtent() {
        return this.i.b0;
    }
    set minorTickEndExtent(v) {
        this.i.b0 = +v;
    }
    /**
     * Gets or sets the stroke thickness to use when rendering minor ticks.
    */
    get minorTickStrokeThickness() {
        return this.i.b4;
    }
    set minorTickStrokeThickness(v) {
        this.i.b4 = +v;
    }
    /**
     * Gets or sets the brush to use for the minor tickmarks.
    */
    get minorTickBrush() {
        return brushToString(this.i.hi);
    }
    set minorTickBrush(v) {
        this.i.hi = stringToBrush(v);
    }
    /**
     * Gets or sets a value indicating whether the scale is inverted.
     * When the scale is inverted the direction in which the scale values increase is right to left.
    */
    get isScaleInverted() {
        return this.i.a4;
    }
    set isScaleInverted(v) {
        this.i.a4 = ensureBool(v);
    }
    /**
     * Gets or sets the brush to use to fill the backing of the bullet graph.
    */
    get backingBrush() {
        return brushToString(this.i.he);
    }
    set backingBrush(v) {
        this.i.he = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the outline of the backing.
    */
    get backingOutline() {
        return brushToString(this.i.hf);
    }
    set backingOutline(v) {
        this.i.hf = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness of the backing outline.
    */
    get backingStrokeThickness() {
        return this.i.bp;
    }
    set backingStrokeThickness(v) {
        this.i.bp = +v;
    }
    /**
     * Gets or sets the inner extent of the bullet graph backing.
    */
    get backingInnerExtent() {
        return this.i.bn;
    }
    set backingInnerExtent(v) {
        this.i.bn = +v;
    }
    /**
     * Gets or sets the outer extent of the bullet graph backing.
    */
    get backingOuterExtent() {
        return this.i.bo;
    }
    set backingOuterExtent(v) {
        this.i.bo = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the scale, measured from the front/bottom of the bullet graph as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get scaleStartExtent() {
        return this.i.cd;
    }
    set scaleStartExtent(v) {
        this.i.cd = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the scale as a value from 0 to 1, measured from the front/bottom of the bullet graph.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get scaleEndExtent() {
        return this.i.ca;
    }
    set scaleEndExtent(v) {
        this.i.ca = +v;
    }
    /**
     * Gets or sets the brush to use when rendering the fill of the comparative marker.
    */
    get targetValueBrush() {
        return brushToString(this.i.hl);
    }
    set targetValueBrush(v) {
        this.i.hl = stringToBrush(v);
    }
    /**
     * Get or sets the breadth of the target value element.
    */
    get targetValueBreadth() {
        return this.i.cf;
    }
    set targetValueBreadth(v) {
        this.i.cf = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the target value, measured from the front/bottom of the control as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get targetValueInnerExtent() {
        return this.i.cg;
    }
    set targetValueInnerExtent(v) {
        this.i.cg = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the target value, measured from the front/bottom of the control as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the bullet graph.
    */
    get targetValueOuterExtent() {
        return this.i.ch;
    }
    set targetValueOuterExtent(v) {
        this.i.ch = +v;
    }
    /**
     * Gets or sets the brush to use when rendering the outline of the target value.
    */
    get targetValueOutline() {
        return brushToString(this.i.hm);
    }
    set targetValueOutline(v) {
        this.i.hm = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness of the outline of the target value bar.
    */
    get targetValueStrokeThickness() {
        return this.i.ci;
    }
    set targetValueStrokeThickness(v) {
        this.i.ci = +v;
    }
    /**
     * Gets or sets the label composite format used when creating label values.
    */
    get labelFormat() {
        return this.i.dd;
    }
    set labelFormat(v) {
        this.i.dd = v;
    }
    /**
     * Gets or sets the format specifiers to use with the LabelFormat string.
    */
    get labelFormatSpecifiers() {
        return this.i.ag;
    }
    set labelFormatSpecifiers(v) {
        this.i.ag = v;
    }
    /**
     * Gets or sets the number of milliseconds over which changes to the bullet graph should be animated.
    */
    get transitionDuration() {
        return this.i.cy;
    }
    set transitionDuration(v) {
        this.i.cy = +v;
    }
    /**
     * Gets or sets the time in milliseconds that tooltip appearance is delayed with.
    */
    get showToolTipTimeout() {
        return this.i.cx;
    }
    set showToolTipTimeout(v) {
        this.i.cx = +v;
    }
    /**
     * Gets or sets a value indicating whether tooltips are enabled.
    */
    get showToolTip() {
        return this.i.a8;
    }
    set showToolTip(v) {
        this.i.a8 = ensureBool(v);
    }
    /**
     * Gets or sets the font.
    */
    get font() {
        return this.i.c7;
    }
    set font(v) {
        this.i.c7 = v;
    }
    /**
     * Gets or sets the scaling value used to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get pixelScalingRatio() {
        return this.i.b5;
    }
    set pixelScalingRatio(v) {
        this.i.b5 = +v;
    }
    /**
     * Gets the actual pixel scaling ratio used to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get actualPixelScalingRatio() {
        return this.i.bm;
    }
    set actualPixelScalingRatio(v) {
        this.i.bm = +v;
    }
    findByName(name) {
        if (this.ranges != null && this.ranges.findByName && this.ranges.findByName(name)) {
            return this.ranges.findByName(name);
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("BulletGraph");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Gets the value for the main scale of the bullet graph for a given point within the bounds of the bullet graph.

* @param point  * The point for which to retrieve the associated value.
*/
    getValueForPoint(point) {
        let iv = this.i.br(toPoint(point));
        return (iv);
    }
    /**
     * Returns visuals as a serialized string.
    
    */
    exportSerializedVisualData() {
        let iv = this.i.c6();
        return (iv);
    }
    /**
     * Provide a container for the bullet graph.
    
    * @param container  * The container.
    */
    provideContainer(container) {
        this.i.provideContainer(container);
    }
    /**
     * Notify that the container has resized.
    
    */
    containerResized() {
        this.i.containerResized();
    }
    /**
     * Notify that the bullet graph styling has updated.
    
    */
    styleUpdated() {
        this.i.fr();
    }
    /**
     * Use to force the bullet graph to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the bullet graph needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the bullet graph.
    
    */
    flush() {
        this.i.ez();
    }
    /**
     * Event which is raised when a label of the bullet graph is formatted.
     * Function takes first argument evt and second argument ui.
     * Use ui.owner to obtain reference to the bullet graph widget.
     * Use ui.actualMinimumValue to obtain the minimum value of the bullet graph scale.
     * Use ui.actualMaximumValue to obtain the maximum value of the bullet graph scale.
     * Use ui.value to obtain the value on the the bullet graph scale associated with the label.
     * Use ui.label to obtain the string value of the label.
    */
    get formatLabel() {
        return this._formatLabel;
    }
    set formatLabel(ev) {
        if (this._formatLabel_wrapped !== null) {
            this.i.formatLabel = delegateRemove(this.i.formatLabel, this._formatLabel_wrapped);
            this._formatLabel_wrapped = null;
            this._formatLabel = null;
        }
        this._formatLabel = ev;
        this._formatLabel_wrapped = (o, e) => {
            let outerArgs = new IgrFormatLinearGraphLabelEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFormatLabel) {
                this.beforeFormatLabel(this, outerArgs);
            }
            if (this._formatLabel) {
                this._formatLabel(this, outerArgs);
            }
        };
        this.i.formatLabel = delegateCombine(this.i.formatLabel, this._formatLabel_wrapped);
    }
    /**
     * Event which is raised when a label of the bullet graph is aligned along the scale.
     * Function takes first argument evt and second argument ui.
     * Use ui.owner to obtain reference to gauge widget.
     * Use ui.actualMinimumValue to obtain the minimum value of the bullet graph scale.
     * Use ui.actualMaximumValue to obtain the maximum value of the bullet graph scale.
     * Use ui.value to obtain the value on the the bullet graph scale associated with the label.
     * Use ui.label to obtain the string value of the label.
     * Use ui.width to obtain the width of the label.
     * Use ui.height to obtain the height of the label.
     * Use ui.offsetX to obtain the X offset of the label on the bullet graph scale.
     * Use ui.offsetY to obtain the Y offset of the label on the bullet graph scale.
    */
    get alignLabel() {
        return this._alignLabel;
    }
    set alignLabel(ev) {
        if (this._alignLabel_wrapped !== null) {
            this.i.alignLabel = delegateRemove(this.i.alignLabel, this._alignLabel_wrapped);
            this._alignLabel_wrapped = null;
            this._alignLabel = null;
        }
        this._alignLabel = ev;
        this._alignLabel_wrapped = (o, e) => {
            let outerArgs = new IgrAlignLinearGraphLabelEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeAlignLabel) {
                this.beforeAlignLabel(this, outerArgs);
            }
            if (this._alignLabel) {
                this._alignLabel(this, outerArgs);
            }
        };
        this.i.alignLabel = delegateCombine(this.i.alignLabel, this._alignLabel_wrapped);
    }
    get actualMinimumValueChange() {
        return this._actualMinimumValueChange;
    }
    set actualMinimumValueChange(ev) {
        if (this._actualMinimumValueChange_wrapped !== null) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
            this._actualMinimumValueChange_wrapped = null;
            this._actualMinimumValueChange = null;
        }
        this._actualMinimumValueChange = ev;
        this._actualMinimumValueChange_wrapped = (o, e) => {
            let ext = this.actualMinimumValue;
            if (this.beforeActualMinimumValueChange) {
                this.beforeActualMinimumValueChange(this, ext);
            }
            if (this._actualMinimumValueChange) {
                this._actualMinimumValueChange(this, ext);
            }
        };
        this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
    }
    get actualMaximumValueChange() {
        return this._actualMaximumValueChange;
    }
    set actualMaximumValueChange(ev) {
        if (this._actualMaximumValueChange_wrapped !== null) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
            this._actualMaximumValueChange_wrapped = null;
            this._actualMaximumValueChange = null;
        }
        this._actualMaximumValueChange = ev;
        this._actualMaximumValueChange_wrapped = (o, e) => {
            let ext = this.actualMaximumValue;
            if (this.beforeActualMaximumValueChange) {
                this.beforeActualMaximumValueChange(this, ext);
            }
            if (this._actualMaximumValueChange) {
                this._actualMaximumValueChange(this, ext);
            }
        };
        this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrLinearGraphRangeModule {
    static register() {
        TypeRegistrar.registerCons('IgrLinearGraphRange', IgrLinearGraphRange);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrBulletGraphCoreModule {
    static register() {
        TypeRegistrar.registerCons('IgrBulletGraph', IgrBulletGraph);
        IgrLinearGraphRangeModule.register();
        IgrNumberFormatSpecifierModule.register();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrBulletGraphModule {
    static register() {
        IgrBulletGraphCoreModule.register();
        IgrDVInteractivityModule.register();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enumeration of preset needle shapes.
 */
var LinearGraphNeedleShape = /*@__PURE__*/ (function (LinearGraphNeedleShape) {
    /**
     * A custom user defined needle shape.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Custom"] = 0] = "Custom";
    /**
     * A needle shaped like a rectangle.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Rectangle"] = 1] = "Rectangle";
    /**
     * A needle shaped like a triangle.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Triangle"] = 2] = "Triangle";
    /**
     * A needle shaped like a needle.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Needle"] = 3] = "Needle";
    /**
     * A needle shaped like a trapezoid.
     */
    LinearGraphNeedleShape[LinearGraphNeedleShape["Trapezoid"] = 4] = "Trapezoid";
    return LinearGraphNeedleShape;
})({});
/**
 * @hidden
 */
let LinearGraphNeedleShape_$type = /*@__PURE__*/ markEnum('LinearGraphNeedleShape', 'Custom,0|Rectangle,1|Triangle,2|Needle,3|Trapezoid,4');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying the position of the titles relative to scale's start/end.
 */
var TitlesPosition = /*@__PURE__*/ (function (TitlesPosition) {
    /**
     * The titles are placed at scale's start (minimum value).
     */
    TitlesPosition[TitlesPosition["ScaleStart"] = 0] = "ScaleStart";
    /**
     * The titles are placed at the scale's end (maximum value).
     */
    TitlesPosition[TitlesPosition["ScaleEnd"] = 1] = "ScaleEnd";
    return TitlesPosition;
})({});
/**
 * @hidden
 */
let TitlesPosition_$type = /*@__PURE__*/ markEnum('TitlesPosition', 'ScaleStart,0|ScaleEnd,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphNeedlePreparer = /*@__PURE__*/ (() => {
    class LinearGraphNeedlePreparer extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        c(a) {
            this.d(a);
        }
        d(a) {
            this.f(a);
            let b = this.a();
            a.n = b.u;
            a.m = b.q;
            a.q = 0;
            if (!isNaN_(b.t)) {
                a.q = Math.max(a.q, b.t);
            }
            if (!isNaN_(b.p)) {
                a.q = Math.max(a.q, b.p);
            }
            let c = 7;
            let d = new Array(c);
            let e = new Array(c + 1);
            this.e(a, d, e, b);
            for (let f = 0; f < c; f++) {
                let g = d[f].f;
                g.add(e[f]);
                g.add(e[f + 1]);
            }
        }
        e(a, b, c, d) {
            let e = d.q;
            let f = d.u;
            let g = d.r;
            let h = d.v;
            if (d.d == 0) {
                e = 1 - e;
                f = 1 - f;
                g = 1 - g;
                h = 1 - h;
                b[0] = a.i;
                b[1] = a.j;
                b[2] = a.d;
                b[3] = a.g;
                b[4] = a.f;
                b[5] = a.h;
                b[6] = a.e;
                c[0] = { $type: Point_$type, x: (-1) * d.t, y: f };
                c[1] = { $type: Point_$type, x: d.t, y: f };
                c[2] = { $type: Point_$type, x: d.w, y: h };
                c[3] = { $type: Point_$type, x: d.s, y: g };
                c[4] = { $type: Point_$type, x: d.p, y: e };
                c[5] = { $type: Point_$type, x: (-1) * d.p, y: e };
                c[6] = { $type: Point_$type, x: (-1) * d.s, y: g };
                c[7] = { $type: Point_$type, x: (-1) * d.w, y: h };
            }
            else {
                b[0] = a.i;
                b[1] = a.j;
                b[2] = a.d;
                b[3] = a.g;
                b[4] = a.f;
                b[5] = a.h;
                b[6] = a.e;
                c[0] = { $type: Point_$type, x: f, y: (-1) * d.t };
                c[1] = { $type: Point_$type, x: f, y: d.t };
                c[2] = { $type: Point_$type, x: h, y: d.w };
                c[3] = { $type: Point_$type, x: g, y: d.s };
                c[4] = { $type: Point_$type, x: e, y: d.p };
                c[5] = { $type: Point_$type, x: e, y: (-1) * d.p };
                c[6] = { $type: Point_$type, x: g, y: (-1) * d.s };
                c[7] = { $type: Point_$type, x: h, y: (-1) * d.w };
            }
        }
        a() {
            let a = this.b;
            let b = 0.85;
            let c = 0.25;
            let d = 0.45;
            let e = a.o;
            let f = 0.5;
            let g = a.q;
            let h = a.u;
            let i = a.r;
            let j = a.v;
            let k = a.p;
            let l = a.t;
            let m = a.s;
            let n = a.w;
            if (isNaN_(g)) {
                g = c;
            }
            if (isNaN_(h)) {
                h = b;
            }
            if (isNaN_(i)) {
                if (a.c == 3) {
                    i = d;
                }
                else {
                    i = c;
                }
            }
            if (isNaN_(j)) {
                j = b;
            }
            if (isNaN_(l)) {
                l = e;
            }
            if (isNaN_(k)) {
                if (a.c == 4) {
                    k = l * f;
                }
                else {
                    k = e;
                }
            }
            if (isNaN_(m)) {
                m = e;
            }
            if (isNaN_(n)) {
                n = e;
            }
            switch (a.c) {
                case 2:
                case 1:
                case 4:
                    j = h;
                    i = g;
                    break;
            }
            if (a.c == 3) {
                k = 0;
                m = l;
                n = l;
                j = h;
            }
            if (a.c == 2) {
                k = 0;
                m = 0;
                n = l;
            }
            if (a.c == 4) {
                m = k;
                n = l;
            }
            if (a.c == 1) {
                let o = Math.max(k, l);
                k = o;
                l = o;
                m = o;
                n = o;
            }
            a.q = g;
            a.u = h;
            a.r = i;
            a.v = j;
            a.p = k;
            a.t = l;
            a.s = m;
            a.w = n;
            return a;
        }
        f(a) {
            a.f.k();
            a.g.k();
            a.d.k();
            a.j.k();
            a.i.k();
            a.k.k();
            a.e.k();
            a.h.k();
            a.b.k();
            a.c.k();
        }
    }
    LinearGraphNeedlePreparer.$t = /*@__PURE__*/ markType(LinearGraphNeedlePreparer, 'LinearGraphNeedlePreparer');
    return LinearGraphNeedlePreparer;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGraphNeedleParameters = /*@__PURE__*/ (() => {
    class LinearGraphNeedleParameters extends Base {
        constructor() {
            super(...arguments);
            this.d = 0;
            this.e = false;
            this.k = NaN;
            this.j = NaN;
            this.g = NaN;
            this.l = NaN;
            this.i = NaN;
            this.n = NaN;
            this.h = NaN;
            this.m = NaN;
            this.f = NaN;
            this.b = 3;
            this.propertyChanged = null;
        }
        get u() {
            return this.k;
        }
        set u(a) {
            if (this.k != a) {
                this.k = a;
                this.x("OuterExtent");
            }
        }
        get q() {
            return this.j;
        }
        set q(a) {
            if (this.j != a) {
                this.j = a;
                this.x("InnerExtent");
            }
        }
        get p() {
            return this.g;
        }
        set p(a) {
            if (this.g != a) {
                this.g = a;
                this.x("InnerBaseWidth");
            }
        }
        get t() {
            return this.l;
        }
        set t(a) {
            if (this.l != a) {
                this.l = a;
                this.x("OuterBaseWidth");
            }
        }
        get s() {
            return this.i;
        }
        set s(a) {
            if (this.i != a) {
                this.i = a;
                this.x("InnerPointWidth");
            }
        }
        get w() {
            return this.n;
        }
        set w(a) {
            if (this.n != a) {
                this.n = a;
                this.x("OuterPointWidth");
            }
        }
        get r() {
            return this.h;
        }
        set r(a) {
            if (this.h != a) {
                this.h = a;
                this.x("InnerPointExtent");
            }
        }
        get v() {
            return this.m;
        }
        set v(a) {
            if (this.m != a) {
                this.m = a;
                this.x("OuterPointExtent");
            }
        }
        get o() {
            return this.f;
        }
        set o(a) {
            if (this.f != a) {
                this.f = a;
                this.x("DefaultWidth");
            }
        }
        get c() {
            return this.b;
        }
        set c(a) {
            if (this.b != a) {
                this.b = a;
                this.x("NeedleShape");
            }
        }
        a() {
            let a = new LinearGraphNeedleParameters();
            a.u = this.u;
            a.q = this.q;
            a.p = this.p;
            a.t = this.t;
            a.r = this.r;
            a.v = this.v;
            a.s = this.s;
            a.w = this.w;
            a.c = this.c;
            a.o = this.o;
            return a;
        }
        x(a) {
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
        }
    }
    LinearGraphNeedleParameters.$t = /*@__PURE__*/ markType(LinearGraphNeedleParameters, 'LinearGraphNeedleParameters', Base.$, [INotifyPropertyChanged_$type]);
    return LinearGraphNeedleParameters;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearScaleVisualData = /*@__PURE__*/ (() => {
    class LinearScaleVisualData extends Base {
    }
    LinearScaleVisualData.$t = /*@__PURE__*/ markType(LinearScaleVisualData, 'LinearScaleVisualData');
    return LinearScaleVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGaugeScaleFrame = /*@__PURE__*/ (() => {
    class LinearGaugeScaleFrame extends LinearGraphScaleFrame {
        constructor() {
            super();
            this.af = null;
            this.af = new LinearGraphNeedleFrame();
        }
        y(a, b, c) {
            super.y(a, b, c);
            this.af = LinearGraphNeedleFrame.a(a, 1 - a, b.af, c.af);
        }
    }
    LinearGaugeScaleFrame.$t = /*@__PURE__*/ markType(LinearGaugeScaleFrame, 'LinearGaugeScaleFrame', LinearGraphScaleFrame.$);
    return LinearGaugeScaleFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGaugeFrame = /*@__PURE__*/ (() => {
    class LinearGaugeFrame extends LinearGraphFrame {
        constructor() {
            super();
            this._c = null;
            this.c = new LinearGaugeScaleFrame();
        }
        get_c() {
            return this._c;
        }
        set_c(a) {
            this._c = a;
        }
        get c() {
            return this.get_c();
        }
        set c(a) {
            this.set_c(a);
        }
    }
    LinearGaugeFrame.$t = /*@__PURE__*/ markType(LinearGaugeFrame, 'LinearGaugeFrame', LinearGraphFrame.$);
    return LinearGaugeFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearGaugeVisualData = /*@__PURE__*/ (() => {
    class LinearGaugeVisualData extends LinearGraphVisualData {
        constructor() {
            super(...arguments);
            this._needlePath = null;
            this._needle = null;
        }
        get needlePath() {
            return this._needlePath;
        }
        set needlePath(a) {
            this._needlePath = a;
        }
        get needle() {
            return this._needle;
        }
        set needle(a) {
            this._needle = a;
        }
        scaleByViewport() {
            super.scaleByViewport();
            if (this.needlePath != null) {
                this.needlePath.scaleByViewport(this.viewport);
            }
        }
        serialize() {
            let a = super.serialize();
            let b = new StringBuilder(0);
            let c = a.length == 0;
            if (this.needlePath != null) {
                if (c) {
                    c = false;
                }
                else {
                    b.l(", ");
                }
                b.l("needlePath: ");
                b.u(this.needlePath.serialize());
            }
            if (this.needle != null) {
                if (c) {
                    c = false;
                }
                else {
                    b.l(", ");
                }
                b.l("needle: ");
                b.u(this.needle.serialize());
            }
            if (c) {
                return a;
            }
            b.l("}");
            return a.substr(0, a.length - 1) + b.toString();
        }
    }
    LinearGaugeVisualData.$t = /*@__PURE__*/ markType(LinearGaugeVisualData, 'LinearGaugeVisualData', LinearGraphVisualData.$);
    return LinearGaugeVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearNeedleVisualData = /*@__PURE__*/ (() => {
    class LinearNeedleVisualData extends ToolTipItemVisualData {
        constructor() {
            super(...arguments);
            this._value = 0;
        }
        get value() {
            return this._value;
        }
        set value(a) {
            this._value = a;
        }
        serialize() {
            return "{ value: " + this.value.toString() + ", type: '" + this.type + "'}";
        }
        get_type() {
            return "needle";
        }
        get type() {
            return this.get_type();
        }
    }
    LinearNeedleVisualData.$t = /*@__PURE__*/ markType(LinearNeedleVisualData, 'LinearNeedleVisualData', ToolTipItemVisualData.$);
    return LinearNeedleVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let XamLinearGauge = /*@__PURE__*/ (() => {
    class XamLinearGauge extends Control {
        constructor() {
            super();
            this.propertyChanged = null;
            this.av = null;
            this.bq = 0;
            this.formatLabel = null;
            this.alignLabel = null;
            this.valueChanged = null;
            this.ao = null;
            this.an = null;
            this.am = null;
            this.ar = null;
            this.bn = 0;
            this.bm = 100;
            this.a3 = false;
            this.aj = null;
            this.be = false;
            this.a1 = null;
            this.az = null;
            this.ay = null;
            this.a2 = null;
            this.a0 = null;
            this.bk = null;
            this.h4 = null;
            this._view = null;
            this.h6 = null;
            this.h5 = null;
            this.h3 = null;
            this.bg = new List$1(TextBlock.$, 0);
            this.bj = new List$1(TextBlock.$, 0);
            this.bi = new List$1(Path.$, 0);
            this.bh = new List$1(Path.$, 0);
            this.a5 = false;
            this.bp = NaN;
            this.bo = 1;
            this.bp = NaN;
            this.bo = 1;
            this.view = new XamLinearGaugeView(this);
            this.view.bc();
            this.h6 = Rect.empty;
            this.h5 = Rect.empty;
            this.h3 = Rect.empty;
            this.ao = new LinearGaugeFrame();
            this.an = new LinearGaugeFrame();
            this.am = new LinearGaugeFrame();
            this.ranges = new LinearGraphRangeCollection();
            this.a5 = true;
            this.av = new DoubleAnimator(0, 1, this.c4);
            let a = this.av;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.e3));
            this.ab = XamLinearGauge.$;
            this.a0 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.bm);
                $ret.c = runOn(this.view, this.view.bn);
                $ret.d = runOn(this.view, this.view.bo);
                $ret.j = runOn(this.view, this.view.co);
                return $ret;
            })());
            this.a1 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.bf);
                $ret.c = runOn(this.view, this.view.bg);
                $ret.d = runOn(this.view, this.view.bh);
                $ret.j = runOn(this.view, this.view.cn);
                return $ret;
            })());
            this.az = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.bf);
                $ret.c = runOn(this.view, this.view.bg);
                $ret.d = runOn(this.view, this.view.bh);
                $ret.j = runOn(this.view, this.view.cn);
                return $ret;
            })());
            this.ay = ((() => {
                let $ret = new StackPool$1(TextBlock.$);
                $ret.b = runOn(this.view, this.view.a4);
                $ret.c = runOn(this.view, this.view.a5);
                $ret.d = runOn(this.view, this.view.a6);
                $ret.j = runOn(this.view, this.view.b3);
                return $ret;
            })());
            this.a2 = ((() => {
                let $ret = new StackPool$1(TextBlock.$);
                $ret.b = runOn(this.view, this.view.bw);
                $ret.c = runOn(this.view, this.view.bx);
                $ret.d = runOn(this.view, this.view.by);
                $ret.j = runOn(this.view, this.view.b4);
                return $ret;
            })());
        }
        fj(a) {
            this.fp(a);
        }
        fp(a) {
            let b = this.propertyChanged;
            if (b != null) {
                b(this, new PropertyChangedEventArgs(a));
            }
        }
        e3(a, b) {
            this.cz = this.av.o;
        }
        get a4() {
            return this.av.f();
        }
        get cz() {
            return this.bq;
        }
        set cz(a) {
            let b = this.bq;
            this.bq = a;
            this.fi("TransitionProgress", b, this.bq);
        }
        f1() {
            this.bq = 0;
            this.av.w();
            this.av.v();
        }
        get bd() {
            return this.c4 > 0;
        }
        onDetachedFromUI() {
            this.view.bb();
        }
        onAttachedToUI() {
            this.view.a7();
        }
        get bs() {
            return this.bn;
        }
        set bs(a) {
            this.bn = a;
        }
        get br() {
            return this.bm;
        }
        set br(a) {
            this.bm = a;
        }
        bx(a) {
            let b = 0;
            let c = a.x;
            if (this.as == 1) {
                b = a.y;
                c = this.h9.height;
            }
            return this.ar.k(c - b);
        }
        bb(a) {
            if (this.bk == null) {
                return false;
            }
            return PolygonUtil.a(this.bk, a);
        }
        needleContainsPoint(a, b) {
            if (this.bk == null) {
                return false;
            }
            return b ? this.h4.containsPoint(a) : PolygonUtil.a(this.bk, a);
        }
        e7(a, b) {
            let c = this.bx(a);
            c = Math.max(Math.min(c, this.br), this.bs);
            if (c != this.c0) {
                this.c0 = c;
            }
        }
        at() {
            let a = new LinearGaugeVisualData();
            a.viewport = new RectData(this.h9.left, this.h9.top, this.h9.width, this.h9.height);
            a.scaleLabels = new LinearGraphScaleLabelVisualDataList();
            a.scaleTickmarks = new LinearGraphScaleTickmarkVisualDataList();
            a.ranges = new LinearGraphRangeVisualDataList();
            a.needle = ((() => {
                let $ret = new LinearNeedleVisualData();
                $ret.value = this.c0;
                return $ret;
            })());
            this.view.az(a);
            let b = this.view.l();
            if (b != null) {
                let c = null;
                switch (b.c) {
                    case "range":
                        c = a.ranges._inner[b.b];
                        break;
                    case "needle":
                        c = a.needle;
                        break;
                }
                a.toolTip = ((() => {
                    let $ret = new LinearGraphToolTipVisualData();
                    $ret.item = c;
                    $ret.itemBrush = AppearanceHelper.b(b.a.brush);
                    $ret.outline = AppearanceHelper.b(b.a.outline);
                    $ret.thickness = b.a.thickness;
                    return $ret;
                })());
            }
            return a;
        }
        dc() {
            let a = this.at();
            a.scaleByViewport();
            return a.serialize();
        }
        e8() {
            this.view.flush();
        }
        destroy() {
            this.provideContainer(null);
        }
        provideContainer(a) {
            this.view.a9(a);
        }
        onMouseOver(a, b, c) {
            if (this.be) {
                this.f0(a, null);
            }
        }
        onMouseLeave() {
            if (this.be) {
                this.f0({ $type: Point_$type, x: -10000, y: -10000 }, null);
            }
        }
        onMouseMove(a, b) {
            if (this.a3) {
                this.e7(a, b);
            }
        }
        onMouseDown(a, b) {
            if (this.a7 && !this.a3 && this.needleContainsPoint(a, b)) {
                this.a3 = true;
            }
        }
        get a6() {
            return this.a3;
        }
        onMouseUp(a) {
            if (this.a3) {
                this.a3 = false;
            }
        }
        containerResized() {
            this.view.ba();
        }
        f2() {
            this.view.bv();
        }
        f0(a, b) {
            let c = this.bk;
            if (c != null && c.count > 0) {
                let d = PolygonUtil.a(c, a);
                if (d == true) {
                    this.view.bu(a, b, -1, "needle");
                    return;
                }
            }
            for (let e = 0; e < this.bh.count; e++) {
                let f = new PathVisualData(1, "range", this.bh._inner[e]);
                let g = f.getPoints(new GetPointsSettings());
                if (g.count > 0) {
                    let h = PolygonUtil.a(this.bl(g._inner[0]), a);
                    if (h == true) {
                        this.view.bu(a, b, e, "range");
                        return;
                    }
                }
            }
            this.view.a2();
        }
        fu() {
            if (!this.a5) {
                return;
            }
            let a = this.an.c;
            if (this.as == 0) {
                let b = 0;
                for (let c = 0; c < a.c.length; c++) {
                    b = Math.max(b, a.c[c]);
                }
                let d = this.h9.height >= b ? this.h9.height - b : this.h9.height;
                this.h8 = new Rect(0, 0, 0, this.h9.width, d);
            }
            else {
                let e = 0;
                for (let f = 0; f < a.f.length; f++) {
                    e = Math.max(e, a.f[f]);
                }
                let g = this.h9.width >= e ? this.h9.width - e : this.h9.width;
                this.h8 = new Rect(0, e, 0, g, this.h9.height);
            }
        }
        get view() {
            return this._view;
        }
        set view(a) {
            this._view = a;
        }
        get h9() {
            return this.h6;
        }
        set h9(a) {
            let b = this.h6;
            this.h6 = a;
            if (!b.equals1(this.h6)) {
                this.fk(b, this.h6);
            }
        }
        get h8() {
            return this.h5;
        }
        set h8(a) {
            this.h5 = a;
        }
        get h7() {
            return this.h3;
        }
        set h7(a) {
            this.h3 = a;
        }
        a9() {
            return !isNaN_(this.bs) && !isNaN_(this.br) && !this.h9.isEmpty && this.view.s();
        }
        e4() {
            if (!this.a9()) {
                return;
            }
            let a = this.cr();
            this.ar = new LinearGraphScaler(this.bs, this.br, a, a + this.cp(), this.a8);
            if (this.a5) {
                if (this.a4) {
                    if (this.av.g) {
                        this.av.t();
                    }
                    let b = this.ao;
                    this.ao = this.am;
                    this.am = b;
                }
                else {
                    let c = this.ao;
                    this.ao = this.an;
                    this.an = c;
                }
            }
            else if (this.a4) {
                this.am.d(this.cz, this.ao, this.an);
                this.fv(this.am);
                this.fy(this.am);
                this.fx(this.am);
            }
            if (this.a5) {
                this.fm();
                this.fu();
                this.fn();
                this.fo();
                this.fl();
            }
            if (this.a5 && this.bd) {
                this.f1();
                this.am.d(this.cz, this.ao, this.an);
                this.fv(this.am);
                this.fy(this.am);
                this.fx(this.am);
                this.fz(this.am);
                this.fw(this.am);
            }
            else {
                if (this.a5) {
                    this.fv(this.an);
                    this.fy(this.an);
                    this.fx(this.an);
                    this.fz(this.an);
                    this.fw(this.an);
                }
            }
            this.a5 = false;
            this.view.as();
        }
        fo() {
            let a = this.an;
            let b = a.c;
            let c = this.ar;
            let d = this.b5;
            let e = this.h8;
            b.u = this.cs;
            b.r = this.cn;
            b.s = this.co;
            b.t = this.cq;
            b.m.clear();
            for (let f = 0; f < this.ranges.count; f++) {
                let g = this.ranges._inner[f];
                if (g.j <= this.bs || g.o > this.br) {
                    continue;
                }
                let h = g.o;
                let i = g.j;
                if (h < this.bs) {
                    h = this.bs;
                }
                if (i > this.br) {
                    i = this.br;
                }
                let j = new LinearGraphRectFrame();
                j.i = g.an != null ? g.an : this.hv(f, this.ah);
                j.j = g.ao != null ? g.ao : this.hv(f, this.ai);
                j.h = g.p;
                j.g = c.i(h);
                j.d = c.i(i);
                j.e = g.l;
                j.b = g.k;
                j.f = g.n;
                j.c = g.m;
                if (isNaN_(j.e)) {
                    j.e = this.ck;
                }
                j.b = g.k;
                if (isNaN_(j.b)) {
                    j.b = this.ck;
                }
                j.f = g.n;
                if (isNaN_(j.f)) {
                    j.f = this.cl;
                }
                j.c = g.m;
                if (isNaN_(j.c)) {
                    j.c = this.cl;
                }
                b.m.add(j);
            }
            b.ab = this.hu;
            b.ad = this.h1;
            b.x = this.cy;
            b.w = this.cx;
            b.v = this.cu;
            b.ac = this.hw;
            b.q = this.b8;
            b.p = this.b7;
            b.o = this.b6;
            let k = this.by;
            if (isNaN_(k)) {
                k = (this.br - this.bs) / 10;
            }
            if (k == 0) {
                k = this.br - this.bs;
            }
            let l = new List$1(Number_$type, 0);
            let m = new List$1(Number_$type, 0);
            if (k > 0) {
                let n = this.bs + this.cv;
                let o = this.br - this.cw;
                let p = 100000;
                let q = Math.abs(o - n) / p;
                if (k >= q) {
                    for (let r = n; r <= o || this.bf(r, o, k); r = r + k) {
                        l.add(c.i(r));
                        for (let s = 0; s < d; s++) {
                            let t = (k / (d + 1)) * (s + 1);
                            if (t + r > o) {
                                continue;
                            }
                            m.add(c.i(t + r));
                        }
                    }
                }
            }
            if (b.j.length != l.count || b.i.length != m.count) {
                b.j = new Array(l.count);
                b.i = new Array(m.count);
            }
            for (let u = 0; u < l.count; u++) {
                b.j[u] = l._inner[u];
            }
            for (let v = 0; v < m.count; v++) {
                b.i[v] = m._inner[v];
            }
        }
        ia() {
            let a = this.by;
            let b = this.b0;
            if (isNaN_(a)) {
                a = (this.br - this.bs) / 10;
            }
            if (isNaN_(b)) {
                b = a;
            }
            if (b == 0) {
                b = this.br - this.bs;
            }
            let c = new List$1(Number_$type, 0);
            if (b > 0) {
                let d = this.b1 + this.bs;
                let e = this.br - this.b2;
                let f = 100000;
                let g = Math.abs(e - d) / f;
                if (b >= g) {
                    for (let h = d; h <= e || this.bf(h, e, a); h += b) {
                        c.add(h);
                    }
                }
            }
            let i = new Array(c.count);
            let j = new Array(c.count);
            for (let k = 0; k < c.count; k++) {
                let l = c._inner[k];
                if (this.formatLabel == null && this.aj == null) {
                    l = (Math.round(l * 100) / 100);
                }
                let m = l.toString();
                if (this.aj != null) {
                    m = this.aj.i(l);
                }
                let n = new FormatLinearGraphLabelEventArgs();
                n.value = l;
                n.label = m;
                if (this.formatLabel != null) {
                    this.formatLabel(this, n);
                }
                m = n.label;
                let o = this.view.cp(((() => {
                    let $ret = new TextBlock();
                    $ret.ak = m;
                    return $ret;
                })()));
                i[k] = o.width;
                j[k] = o.height;
            }
            let p = 0;
            let q = 0;
            let r = 1 - this.cn + this.cs;
            if (this.as == 0) {
                for (let s = 0; s < j.length; s++) {
                    q = Math.max(q, j[s]);
                }
                for (let t = 0; t < i.length; t++) {
                    p += i[t];
                }
                if (i.length > 0) {
                    p += i[0] / 2;
                }
                if (i.length > 1) {
                    p += i[i.length - 1] / 2;
                }
                if (i.length > 0) {
                    p += (i.length - 1) * 5;
                }
                if (r > 0) {
                    p = p / Math.abs(1 - r);
                }
            }
            else {
                for (let u = 0; u < i.length; u++) {
                    p = Math.max(p, i[u]);
                }
                for (let v = 0; v < j.length; v++) {
                    q += j[v];
                }
                if (j.length > 0) {
                    q -= j[0] / 2;
                }
                if (j.length > 1) {
                    q -= j[j.length - 1] / 2;
                }
                if (r > 0) {
                    q = q / Math.abs(1 - r);
                }
                if (j.length > 0) {
                    q += (j.length - 1) * 5;
                }
            }
            return new Size(1, p, q);
        }
        fm() {
            let a = this.an;
            let b = a.c;
            let c = this.ar;
            let d = this.by;
            let e = this.b0;
            let f = this.b5;
            if (isNaN_(d)) {
                d = (this.br - this.bs) / 10;
            }
            if (isNaN_(e)) {
                e = d;
            }
            if (e == 0) {
                e = this.br - this.bs;
            }
            let g = new List$1(Tuple$2.$.specialize(Number_$type, Number_$type), 0);
            if (e > 0) {
                let h = this.b1 + this.bs;
                let i = this.br - this.b2;
                let j = 100000;
                let k = Math.abs(i - h) / j;
                if (e >= k) {
                    for (let l = h; l <= i || this.bf(l, i, e); l = l + e) {
                        g.add(new Tuple$2(Number_$type, Number_$type, l, c.i(l)));
                    }
                }
            }
            if (b.d.length != g.count) {
                b.e = new Array(g.count);
                b.d = new Array(g.count);
                b.f = new Array(g.count);
                b.c = new Array(g.count);
                b.g = new Array(g.count);
                b.h = new Array(g.count);
            }
            b.n = this.bz;
            let m = new FormatLinearGraphLabelEventArgs();
            m.actualMinimumValue = this.bs;
            m.actualMaximumValue = this.br;
            let n = new AlignLinearGraphLabelEventArgs();
            n.actualMinimumValue = this.bs;
            n.actualMaximumValue = this.br;
            for (let o = 0; o < g.count; o++) {
                let p = g._inner[o].c;
                if (this.formatLabel == null) {
                    p = (Math.round(p * 100) / 100);
                }
                let q = (p).toString();
                if (this.aj != null) {
                    q = this.aj.i(p);
                }
                m.value = p;
                n.value = p;
                m.label = q;
                if (this.formatLabel != null) {
                    this.formatLabel(this, m);
                }
                q = m.label;
                n.label = q;
                let r = this.view.cp(((() => {
                    let $ret = new TextBlock();
                    $ret.ak = q;
                    return $ret;
                })()));
                n.width = r.width;
                n.height = r.height;
                if (this.as == 0) {
                    n.offsetX = -1 * (r.width / 2);
                    n.offsetY = -1 * (r.height);
                }
                else {
                    n.offsetX = -1 * r.width;
                    n.offsetY = -1 * (r.height / 2);
                }
                if (this.alignLabel != null) {
                    this.alignLabel(this, n);
                }
                b.f[o] = n.width;
                b.c[o] = n.height;
                b.g[o] = n.offsetX;
                ;
                b.h[o] = n.offsetY;
                b.d[o] = q;
                b.e[o] = g._inner[o].d;
            }
        }
        bf(a, b, c) {
            let d = c / 10000;
            if (isNaN_(d)) {
                d = 1E-05;
            }
            let e = Math.abs(a - b);
            if (e < d) {
                return true;
            }
            return false;
        }
        fl() {
            let a = this.an;
            let b = a.a;
            b.e = this.hs;
            b.f = this.ht;
            b.c = this.bw;
            b.a = this.bu;
            b.b = this.bv;
        }
        fn() {
            let a = this.c0;
            if (isNaN_(a)) {
                return;
            }
            let b = this.an.c;
            let c = this.ar;
            let d = new LinearGraphNeedleParameters();
            d.c = this.ap;
            d.e = this.a8;
            d.d = this.as;
            d.u = this.cf;
            d.q = this.cb;
            d.v = this.cg;
            d.r = this.cc;
            d.t = this.ce;
            d.p = this.ca;
            d.s = this.cd;
            d.w = this.ch;
            d.o = this.b9 * 0.5 / this.cm();
            let e = new LinearGraphNeedleFrame();
            e.r = this.hx;
            e.s = this.hy;
            e.o = this.ci;
            let f = new LinearGraphNeedlePreparer();
            f.b = d;
            f.c(e);
            e.l = -90;
            let g = c.i(a);
            e.p = g;
            b.af = e;
        }
        hv(a, b) {
            if (b != null && b.count > 0) {
                return b.item(a % b.count);
            }
            else {
                return null;
            }
        }
        fz(a) {
            let b = this.h8;
            let c = a.c;
            let d = this.a1;
            let e = c.j;
            let f = c.w;
            let g = c.v;
            let h = c.ad;
            let i = c.x;
            let j = this.az;
            let k = c.i;
            let l = c.p;
            let m = c.o;
            let n = c.ac;
            let o = c.q;
            d.f = true;
            for (let p = 0; p < this.bi.count; p++) {
                d.n(this.bi._inner[p]);
            }
            this.bi.clear();
            let q = this.cm();
            let r = this.c2();
            for (let s = 0; s < e.length; s++) {
                let t, u, v, w;
                if (this.as == 1) {
                    t = b.left + q * f;
                    u = r - e[s];
                    v = b.left + q * g;
                    w = u;
                }
                else {
                    t = b.left + e[s];
                    u = q * (1 - f);
                    v = t;
                    w = q * (1 - g);
                }
                let x = d.a();
                let y = new PathGeometry();
                let z = new PathFigure();
                z._startPoint = { $type: Point_$type, x: t, y: u };
                z._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: v, y: w };
                    return $ret;
                })()));
                y.c.add(z);
                x.ak = y;
                x._stroke = h;
                x.ac = i;
                this.bi.add(x);
            }
            for (let aa = 0; aa < k.length; aa++) {
                let ab, ac, ad, ae;
                if (this.as == 1) {
                    ab = b.left + q * l;
                    ac = r - k[aa];
                    ad = b.left + q * m;
                    ae = ac;
                }
                else {
                    ab = k[aa];
                    ac = q * (1 - l);
                    ad = ab;
                    ae = q * (1 - m);
                }
                let af = d.a();
                let ag = new PathGeometry();
                let ah = new PathFigure();
                ah._startPoint = { $type: Point_$type, x: ab, y: ac };
                ah._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: ad, y: ae };
                    return $ret;
                })()));
                ag.c.add(ah);
                af.ak = ag;
                af._stroke = n;
                af.ac = o;
                this.bi.add(af);
            }
            d.f = false;
        }
        fw(a) {
            let b = this.h8;
            let c = a.c;
            let d = c.e;
            let e = c.d;
            let f = c.g;
            let g = c.h;
            let h = c.f;
            let i = c.c;
            let j = c.n;
            let k = this.ay;
            k.f = true;
            for (let l = 0; l < this.bg.count; l++) {
                k.n(this.bg._inner[l]);
            }
            this.bg.clear();
            let m = c.ab;
            let n = this.c1();
            let o = this.c2();
            for (let p = 0; p < e.length; p++) {
                let q, r;
                if (this.as == 1) {
                    q = b.left + n * j;
                    r = b.top + o - d[p];
                }
                else {
                    q = b.left + d[p];
                    r = b.top + n * (1 - j);
                }
                let s = k.a();
                s.ak = e[p];
                this.view.bt(s, m);
                let t = h[p];
                let u = i[p];
                let v = f[p];
                let w = g[p];
                this.view.bk(s, q + v, r + w);
                this.bg.add(s);
            }
            k.f = false;
        }
        fy(a) {
            let b = a.c;
            let c = this.a0;
            c.f = true;
            for (let d = 0; d < this.bh.count; d++) {
                c.n(this.bh._inner[d]);
            }
            this.bh.clear();
            let e = this.cm();
            let f = this.c2();
            let g = this.h2();
            let h = this.view.cm();
            if (isNaN_(b.s) || isNaN_(b.t) || isNaN_(b.u) || isNaN_(b.r)) {
                h.ak = null;
            }
            else {
                let i = this.cp();
                h.ak = b.ae(g, e, i, this.as);
                h._fill = this.hz;
                h._stroke = this.h0;
                h.ac = this.ct;
            }
            for (let j = 0; j < b.m.count; j++) {
                let k = b.m._inner[j];
                let l = c.a();
                l.ak = k.k(g, e, f, this.as);
                l._fill = k.i;
                l._stroke = k.j;
                l.ac = k.h;
                this.bh.add(l);
            }
            this.view.bs(this.bh);
            c.f = false;
        }
        fv(a) {
            let b = this.h7;
            let c = this.view.ck();
            let d = a.a;
            let e = this.as == 0 ? b.height : b.width;
            let f = this.as == 0 ? b.width : b.height;
            let g = d.g(e, f, this.as);
            c.ak = g;
            c._fill = d.e;
            c._stroke = d.f;
            c.ac = d.c;
        }
        bl(a) {
            let b = new List$1(Point_$type, 0);
            for (let c = 0; c < a.count; c++) {
                b.add({ $type: Point_$type, x: a._inner[c].x, y: a._inner[c].y });
            }
            return b;
        }
        fx(a) {
            this.bk = null;
            let b = this.view.cl();
            let c = this.c0;
            if (isNaN_(c) || c < this.bs || c > this.br) {
                b.ak = null;
                return;
            }
            let d = a.c;
            let e = d.af;
            let f = this.cm();
            let g = this.c2();
            let h = f;
            let i = e.p;
            let j = 0;
            if (this.as == 1) {
                i = this.h8.left;
                j = g - e.p;
            }
            b.ak = e.t(h, i, j);
            b._fill = e.r;
            b._stroke = e.s;
            b.ac = e.o;
            let k = new PathVisualData(1, "needle", b);
            let l = k.getPoints(new GetPointsSettings());
            if (l.count > 0) {
                this.bk = this.bl(l._inner[0]);
                let m = 1.7976931348623157E+308, n = 1.7976931348623157E+308;
                let o = -1.7976931348623157E+308, p = -1.7976931348623157E+308;
                for (let q = 0; q < this.bk.count; q++) {
                    m = this.bk._inner[q].x < m ? this.bk._inner[q].x : m;
                    n = this.bk._inner[q].y < n ? this.bk._inner[q].y : n;
                    o = this.bk._inner[q].x > o ? this.bk._inner[q].x : o;
                    p = this.bk._inner[q].y > p ? this.bk._inner[q].y : p;
                }
                this.h4 = new Rect(2, { $type: Point_$type, x: m, y: n }, { $type: Point_$type, x: o, y: p });
            }
        }
        fk(a, b) {
            this.a5 = true;
            this.view.br();
        }
        fc(a, b) {
            this.a5 = true;
            this.view.br();
        }
        cm() {
            if (this.as == 0) {
                return this.ba ? this.h9.height : this.h8.height;
            }
            return this.ba ? this.h9.width : this.h8.width;
        }
        cp() {
            if (this.as == 0) {
                return this.h9.width * (this.cn - this.cs);
            }
            return this.h9.height * (this.cn - this.cs);
        }
        c1() {
            if (this.as == 0) {
                return this.h9.height;
            }
            return this.h9.width;
        }
        c2() {
            if (this.as == 0) {
                return this.h9.width;
            }
            return this.h9.height;
        }
        cr() {
            let a = this.cs;
            if (this.as == 0) {
                if (this.a8) {
                    a = 1 - this.cn;
                }
                return this.h9.left + this.h9.width * a;
            }
            if (this.a8) {
                a = 1 - this.cn;
            }
            return this.h9.top + this.h9.height * a;
        }
        h2() {
            let a = this.h8.left;
            if (this.ba) {
                a = 0;
            }
            let b = this.cs;
            if (this.as == 0) {
                if (this.a8) {
                    b = 1 - this.cn;
                }
                return { $type: Point_$type, x: a + this.h8.width * b, y: this.h8.top };
            }
            if (!this.a8) {
                b = 1 - this.cn;
            }
            return { $type: Point_$type, x: a, y: this.h8.top + this.h8.height * b };
        }
        fi(a, b, c) {
            switch (a) {
                case XamLinearGauge.$$p[0]:
                case XamLinearGauge.$$p[3]:
                case XamLinearGauge.$$p[44]:
                case XamLinearGauge.$$p[48]:
                case XamLinearGauge.$$p[52]:
                case XamLinearGauge.$$p[19]:
                case XamLinearGauge.$$p[25]:
                case XamLinearGauge.$$p[35]:
                    this.view.a8(a, b, c);
                    break;
                case XamLinearGauge.$$p[39]:
                    this.view.bd(b, c);
                    break;
                case XamLinearGauge.$$p[42]:
                    this.view.be(b, c);
                    break;
                case "PixelScalingRatio":
                    if (isNaN_(DeviceUtils.a(this.cj))) {
                        this.bt = 1;
                    }
                    else {
                        this.bt = DeviceUtils.a(this.cj);
                    }
                    break;
                case "ActualPixelScalingRatio":
                    this.view.bi();
                    break;
            }
            switch (a) {
                case XamLinearGauge.$$p[11]:
                case XamLinearGauge.$$p[12]:
                    if (this.dk != null) {
                        this.aj = new BindingFormatter();
                        this.aj.j = this.dk;
                        this.aj.d = this.ag;
                    }
                    else {
                        this.aj = null;
                    }
                    this.a5 = true;
                    this.view.br();
                    break;
                case XamLinearGauge.$$p[60]:
                    if (this.valueChanged != null) {
                        this.valueChanged(this, new DoubleValueChangedEventArgs(b, c));
                    }
                    this.a5 = true;
                    this.view.br();
                    break;
                case XamLinearGauge.$$p[59]:
                    this.av.r = this.c4;
                    this.view.br();
                    break;
                case "TransitionProgress":
                    if (this.cz >= 1) {
                        this.av.w();
                        let d = this.an;
                        this.an = this.ao;
                        this.ao = d;
                        this.fm();
                        this.fn();
                        this.fo();
                        this.fl();
                        this.fv(this.an);
                        this.fy(this.an);
                        this.fx(this.an);
                        this.fz(this.an);
                        this.fw(this.an);
                    }
                    this.am.d(this.cz, this.ao, this.an);
                    this.fv(this.am);
                    this.fy(this.am);
                    this.fx(this.am);
                    this.fz(this.am);
                    this.fw(this.am);
                    this.view.as();
                    break;
                case XamLinearGauge.$$p[25]:
                case XamLinearGauge.$$p[30]:
                case XamLinearGauge.$$p[24]:
                case XamLinearGauge.$$p[36]:
                case XamLinearGauge.$$p[27]:
                case XamLinearGauge.$$p[32]:
                case XamLinearGauge.$$p[28]:
                case XamLinearGauge.$$p[33]:
                case XamLinearGauge.$$p[26]:
                case XamLinearGauge.$$p[31]:
                case XamLinearGauge.$$p[29]:
                case XamLinearGauge.$$p[34]:
                case XamLinearGauge.$$p[37]:
                case XamLinearGauge.$$p[35]:
                case XamLinearGauge.$$p[0]:
                case XamLinearGauge.$$p[3]:
                case XamLinearGauge.$$p[4]:
                case XamLinearGauge.$$p[1]:
                case XamLinearGauge.$$p[2]:
                case XamLinearGauge.$$p[44]:
                case XamLinearGauge.$$p[48]:
                case XamLinearGauge.$$p[50]:
                case XamLinearGauge.$$p[46]:
                case XamLinearGauge.$$p[47]:
                case XamLinearGauge.$$p[52]:
                case XamLinearGauge.$$p[19]:
                case XamLinearGauge.$$p[39]:
                case XamLinearGauge.$$p[42]:
                case XamLinearGauge.$$p[40]:
                case XamLinearGauge.$$p[41]:
                case XamLinearGauge.$$p[7]:
                case XamLinearGauge.$$p[13]:
                case XamLinearGauge.$$p[10]:
                case XamLinearGauge.$$p[14]:
                case XamLinearGauge.$$p[15]:
                case XamLinearGauge.$$p[54]:
                case XamLinearGauge.$$p[55]:
                case XamLinearGauge.$$p[56]:
                case XamLinearGauge.$$p[53]:
                case XamLinearGauge.$$p[57]:
                case XamLinearGauge.$$p[22]:
                case XamLinearGauge.$$p[21]:
                case XamLinearGauge.$$p[20]:
                case XamLinearGauge.$$p[23]:
                    this.a5 = true;
                    this.view.br();
                    break;
                case XamLinearGauge.$$p[43]:
                    let e = b;
                    let f = c;
                    if (e != null) {
                        let g = e;
                        g.collectionChanged = delegateRemove(g.collectionChanged, runOn(this, this.fs));
                    }
                    if (f != null) {
                        let h = f;
                        h.collectionChanged = delegateCombine(h.collectionChanged, runOn(this, this.fs));
                    }
                    this.a5 = true;
                    this.view.br();
                    break;
                case XamLinearGauge.$$p[38]:
                case XamLinearGauge.$$p[9]:
                case XamLinearGauge.$$p[18]:
                case XamLinearGauge.$$p[16]:
                case XamLinearGauge.$$p[45]:
                case XamLinearGauge.$$p[49]:
                    this.bs = Math.min(this.b4, this.b3);
                    this.br = Math.max(this.b4, this.b3);
                    let i = this.cr();
                    this.ar = new LinearGraphScaler(this.bs, this.br, i, i + this.cp(), this.a8);
                    this.a5 = true;
                    this.view.br();
                    break;
                case XamLinearGauge.$$p[5]:
                case XamLinearGauge.$$p[6]:
                    this.view.b1();
                    this.a5 = true;
                    this.view.br();
                    break;
            }
            this.fj(a);
        }
        fs(a, b) {
            if (b.oldItems != null) {
                for (let c of fromEn(b.oldItems)) {
                    c.propertyChanged = delegateRemove(c.propertyChanged, runOn(this, this.fr));
                }
            }
            if (b.newItems != null) {
                for (let d of fromEn(b.newItems)) {
                    d.propertyChanged = delegateCombine(d.propertyChanged, runOn(this, this.fr));
                }
            }
            this.a5 = true;
            this.view.br();
        }
        fr(a, b) {
            this.a5 = true;
            this.view.br();
        }
        e9(a, b) {
            this.a5 = true;
            this.view.br();
        }
        refresh() {
            this.a5 = true;
            this.view.br();
        }
        ax() {
            return FontUtil.toFontInfo(this.view.ah, this.dd);
        }
        get cj() {
            return this.bp;
        }
        set cj(a) {
            let b = this.bp;
            this.bp = a;
            this.fi("PixelScalingRatio", b, this.bp);
        }
        get bt() {
            return this.bo;
        }
        set bt(a) {
            let b = this.bo;
            this.bo = a;
            this.fi("ActualPixelScalingRatio", b, this.bo);
        }
    }
    XamLinearGauge.$t = /*@__PURE__*/ markType(XamLinearGauge, 'XamLinearGauge', Control.$, [INotifyPropertyChanged_$type]);
    XamLinearGauge.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, XamLinearGauge, 'fi', ['BackingBrush:hs:f3', [Brush.$, null], 'BackingInnerExtent:bu:f4', [1, 0], 'BackingOuterExtent:bv:f5', [1, 1], 'BackingOutline:ht:f6', [Brush.$, null], 'BackingStrokeThickness:bw:f7', [1, 2], 'FontBrush:hu:f8', [Brush.$, null], 'Font:dd:f9', [2, null], 'Interval:by:ga', [1, NaN], 'IsNeedleDraggingEnabled:a7:gb', [0, false], 'IsScaleInverted:a8:gc', [0, false], 'LabelExtent:bz:gd', [1, 0], 'LabelFormat:dk:ge', [2, null], 'LabelFormatSpecifiers:ag:gf', [Array_$type, null], 'LabelInterval:b0:gg', [1, NaN], 'LabelsPostInitial:b1:gh', [1, 0], 'LabelsPreTerminal:b2:gi', [1, 0], 'MaximumValue:b3:gj', [1, 100], 'MergeViewPorts:ba:gk', [0, false], 'MinimumValue:b4:gl', [1, 0], 'MinorTickBrush:hw:gm', [Brush.$, null], 'MinorTickCount:b5:gn', [1, 4], 'MinorTickEndExtent:b6:go', [1, 0.35], 'MinorTickStartExtent:b7:gp', [1, 0.05], 'MinorTickStrokeThickness:b8:gq', [1, 1], 'NeedleBreadth:b9:gr', [1, 6], 'NeedleBrush:hx:gs', [Brush.$, null], 'NeedleInnerBaseWidth:ca:gt', [1, NaN], 'NeedleInnerExtent:cb:gu', [1, NaN], 'NeedleInnerPointExtent:cc:gv', [1, NaN], 'NeedleInnerPointWidth:cd:gw', [1, NaN], 'NeedleName:d5:gx', [2, null], 'NeedleOuterBaseWidth:ce:gy', [1, NaN], 'NeedleOuterExtent:cf:gz', [1, NaN], 'NeedleOuterPointExtent:cg:g0', [1, NaN], 'NeedleOuterPointWidth:ch:g1', [1, NaN], 'NeedleOutline:hy:g2', [Brush.$, null], 'NeedleShape:ap:g3', [LinearGraphNeedleShape_$type, /*@__PURE__*/ enumGetBox(LinearGraphNeedleShape_$type, 3)], 'NeedleStrokeThickness:ci:g4', [1, 1], 'Orientation:as:g5', [LinearScaleOrientation_$type, /*@__PURE__*/ enumGetBox(LinearScaleOrientation_$type, 0)], 'RangeBrushes:ah:g6', [BrushCollection.$, null], 'RangeInnerExtent:ck:g7', [1, 0.05], 'RangeOuterExtent:cl:g8', [1, 0.65], 'RangeOutlines:ai:g9', [BrushCollection.$, null], 'Ranges::ha', [LinearGraphRangeCollection.$, null], 'ScaleBrush:hz:hb', [Brush.$, null], 'ScaleEndExtent:cn:hc', [1, 0.95], 'ScaleInnerExtent:co:hd', [1, 0.05], 'ScaleOuterExtent:cq:he', [1, 0.65], 'ScaleOutline:h0:hf', [Brush.$, null], 'ScaleStartExtent:cs:hg', [1, 0.05], 'ScaleStrokeThickness:ct:hh', [1, 1], 'ShowToolTipTimeout:c3:hi', [1, 500], 'TickBrush:h1:hj', [Brush.$, null], 'TickEndExtent:cu:hk', [1, 0.65], 'TicksPostInitial:cv:hl', [1, 0], 'TicksPreTerminal:cw:hm', [1, 0], 'TickStartExtent:cx:hn', [1, 0.05], 'TickStrokeThickness:cy:ho', [1, 2], 'ToolTip::hp', [4, null], 'TransitionDuration:c4:hq', [1, 0], 'Value:c0:hr', [1, NaN]]);
    return XamLinearGauge;
})();
/**
 * @hidden
 */
let XamLinearGaugeView = /*@__PURE__*/ (() => {
    class XamLinearGaugeView extends Base {
        constructor(a) {
            super();
            this.ap = 0;
            this.ao = 0;
            this.m = null;
            this.i = null;
            this.aj = null;
            this.p = null;
            this.ah = null;
            this.aa = null;
            this.z = null;
            this.y = null;
            this.ab = null;
            this.ci = null;
            this.cj = null;
            this.ch = null;
            this.ca = null;
            this.cb = null;
            this.b7 = null;
            this.b8 = null;
            this.cc = null;
            this.cd = null;
            this.ce = null;
            this.b9 = null;
            this.c = null;
            this.d = null;
            this.e = null;
            this.f = null;
            this.q = false;
            this.v = null;
            this.a = ["needle", "backing", "scale", "tick", "minortick", "label"];
            this.u = false;
            this.t = false;
            this.ai = null;
            this.k = null;
            this.ak = 0;
            this.am = 0;
            this.aq = null;
            this.an = -1;
            this.cf = null;
            this.al = 0;
            this.x = null;
            this.b6 = ((() => {
                let $ret = new Brush();
                $ret.fill = "black";
                return $ret;
            })());
            this.r = false;
            this.n = null;
            this.b5 = null;
            this.ac = 0;
            this.ad = 1;
            this.m = a;
            this.v = new Dictionary$2(String_$type, Dictionary$2.$.specialize(String_$type, Brush.$), 0);
            this.ci = new Path();
            this.cj = new Path();
            this.ch = new Path();
            this.aa = new List$1(Path.$, 0);
            this.z = new List$1(Path.$, 0);
            this.y = new List$1(TextBlock.$, 0);
            this.ab = new List$1(TextBlock.$, 0);
        }
        a3() {
            let a = this.m.cj;
            let b = this.m.bt;
            if (!isNaN_(a) && a != 0) {
                return;
            }
            if (window.devicePixelRatio != undefined && window.devicePixelRatio != b) {
                this.m.bt = window.devicePixelRatio;
            }
        }
        bc() {
            this.k = new LinearGraphTooltipDataContext();
            this.al = this.m.c3;
            this.a3();
        }
        s() {
            return true;
        }
        cl() {
            return this.ci;
        }
        cm() {
            return this.cj;
        }
        ck() {
            return this.ch;
        }
        a1() {
            this.q = true;
            let a = ["#778899", "#EBEDEF", "#e0e0e0", "#617583", "rgba(100,107,114,.74)", "rgba(100,107,114,.74)"];
            let b = ["#778899", "#B2B9C0", "#e0e0e0", null, null, null];
            let c = ((() => {
                let $ret = new List$1(Array_$type, 0);
                $ret.add(a);
                $ret.add(b);
                return $ret;
            })());
            this.v.clear();
            let d = this.a.length;
            for (let e = 0; e < d; e++) {
                let f = this.a[e];
                let g = "ui-lineargauge-" + f;
                let h = "ui-lineargauge-" + f + "-fill";
                let i = "ui-lineargauge-" + f + "-outline";
                let j;
                if (!((() => { let k = XamLinearGaugeView.w.tryGetValue(h, j); j = k.p1; return k.ret; })())) {
                    j = BrushUtil.j(h, g, "background-color", this.ah, a[e]);
                    XamLinearGaugeView.w.addItem(h, j);
                }
                let k;
                if (!((() => { let l = XamLinearGaugeView.w.tryGetValue(i, k); k = l.p1; return l.ret; })())) {
                    k = BrushUtil.j(i, g, "border-top-color", this.ah, b[e]);
                    XamLinearGaugeView.w.addItem(i, k);
                }
                let l = new Dictionary$2(String_$type, Brush.$, 0);
                l.item("fill", j);
                l.item("outline", k);
                this.v.item(this.a[e], l);
            }
            this.b0();
            if (XamLinearGaugeView.g == null || XamLinearGaugeView.h == null) {
                let m = BrushUtil.f("ui-lineargauge-range-fill-palette-", "ui-lineargauge-range-outline-palette-", "ui-lineargauge-range-palette-", this.ah, XamLinearGaugeView.g, XamLinearGaugeView.h, ["#216E99", "#216E99", "#44acd6", "#44acd6", "#cecece", "#cecece"]);
                XamLinearGaugeView.g = m.p4;
                XamLinearGaugeView.h = m.p5;
            }
            this.c = XamLinearGaugeView.g;
            this.d = XamLinearGaugeView.h;
            if (this.e == null) {
                this.m.ah = this.c;
            }
            if (this.f == null) {
                this.m.ai = this.d;
            }
            this.q = false;
        }
        b0() {
            this.q = true;
            let a = this.a.length;
            for (let b = 0; b < a; b++) {
                let c = this.a[b];
                this.bz(c, this.v.item(c));
            }
            this.q = false;
        }
        bz(a, b) {
            let c = b.item("fill");
            let d = b.item("outline");
            switch (a) {
                case "needle":
                    if (this.ca == null) {
                        this.m.hx = c;
                    }
                    if (this.cb == null) {
                        this.m.hy = d;
                    }
                    break;
                case "scale":
                    if (this.cc == null) {
                        this.m.hz = c;
                    }
                    if (this.cd == null) {
                        this.m.h0 = d;
                    }
                    break;
                case "backing":
                    if (this.b7 == null) {
                        this.m.hs = c;
                    }
                    if (this.b8 == null) {
                        this.m.ht = d;
                    }
                    break;
                case "tick":
                    if (this.ce == null) {
                        this.m.h1 = c;
                    }
                    break;
                case "minortick":
                    if (this.b9 == null) {
                        this.m.hw = c;
                    }
                    break;
                case "label":
                    this.b6 = c;
                    break;
            }
        }
        a8(a, b, c) {
            let d = b;
            let e = c;
            if (!this.q) {
                switch (a) {
                    case XamLinearGauge.$$p[25]:
                        this.ca = e;
                        break;
                    case XamLinearGauge.$$p[35]:
                        this.cb = e;
                        break;
                    case XamLinearGauge.$$p[0]:
                        this.b7 = e;
                        break;
                    case XamLinearGauge.$$p[3]:
                        this.b8 = e;
                        break;
                    case XamLinearGauge.$$p[44]:
                        this.cc = e;
                        break;
                    case XamLinearGauge.$$p[48]:
                        this.cd = e;
                        break;
                    case XamLinearGauge.$$p[52]:
                        this.ce = e;
                        break;
                    case XamLinearGauge.$$p[19]:
                        this.b9 = e;
                        break;
                }
                if (e == null) {
                    this.b0();
                }
            }
        }
        bd(a, b) {
            if (!this.q) {
                this.e = b;
                if (this.e == null) {
                    this.m.ah = this.c;
                }
            }
        }
        be(a, b) {
            if (!this.q) {
                this.f = b;
                if (this.f == null) {
                    this.m.ai = this.d;
                }
            }
        }
        b(a, b) {
            this.ah.startCSSQuery();
            for (let c = 0; c < b.length; c++) {
                b[c] = this.ah.getCssDefaultPropertyValue(a, b[c]);
            }
            this.ah.endCSSQuery();
            return b;
        }
        bv() {
            this.a1();
            this.b1();
            this.br();
        }
        cg(a) {
            let b = CanvasGestureDOMEventProxy.cy(this.ah.rootWrapper);
            return { $type: Point_$type, x: a.x - b.left, y: a.y - b.top };
        }
        bu(a, b, c, d) {
            this.cf = a;
            this.an = c;
            this.aq = d;
            this.bq();
            if (this.ah != null) {
                this.am = this.ah.setTimeout(runOn(this, this.b2), this.al);
            }
            else {
                this.am = window.setTimeout(runOn(this, this.b2), this.al);
            }
            this.t = true;
        }
        a2() {
            if (this.t) {
                if (this.ah != null) {
                    this.ah.clearTimeout(this.am);
                }
                else {
                    window.clearTimeout(this.am);
                }
                this.t = false;
            }
            if (this.u) {
                let a = this.m.toolTip;
                if (this.ah != null) {
                    this.ah.clearTimeout(this.ak);
                }
                else {
                    window.clearTimeout(this.ak);
                }
                a.hide();
                this.u = false;
                this.k = null;
            }
            this.al = this.m.c3;
        }
        bq() {
            if (this.t) {
                if (this.ah != null) {
                    this.ah.clearTimeout(this.am);
                }
                else {
                    window.clearTimeout(this.am);
                }
            }
            if (this.u) {
                let a = this.m.toolTip;
                if (this.ah != null) {
                    this.ah.clearTimeout(this.ak);
                }
                else {
                    window.clearTimeout(this.ak);
                }
                a.hide();
                this.u = false;
                this.al = intDivide(this.m.c3, 2);
            }
        }
        b2() {
            if (this.t) {
                if (this.ah != null) {
                    this.ah.clearTimeout(this.am);
                }
                else {
                    window.clearTimeout(this.am);
                }
                this.t = false;
            }
            let a = this.an;
            let b = this.aq;
            let c = this.cf;
            if (this.ah != null) {
                this.ak = this.ah.setTimeout(runOn(this, this.a2), 10 * this.m.c3);
            }
            else {
                this.ak = window.setTimeout(runOn(this, this.a2), 10 * this.m.c3);
            }
            let d = this.m.ranges._inner[a];
            if (this.ai != this.m.toolTip) {
                if (this.ai != null) {
                    this.ai.remove();
                }
                this.ai = this.m.toolTip;
                this.ai.setStyleProperty("z-index", "10000");
                this.ai.setStyleProperty("position", "absolute");
                this.ah.append(this.ai);
            }
            this.k = this.j(b, a);
            let context_ = this.k;
            let tooltip_ = this.ai;
            let tooltipType_ = b;
            if (tooltip_.updateToolTip) {
                tooltip_.updateToolTip(context_, tooltipType_);
            }
            ;
            let e = this.ai.findByClass(".ui-tooltip-container");
            if (e != null && e.length > 0) {
                e[0].setAttribute("style", null);
            }
            let f = "ui-simple-default-tooltip-content";
            let g = this.ai.findByClass("." + f);
            if (g != null && g.length > 0) {
                let h = ["border-top-color", "border-top-width", "border-top-style", "border-top-left-radius", "background-color", "padding-top", "font-weight"];
                let i = ["border-color", "border-width", "border-style", "border-radius", "background-color", "padding", "font-weight"];
                let j = ((() => {
                    let $ret = new List$1(String_$type, 0);
                    $ret.add(this.k.brush.color.colorString);
                    $ret.add("2px");
                    $ret.add("solid");
                    $ret.add("4px");
                    $ret.add("rgba(230, 230, 230, 0.74)");
                    $ret.add("4px");
                    $ret.add("bold");
                    return $ret;
                })());
                let k = new Dictionary$2(String_$type, String_$type, 0);
                let l = new Array(h.length);
                arrayCopy1(h, 0, l, 0, h.length);
                this.b(f, l);
                for (let m = 0; m < l.length; m++) {
                    this.ai.setStyleProperty(i[m], (l[m] == null) ? j._inner[m] : l[m]);
                }
            }
            this.ai.setStyleProperty("top", (c.y + 15).toString() + "px").setStyleProperty("left", (c.x + 15).toString() + "px");
            this.ai.show();
            this.u = true;
        }
        j(a, b) {
            let c = new LinearGraphTooltipDataContext();
            switch (a) {
                case "range":
                    let d = this.m.ranges._inner[b];
                    c.item = d;
                    c.itemName = d.u;
                    c.label = d.u + ": " + d.o.toString() + "-" + d.j.toString();
                    let e = d.an;
                    let f = d.ao;
                    c.brush = e != null ? e : this.m.hv(b, this.c);
                    c.outline = f != null ? f : this.m.hv(b, this.d);
                    c.thickness = d.p;
                    break;
                case "needle":
                    c.item = this.m.c0;
                    c.itemName = this.m.d5;
                    c.label = this.m.d5 != null ? this.m.d5 + ": " + this.m.c0.toString() : this.m.c0.toString();
                    c.brush = this.m.hx;
                    c.outline = this.m.hy;
                    c.thickness = this.m.ci;
                    break;
            }
            return c;
        }
        a9(a) {
            if (a == null) {
                this.aj = null;
                this.ah = null;
                this.ai = null;
                this.p = null;
                this.at();
                return;
            }
            let b = a;
            this.ah = b;
            this.m.av.u(this.ah);
            this.ah.rootWrapper.addClass("ui-lineargauge-container");
            this.ad = (isNaN_(this.m.cj) ? this.m.bt : this.m.cj);
            let c = this.ad;
            let d = Math.round(b.rootWrapper.width());
            let e = Math.round(b.rootWrapper.height());
            let f = d * c;
            let g = e * c;
            this.ah.rootWrapper.setStyleProperty("position", "relative");
            let h = this.ah.createElement("canvas");
            h.setStyleProperty("position", "absolute");
            this.ah.append(h);
            this.ap = f;
            this.ao = g;
            h.setAttribute("width", f.toString());
            h.setAttribute("height", g.toString());
            h.setStyleProperty("width", d.toString() + "px");
            h.setStyleProperty("height", e.toString() + "px");
            this.m.h9 = new Rect(0, 0, 0, d, e);
            this.m.h7 = new Rect(0, 0, 0, d, e);
            this.aj = h;
            let i = this.ah.get2DCanvasContext(this.aj);
            this.p = new RenderingContext(new CanvasViewRenderer(), i);
            this.a1();
            this.b1();
            this.p.ac(this.n);
            this.at();
            if (TypeRegistrar.isRegistered("CanvasGestureDOMEventProxy")) {
                this.i = typeCast(EventProxy.$, TypeRegistrar.create("CanvasGestureDOMEventProxy", this.ah.rootWrapper, this.ah, false));
            }
            if (this.i != null) {
                let j = this.i;
                j.onMouseOver = delegateCombine(j.onMouseOver, runOn(this, this.ay));
                let k = this.i;
                k.onMouseLeave = delegateCombine(k.onMouseLeave, runOn(this, this.ax));
                let l = this.i;
                l.onContactStarted = delegateCombine(l.onContactStarted, runOn(this, this.aw));
                let m = this.i;
                m.onContactMoved = delegateCombine(m.onContactMoved, runOn(this, this.av));
                let n = this.i;
                n.onContactCompleted = delegateCombine(n.onContactCompleted, runOn(this, this.au));
            }
            this.bp();
        }
        au(a, b) {
            if (this.m != null) {
                this.m.onMouseUp(a);
            }
        }
        av(a, b) {
            if (this.m != null) {
                this.m.onMouseMove(a, b);
            }
        }
        aw(a, b) {
            if (this.m != null) {
                this.m.onMouseDown(a, b);
            }
        }
        ay(a, b, c) {
            if (this.m != null) {
                this.m.onMouseOver(a, b, c);
            }
        }
        ax(a) {
            if (this.m != null) {
                this.m.onMouseLeave();
            }
        }
        at() {
            if (this.i != null) {
                let a = this.i;
                a.onMouseOver = delegateRemove(a.onMouseOver, runOn(this, this.ay));
                let b = this.i;
                b.onMouseLeave = delegateRemove(b.onMouseLeave, runOn(this, this.ax));
                let c = this.i;
                c.onContactStarted = delegateRemove(c.onContactStarted, runOn(this, this.aw));
                let d = this.i;
                d.onContactMoved = delegateRemove(d.onContactMoved, runOn(this, this.av));
                let e = this.i;
                e.onContactCompleted = delegateRemove(e.onContactCompleted, runOn(this, this.au));
                this.i.aq();
            }
        }
        ba() {
            this.a3();
            let a = Math.round(this.ah.rootWrapper.width());
            let b = Math.round(this.ah.rootWrapper.height());
            this.m.h9 = new Rect(0, 0, 0, a, b);
            this.m.h7 = new Rect(0, 0, 0, a, b);
            if (this.i != null) {
                this.i.bf = this.m.h9;
            }
        }
        as() {
            this.bp();
        }
        bs(a) {
            this.x = a;
        }
        bp() {
            let a = this.m.h9.width;
            let b = this.m.h9.height;
            let c = a * this.ad;
            let d = b * this.ad;
            if (this.ap != a || this.ao != b) {
                this.aj.setAttribute("width", c.toString());
                this.aj.setAttribute("height", d.toString());
                this.aj.setStyleProperty("width", a.toString() + "px");
                this.aj.setStyleProperty("height", b.toString() + "px");
                this.ap = truncate(Math.round(c));
                this.ao = truncate(Math.round(d));
            }
            if (this.p.d && this.ad != 1) {
                this.p.z();
                this.p.aa(this.ad, this.ad);
            }
            this.p.k(this.m.h9.left, this.m.h9.top, this.m.h9.width, this.m.h9.height);
            this.p.s(this.ch);
            this.p.s(this.cj);
            if (this.x != null) {
                for (let e = 0; e < this.x.count; e++) {
                    this.p.s(this.x._inner[e]);
                }
            }
            for (let f = 0; f < this.y.count; f++) {
                this.p.ac(this.n);
                this.p.w(this.y._inner[f]);
            }
            for (let g = 0; g < this.z.count; g++) {
                this.p.s(this.z._inner[g]);
            }
            this.p.s(this.ci);
            if (this.p.d && this.ad != 1) {
                this.p.y();
            }
        }
        b1() {
            if (this.m.dd != null) {
                this.n = this.m.ax();
            }
            else {
                this.n = FontUtil.getFont(this.ah);
            }
            this.ac = this.ae(this.n);
            if (this.m.hu == null) {
                let a = this.ah.rootWrapper.getStyleProperty("color");
                if (stringIsNullOrEmpty(a) == false) {
                    this.b5 = new Brush();
                    this.b5._fill = a;
                    this.m.hu = this.b5;
                }
            }
            if (this.p != null) {
                this.p.ac(this.n);
            }
        }
        af(a) {
            let b = typeCast(TextBlock.$, a);
            if (b != null && b.ak != null) {
                return this.p.e(b) + 0;
            }
            return 0;
        }
        cp(a) {
            if (isNaN_(this.ac)) {
                this.ac = this.ae(null);
            }
            let b = this.af(a);
            let c = this.ac;
            return new Size(1, b, c);
        }
        bt(a, b) {
            if (b != null) {
                a.am = b;
            }
            else {
                a.am = this.b6;
            }
        }
        bk(a, b, c) {
            a.n = b;
            a.o = c;
        }
        bj(a, b) {
        }
        bl(a, b) {
        }
        ae(a) {
            return FontUtil.getCurrentFontHeight(this.ah, a);
        }
        br() {
            if (!this.r) {
                this.r = true;
                window.setTimeout(runOn(this, this.ar), 0);
            }
        }
        ar() {
            if (this.r) {
                this.r = false;
                this.m.e4();
            }
        }
        flush() {
            if (this.r) {
                this.ar();
            }
        }
        o(a, b) {
            return FontUtil.getFontInfo(this.ah, a, b);
        }
        az(a) {
            a.scalePath = new PathVisualData(1, "Scale", this.cj);
            a.needlePath = new PathVisualData(1, "Needle", this.ci);
            a.backingPath = new PathVisualData(1, "Backing", this.ch);
            let b = this.n;
            for (let c of fromEnum(this.y)) {
                if (c._visibility == 0) {
                    let d = this.o(c, b);
                    let e = new LinearGraphScaleLabelVisualData();
                    e.labelValue = c.ak;
                    e.labelPosition = PointData.b({ $type: Point_$type, x: c.n, y: c.o });
                    e.labelSize = SizeData.b(this.cp(c));
                    e.appearance = AppearanceHelper.c(c, d);
                    a.scaleLabels.add(e);
                }
            }
            for (let f of fromEnum(this.z)) {
                if (f._visibility == 0) {
                    let g = new LinearGraphScaleTickmarkVisualData();
                    g.tickPath = new PathVisualData(1, "tickmarks", f);
                    a.scaleTickmarks.add(g);
                }
            }
            for (let h of fromEnum(this.x)) {
                if (h._visibility == 0) {
                    let i = new LinearGraphRangeVisualData();
                    let j = new PathVisualData(1, "range", h);
                    i.rangePath = j;
                    a.ranges.add(i);
                }
            }
        }
        a7() {
            this.a3();
            if (this.i != null) {
                this.i.ap(this.ah.rootWrapper, "");
            }
        }
        bb() {
            if (this.i != null) {
                this.i.bb(this.ah.rootWrapper, "");
            }
        }
        bm(a) {
            a._visibility = 0;
        }
        bn(a) {
            a._visibility = 1;
        }
        bo(a) {
            this.aa.remove(a);
        }
        co() {
            let a = new Path();
            this.aa.add(a);
            return a;
        }
        bw(a) {
            a._visibility = 0;
        }
        bx(a) {
            a._visibility = 1;
        }
        by(a) {
            this.ab.remove(a);
        }
        b4() {
            let a = new TextBlock();
            this.ab.add(a);
            return a;
        }
        bf(a) {
            a._visibility = 0;
        }
        bg(a) {
            a._visibility = 1;
        }
        bh(a) {
            this.z.remove(a);
        }
        cn() {
            let a = new Path();
            this.z.add(a);
            return a;
        }
        a4(a) {
            a._visibility = 0;
        }
        a5(a) {
            a._visibility = 1;
        }
        a6(a) {
            this.y.remove(a);
        }
        b3() {
            let a = new TextBlock();
            this.y.add(a);
            return a;
        }
        l() {
            if (this.k == null) {
                return null;
            }
            return ((() => {
                let $ret = new ToolTipInfo();
                $ret.b = this.an;
                $ret.d = this.cf;
                $ret.c = this.aq;
                $ret.a = this.k;
                return $ret;
            })());
        }
        bi() {
            this.ad = this.m.bt;
        }
    }
    XamLinearGaugeView.$t = /*@__PURE__*/ markType(XamLinearGaugeView, 'XamLinearGaugeView');
    XamLinearGaugeView.w = /*@__PURE__*/ new Dictionary$2(String_$type, Brush.$, 0);
    XamLinearGaugeView.g = null;
    XamLinearGaugeView.h = null;
    return XamLinearGaugeView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

let defaultFont$1 = "Verdana, \"Segoe UI\", Arial, \"Myriad Pro\", sans-serif";
let LinearGaugeStylingDefaults = {
    //"ui-lineargauge-backing": {
    //    "background-color": "#ffffff",
    //    "border-color": "#ffffff"
    //},
    "ui-lineargauge-needle": {
        "background-color": "#999999",
        "border-top-color": "#FFFFFF"
    },
    "ui-lineargauge-scale": {
        "background-color": "transparent",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-tick": {
        "background-color": "rgba(0, 0, 0, 0.35)",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-minortick": {
        "background-color": "rgba(0, 0, 0, 0.2)",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-label": {
        "background-color": "#666666",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-1": {
        "background-color": "#0078C8",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-2": {
        "background-color": "#0099FF",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-3": {
        "background-color": "#21A7FF",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-4": {
        "background-color": "#4FB9FF",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-range-palette-5": {
        "background-color": "#79C9FF",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-1": {
        "background-color": "#e0e0e0",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-2": {
        "background-color": "#c0c0c0",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-3": {
        "background-color": "#999999",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-4": {
        "background-color": "#494949",
        "border-top-color": "transparent"
    },
    "ui-lineargauge-needle-palette-5": {
        "background-color": "#353535",
        "border-top-color": "transparent"
    },
    //"ui-lineargauge-tooltip": {
    //    "border-style": "none",
    //    "white-space": "nowrap",
    //    "background-color": "transparent"
    //},
    //"ui-lineargauge-range-tooltip": {
    //    "border-style": "solid",
    //    "border-width": "2px",
    //    "border-radius": "4px",
    //    "background-color": "rgba(230, 230, 230, 0.74)",
    //    "padding": "4px",
    //    "font-weight": "bold"
    //},
    //"ui-lineargauge-needle-tooltip": {
    //    "border-style": "solid",
    //    "border-width": "2px",
    //    "border-radius": "4px",
    //    "background-color": "rgba(230, 230, 230, 0.74)",
    //    "padding": "4px",
    //    "font-weight": "bold"
    //},
    "ui-lineargauge": {
        "font-family": defaultFont$1,
        "font-size": "11px",
        "color": "#494949"
    },
    "font-family": defaultFont$1,
    "font-style": "normal",
    "font-weight": "normal",
    "font-size": "11px",
    "color": "#666666",
    "font-variant": "",
    "line-height": ""
};

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * A linear gauge for displaying a single value on a defined scale.
*/
class IgrLinearGauge extends Component {
    constructor(props) {
        super(props);
        this.contentRanges = [];
        /**
        * The ranges actually present in the chart. Do not directly modify this array.
        * This array's contents can be modified by causing Angular to reproject the child content.
        * Or adding and removing ranges from the manual ranges collection on the ranges property.
        */
        this.actualRanges = [];
        this._ranges = null;
        this._rangesAdapter = null;
        this._initialized = false;
        this._tooltipTemplate = null;
        this._tooltipContent = null;
        this._defaultTooltips = null;
        this._uniqueTooltipId = 0;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._formatLabel = null;
        this._formatLabel_wrapped = null;
        this._alignLabel = null;
        this._alignLabel_wrapped = null;
        this._valueChanged = null;
        this._valueChanged_wrapped = null;
        this._actualMinimumValueChange = null;
        this._actualMinimumValueChange_wrapped = null;
        this._actualMaximumValueChange = null;
        this._actualMaximumValueChange_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        this._tooltipRef = this._tooltipRef.bind(this);
        this._activeTooltipElements = new Map();
        this._activeTooltips = new Map();
        this._currentTooltips = [];
        this._contentChildrenManager = new ContentChildrenManager((ch) => ch.key || ch.props.name, (ch) => ch.key || ch.props.name, () => this._updateContentChildren());
        let container = null;
        if (document) {
            container = document.createElement("div");
            container.style.display = "block";
            container.style.width = "100%";
            container.style.height = "100%";
        }
        var root;
        root = container;
        this._renderer = new ReactRenderer(root, document, true, LinearGaugeStylingDefaults);
        this._container = this._renderer.getWrapper(container);
        this._implementation = this.createImplementation();
        //this._container = this._renderer.createElement("div");
        //this._renderer.rootWrapper.append(this._container);
        //this._container.setStyleProperty("display", "block");
        //this._container.setStyleProperty("width", "100%");
        //this._container.setStyleProperty("height", "100%");
        this._wrapper = this._renderer;
        //var root: any;
        //root = this._container;
        //if (this._container.nativeElement != null) {
        //    root = this._container.nativeElement;
        //}
        var gauge = this.i;
        this._gauge = gauge;
        this._rangesAdapter = new CollectionAdapter(this.contentRanges, this.i.ranges, this.actualRanges, (c) => c.i, (i) => {
            i._provideRenderer(this._wrapper);
            if (this._container && this._container.getNativeElement().parentElement) {
                i._styling(this._container.getNativeElement(), this, this);
            }
        }, (i) => { i._provideRenderer(null); });
        gauge.provideContainer(this._renderer);
        this._renderer.addSizeWatcher(() => {
            this._gauge.containerResized();
        });
        this._initialized = true;
    }
    set height(value) {
        this._height = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this.containerResized();
        }
    }
    get height() {
        return this._height;
    }
    set width(value) {
        this._width = value;
        if (this._elRef) {
            this._elRef.style.width = value;
            this.containerResized();
        }
    }
    get width() {
        return this._width;
    }
    _updateContentChildren() {
        this.contentRanges.length = 0;
        let contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (let i = 0; i < contentChildrenActual.length; i++) {
            if ((XamLinearGraphRange.$type).isAssignableFrom(contentChildrenActual[i].i.$type)) {
                this.contentRanges.push(contentChildrenActual[i]);
            }
        }
        if (this._rangesAdapter !== null) {
            this._rangesAdapter.notifyContentChanged();
        }
    }
    /**
     * A collection or manually added axes for the chart.
    */
    get ranges() {
        if (this._ranges === null) {
            let coll = new IgrLinearGraphRangeCollection();
            let inner = coll._innerColl;
            inner.addListener((sender, e) => {
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._rangesAdapter.clearManualItems();
                        break;
                }
            });
            this._ranges = coll;
        }
        return this._ranges;
    }
    _tooltipRef(t) {
        //console.log(t);
        if (t === null) {
            return;
        }
        if (t.currentOwner &&
            t.currentOwner.tooltipTemplate) {
            t.template = t.currentOwner.tooltipTemplate;
        }
        this._activeTooltips.set(t.currentOwner, t);
    }
    render() {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        let children = this._contentChildrenManager.getChildren(this.props.children);
        if (this._currentTooltips && this._currentTooltips.length > 0) {
            for (let i = 0; i < this._currentTooltips.length; i++) {
                let t = this._currentTooltips[i];
                if (this._activeTooltipElements.has(t)) {
                    children.push(this._activeTooltipElements.get(t));
                }
                else {
                    if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
                        continue;
                    }
                    let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
                    let tEle = createElement(Tooltip, {
                        ref: this._tooltipRef,
                        key: this._currentTooltips[i].key,
                        owner: this._currentTooltips[i]
                    });
                    let portal = createPortal(tEle, t, this._currentTooltips[i].key);
                    this._activeTooltipElements.set(t, portal);
                    children.push(portal);
                }
            }
        }
        let div = createElement("div", {
            className: "ig-linear-gauge igr-linear-gauge",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                {
                    this[p] = this.props[p];
                }
            }
        }
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container.getNativeElement());
        this.containerResized();
        this.initializeContent();
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    _getMainRef(div) {
        this._elRef = div;
    }
    destroy() {
        this._wrapper.rootWrapper.unlistenAll();
        this._gauge.destroy();
        this._wrapper.destroy();
    }
    createImplementation() {
        return new XamLinearGauge();
    }
    initializeContent() {
        this._styling(this._container.getNativeElement(), this);
        if (this.actualRanges && this.actualRanges.length > 0) {
            var currRange = this.actualRanges;
            for (var i = 0; i < currRange.length; i++) {
                currRange[i]._styling(this._container.getNativeElement(), this, this);
            }
        }
        this._updateContentChildren();
        this.i.containerResized();
    }
    componentWillUnmount() {
        //this._grid.destroy();
        this.destroy();
    }
    set tooltipTemplate(value) {
        this._tooltipTemplate = value;
        if (value == null) {
            if (this._tooltipContent !== null) {
                this._tooltipContent.destroy();
                this._tooltipContent = null;
            }
        }
        if (this._tooltipContent != null) {
            this._tooltipContent.instance.template = this._tooltipTemplate;
        }
        else {
            this._ensureTooltipCreated();
        }
    }
    get tooltipTemplate() {
        return this._tooltipTemplate;
    }
    createWrapper(ele) {
        let wrapper = new ReactWrapper(ele, this._renderer);
        wrapper.updateToolTip = ele.updateToolTip;
        wrapper.hideToolTip = ele.hideToolTip;
        return wrapper;
    }
    _ensureDefaultTooltip() {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips["ensureDefaultTooltip"](this);
    }
    _onDefaultTooltipsReady(cr) {
        this._ensureDefaultTooltip();
    }
    _updateTooltipState() {
        if (this._initialized) {
            this.setState({ tooltips: this._currentTooltips });
        }
    }
    createTooltip() {
        // if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
        // 	return null;
        // }
        // let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
        let wrapper = this._wrapper.createElement("div");
        let ele = wrapper.getNativeElement();
        ele.key = "__tooltip_" + this._uniqueTooltipId;
        this._uniqueTooltipId++;
        this._currentTooltips = this._currentTooltips.slice(0);
        this._currentTooltips.push(ele);
        //let element = React.createElement(Tooltip,  );
        //let portal = ReactDOM.createPortal(element, ele);
        let self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                let ext = new IgrDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container.getNativeElement()) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.getNativeElement().appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            if (self._activeTooltips.has(ele)) {
                let t = self._activeTooltips.get(ele);
                if (t.template === null &&
                    ele.tooltipTemplate !== null) {
                    t.template = ele.tooltipTemplate;
                }
                t.dataContext = c;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        this._updateTooltipState();
        return ele;
    }
    _ensureTooltipCreated() {
        if (this.i.toolTip == null) {
            let tooltip = this.createTooltip();
            let ele = tooltip;
            if (tooltip == null) {
                return;
            }
            this._tooltipContent = tooltip;
            //(<any>tooltip.instance).template = this._tooltipTemplate;
            this.i.toolTip = this.createWrapper(tooltip);
            if (this._activeTooltips.has(ele)) {
                let tCont = this._activeTooltips.get(ele);
                tCont.template = ele.tooltipTemplate;
            }
        }
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets a value indicating whether the bullet graph is currently animating.
*/
    get animating() {
        return this.i.a4;
    }
    /**
     * Gets the transition progress of the animation when the control is animating.
    */
    get transitionProgress() {
        return this.i.cz;
    }
    set transitionProgress(v) {
        this.i.cz = +v;
    }
    /**
     * Gets or sets the orientation of the scale.
    */
    get orientation() {
        return this.i.as;
    }
    set orientation(v) {
        this.i.as = ensureEnum(LinearScaleOrientation_$type, v);
    }
    /**
     * Gets or sets a collection of brushes to be used as the palette for linear gauge ranges.
    */
    get rangeBrushes() {
        return fromBrushCollection(this.i.ah);
    }
    set rangeBrushes(v) {
        this.i.ah = toBrushCollection(v);
    }
    /**
     * Gets or sets a collection of brushes to be used as the palette for linear gauge outlines.
    */
    get rangeOutlines() {
        return fromBrushCollection(this.i.ai);
    }
    set rangeOutlines(v) {
        this.i.ai = toBrushCollection(v);
    }
    /**
     * Gets or sets the minimum value of the scale.
    */
    get minimumValue() {
        return this.i.b4;
    }
    set minimumValue(v) {
        this.i.b4 = +v;
    }
    /**
     * Gets the resolved minimum value of the scale.
    */
    get actualMinimumValue() {
        return this.i.bs;
    }
    set actualMinimumValue(v) {
        this.i.bs = +v;
    }
    /**
     * Gets or sets the maximum value of the scale.
    */
    get maximumValue() {
        return this.i.b3;
    }
    set maximumValue(v) {
        this.i.b3 = +v;
    }
    /**
     * Gets the resolved maximum value of the scale.
    */
    get actualMaximumValue() {
        return this.i.br;
    }
    set actualMaximumValue(v) {
        this.i.br = +v;
    }
    /**
     * Gets or sets the value at which the needle is positioned.
    */
    get value() {
        return this.i.c0;
    }
    set value(v) {
        this.i.c0 = +v;
    }
    /**
     * Gets or sets the shape to use when rendering the needle from a number of options.
    */
    get needleShape() {
        return this.i.ap;
    }
    set needleShape(v) {
        this.i.ap = ensureEnum(LinearGraphNeedleShape_$type, v);
    }
    /**
     * Gets or sets the name used for needle.
    */
    get needleName() {
        return this.i.d5;
    }
    set needleName(v) {
        this.i.d5 = v;
    }
    /**
     * Gets or sets the position at which to start rendering the ranges, measured from the front/bottom of the control as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get rangeInnerExtent() {
        return this.i.ck;
    }
    set rangeInnerExtent(v) {
        this.i.ck = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the scale, measured from the bottom/front (when orientation is horizontal/vertical) of the control as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get scaleInnerExtent() {
        return this.i.co;
    }
    set scaleInnerExtent(v) {
        this.i.co = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the range as a value from 0 to 1 measured from the front/bottom of the linear gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get rangeOuterExtent() {
        return this.i.cl;
    }
    set rangeOuterExtent(v) {
        this.i.cl = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the scale as a value from 0 to 1 measured from the bottom/front (when orientation is horizontal/vertical) of the linear gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get scaleOuterExtent() {
        return this.i.cq;
    }
    set scaleOuterExtent(v) {
        this.i.cq = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the needle geometry, measured from the front/bottom of the linear gauge as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get needleInnerExtent() {
        return this.i.cb;
    }
    set needleInnerExtent(v) {
        this.i.cb = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the needle geometry as a value from 0 to 1 measured from the front/bottom of the linear gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get needleOuterExtent() {
        return this.i.cf;
    }
    set needleOuterExtent(v) {
        this.i.cf = +v;
    }
    /**
     * Gets or sets the width of the needle's inner base.
    */
    get needleInnerBaseWidth() {
        return this.i.ca;
    }
    set needleInnerBaseWidth(v) {
        this.i.ca = +v;
    }
    /**
     * Gets or sets the width of the needle's outer base.
    */
    get needleOuterBaseWidth() {
        return this.i.ce;
    }
    set needleOuterBaseWidth(v) {
        this.i.ce = +v;
    }
    /**
     * Gets or sets the width of the needle's inner point.
    */
    get needleInnerPointWidth() {
        return this.i.cd;
    }
    set needleInnerPointWidth(v) {
        this.i.cd = +v;
    }
    /**
     * Gets or sets the width of the needle's outer point.
    */
    get needleOuterPointWidth() {
        return this.i.ch;
    }
    set needleOuterPointWidth(v) {
        this.i.ch = +v;
    }
    /**
     * Gets or sets the extent of the needle's inner point.
    */
    get needleInnerPointExtent() {
        return this.i.cc;
    }
    set needleInnerPointExtent(v) {
        this.i.cc = +v;
    }
    /**
     * Gets or sets the extent of the needle's outer point.
    */
    get needleOuterPointExtent() {
        return this.i.cg;
    }
    set needleOuterPointExtent(v) {
        this.i.cg = +v;
    }
    /**
     * Gets or sets the interval to use for the scale.
    */
    get interval() {
        return this.i.by;
    }
    set interval(v) {
        this.i.by = +v;
    }
    /**
     * A value to start adding tickmarks, added to the scale's MinimumValue.
    */
    get ticksPostInitial() {
        return this.i.cv;
    }
    set ticksPostInitial(v) {
        this.i.cv = +v;
    }
    /**
     * A value to stop adding tickmarks, subtracted from the scale's MaximumValue.
    */
    get ticksPreTerminal() {
        return this.i.cw;
    }
    set ticksPreTerminal(v) {
        this.i.cw = +v;
    }
    /**
     * Gets or sets the interval to use for rendering labels. This defaults to be the same interval as the tickmarks on the scale.
    */
    get labelInterval() {
        return this.i.b0;
    }
    set labelInterval(v) {
        this.i.b0 = +v;
    }
    /**
     * Gets or sets the position at which to put the labels as a value from 0 to 1, measured from the bottom of the scale.
     * Values further from zero than 1 can be used to hide the labels of the linear gauge.
    */
    get labelExtent() {
        return this.i.bz;
    }
    set labelExtent(v) {
        this.i.bz = +v;
    }
    /**
     * A value to start adding labels, added to the scale's MinimumValue.
    */
    get labelsPostInitial() {
        return this.i.b1;
    }
    set labelsPostInitial(v) {
        this.i.b1 = +v;
    }
    /**
     * A value to stop adding labels, subtracted from the scale's MaximumValue.
    */
    get labelsPreTerminal() {
        return this.i.b2;
    }
    set labelsPreTerminal(v) {
        this.i.b2 = +v;
    }
    /**
     * Gets or sets the number of minor tickmarks to place between major tickmarks.
    */
    get minorTickCount() {
        return this.i.b5;
    }
    set minorTickCount(v) {
        this.i.b5 = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the major tickmarks as a value from 0 to 1, measured from the front/bottom of the linear gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get tickStartExtent() {
        return this.i.cx;
    }
    set tickStartExtent(v) {
        this.i.cx = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the major tickmarks as a value from 0 to 1, measured from the front/bottom of the linear gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get tickEndExtent() {
        return this.i.cu;
    }
    set tickEndExtent(v) {
        this.i.cu = +v;
    }
    /**
     * Gets or sets the stroke thickness to use when rendering ticks.
    */
    get tickStrokeThickness() {
        return this.i.cy;
    }
    set tickStrokeThickness(v) {
        this.i.cy = +v;
    }
    /**
     * Gets or sets the brush to use for the major tickmarks.
    */
    get tickBrush() {
        return brushToString(this.i.h1);
    }
    set tickBrush(v) {
        this.i.h1 = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the label font.
    */
    get fontBrush() {
        return brushToString(this.i.hu);
    }
    set fontBrush(v) {
        this.i.hu = stringToBrush(v);
    }
    /**
     * Gets or sets the needle breadth.
    */
    get needleBreadth() {
        return this.i.b9;
    }
    set needleBreadth(v) {
        this.i.b9 = +v;
    }
    /**
     * Gets or sets the brush to use for needle element.
    */
    get needleBrush() {
        return brushToString(this.i.hx);
    }
    set needleBrush(v) {
        this.i.hx = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the outline of needle element.
    */
    get needleOutline() {
        return brushToString(this.i.hy);
    }
    set needleOutline(v) {
        this.i.hy = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness to use when rendering single actual value element.
    */
    get needleStrokeThickness() {
        return this.i.ci;
    }
    set needleStrokeThickness(v) {
        this.i.ci = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the minor tickmarks as a value from 0 to 1, measured from the front/bottom of the linear gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get minorTickStartExtent() {
        return this.i.b7;
    }
    set minorTickStartExtent(v) {
        this.i.b7 = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the minor tickmarks as a value from 0 to 1, measured from the front/bottom of the linear gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get minorTickEndExtent() {
        return this.i.b6;
    }
    set minorTickEndExtent(v) {
        this.i.b6 = +v;
    }
    /**
     * Gets or sets the stroke thickness to use when rendering minor ticks.
    */
    get minorTickStrokeThickness() {
        return this.i.b8;
    }
    set minorTickStrokeThickness(v) {
        this.i.b8 = +v;
    }
    /**
     * Gets or sets the brush to use for the minor tickmarks.
    */
    get minorTickBrush() {
        return brushToString(this.i.hw);
    }
    set minorTickBrush(v) {
        this.i.hw = stringToBrush(v);
    }
    /**
     * Gets or sets a value indicating whether the scale is inverted.
     * When the scale is inverted the direction in which the scale values increase is right to left.
    */
    get isScaleInverted() {
        return this.i.a8;
    }
    set isScaleInverted(v) {
        this.i.a8 = ensureBool(v);
    }
    /**
     * Gets or sets the brush to use to fill the backing of the linear gauge.
    */
    get backingBrush() {
        return brushToString(this.i.hs);
    }
    set backingBrush(v) {
        this.i.hs = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the outline of the backing.
    */
    get backingOutline() {
        return brushToString(this.i.ht);
    }
    set backingOutline(v) {
        this.i.ht = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness of the backing outline.
    */
    get backingStrokeThickness() {
        return this.i.bw;
    }
    set backingStrokeThickness(v) {
        this.i.bw = +v;
    }
    /**
     * Gets or sets the inner extent of the linear gauge backing.
    */
    get backingInnerExtent() {
        return this.i.bu;
    }
    set backingInnerExtent(v) {
        this.i.bu = +v;
    }
    /**
     * Gets or sets the outer extent of the linear gauge backing.
    */
    get backingOuterExtent() {
        return this.i.bv;
    }
    set backingOuterExtent(v) {
        this.i.bv = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the scale, measured from the front/bottom of the linear gauge as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get scaleStartExtent() {
        return this.i.cs;
    }
    set scaleStartExtent(v) {
        this.i.cs = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the scale as a value from 0 to 1, measured from the front/bottom of the linear gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal size of the linear gauge.
    */
    get scaleEndExtent() {
        return this.i.cn;
    }
    set scaleEndExtent(v) {
        this.i.cn = +v;
    }
    /**
     * Gets or sets the brush to use to fill the scale of the linear gauge.
    */
    get scaleBrush() {
        return brushToString(this.i.hz);
    }
    set scaleBrush(v) {
        this.i.hz = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the outline of the scale.
    */
    get scaleOutline() {
        return brushToString(this.i.h0);
    }
    set scaleOutline(v) {
        this.i.h0 = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness of the scale outline.
    */
    get scaleStrokeThickness() {
        return this.i.ct;
    }
    set scaleStrokeThickness(v) {
        this.i.ct = +v;
    }
    /**
     * Gets or sets whether needle dragging is enabled or not.
    */
    get isNeedleDraggingEnabled() {
        return this.i.a7;
    }
    set isNeedleDraggingEnabled(v) {
        this.i.a7 = ensureBool(v);
    }
    /**
     * Gets or sets the label composite format used when creating label values.
    */
    get labelFormat() {
        return this.i.dk;
    }
    set labelFormat(v) {
        this.i.dk = v;
    }
    /**
     * Gets or sets the format specifiers to use with the LabelFormat string.
    */
    get labelFormatSpecifiers() {
        return this.i.ag;
    }
    set labelFormatSpecifiers(v) {
        this.i.ag = v;
    }
    /**
     * Gets or sets the number of milliseconds over which changes to the linear gauge should be animated.
    */
    get transitionDuration() {
        return this.i.c4;
    }
    set transitionDuration(v) {
        this.i.c4 = +v;
    }
    /**
     * Gets or sets the time in milliseconds that tooltip appearance is delayed with.
    */
    get showToolTipTimeout() {
        return this.i.c3;
    }
    set showToolTipTimeout(v) {
        this.i.c3 = +v;
    }
    /**
     * Gets or sets a value indicating whether tooltips are enabled.
    */
    get showToolTip() {
        return this.i.be;
    }
    set showToolTip(v) {
        this.i.be = ensureBool(v);
    }
    /**
     * Gets or sets the font.
    */
    get font() {
        return this.i.dd;
    }
    set font(v) {
        this.i.dd = v;
    }
    /**
     * Gets or sets the scaling value used to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get pixelScalingRatio() {
        return this.i.cj;
    }
    set pixelScalingRatio(v) {
        this.i.cj = +v;
    }
    /**
     * Gets the actual pixel scaling ratio used to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get actualPixelScalingRatio() {
        return this.i.bt;
    }
    set actualPixelScalingRatio(v) {
        this.i.bt = +v;
    }
    findByName(name) {
        if (this.ranges != null && this.ranges.findByName && this.ranges.findByName(name)) {
            return this.ranges.findByName(name);
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("LinearGauge");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.

* @param point  * The point for which to retrieve the associated value.
*/
    getValueForPoint(point) {
        let iv = this.i.bx(toPoint(point));
        return (iv);
    }
    needleContainsPoint(point, isFinger) {
        let iv = this.i.needleContainsPoint(toPoint(point), isFinger);
        return (iv);
    }
    /**
     * Returns visuals as a serialized string.
    
    */
    exportSerializedVisualData() {
        let iv = this.i.dc();
        return (iv);
    }
    /**
     * Use to force the linear gauge to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the linear gauge needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the linear gauge.
    
    */
    flush() {
        this.i.e8();
    }
    /**
     * Called by the UI framework to provide a UI container for rendering this control.
    
    * @param container  * The UI container element.
    */
    provideContainer(container) {
        this.i.provideContainer(container);
    }
    containerResized() {
        this.i.containerResized();
    }
    styleUpdated() {
        this.i.f2();
    }
    /**
     * Event which is raised when a label of the the gauge is formatted.
     * Function takes first argument evt and second argument ui.
     * Use ui.owner to obtain reference to the gauge widget.
     * Use ui.actualMinimumValue to obtain the minimum value of the gauge scale.
     * Use ui.actualMaximumValue to obtain the maximum value of the gauge scale.
     * Use ui.value to obtain the value on the the gauge scale associated with the label.
     * Use ui.label to obtain the string value of the label.
    */
    get formatLabel() {
        return this._formatLabel;
    }
    set formatLabel(ev) {
        if (this._formatLabel_wrapped !== null) {
            this.i.formatLabel = delegateRemove(this.i.formatLabel, this._formatLabel_wrapped);
            this._formatLabel_wrapped = null;
            this._formatLabel = null;
        }
        this._formatLabel = ev;
        this._formatLabel_wrapped = (o, e) => {
            let outerArgs = new IgrFormatLinearGraphLabelEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFormatLabel) {
                this.beforeFormatLabel(this, outerArgs);
            }
            if (this._formatLabel) {
                this._formatLabel(this, outerArgs);
            }
        };
        this.i.formatLabel = delegateCombine(this.i.formatLabel, this._formatLabel_wrapped);
    }
    /**
     * Event which is raised when a label of the linear gauge is aligned along the scale.
     * Function takes first argument evt and second argument ui.
     * Use ui.owner to obtain reference to the gauge widget.
     * Use ui.actualMinimumValue to obtain the minimum value of the gauge scale.
     * Use ui.actualMaximumValue to obtain the maximum value of the gauge scale.
     * Use ui.value to obtain the value on the gauge scale associated with the label.
     * Use ui.label to obtain the string value of the label.
     * Use ui.width to obtain the width of the label.
     * Use ui.height to obtain the height of the label.
     * Use ui.offsetX to obtain the X offset of the label on the gauge scale.
     * Use ui.offsetY to obtain the Y offset of the label on the gauge scale.
    */
    get alignLabel() {
        return this._alignLabel;
    }
    set alignLabel(ev) {
        if (this._alignLabel_wrapped !== null) {
            this.i.alignLabel = delegateRemove(this.i.alignLabel, this._alignLabel_wrapped);
            this._alignLabel_wrapped = null;
            this._alignLabel = null;
        }
        this._alignLabel = ev;
        this._alignLabel_wrapped = (o, e) => {
            let outerArgs = new IgrAlignLinearGraphLabelEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeAlignLabel) {
                this.beforeAlignLabel(this, outerArgs);
            }
            if (this._alignLabel) {
                this._alignLabel(this, outerArgs);
            }
        };
        this.i.alignLabel = delegateCombine(this.i.alignLabel, this._alignLabel_wrapped);
    }
    /**
     * Occurs when the Value property changes.
    */
    get valueChanged() {
        return this._valueChanged;
    }
    set valueChanged(ev) {
        if (this._valueChanged_wrapped !== null) {
            this.i.valueChanged = delegateRemove(this.i.valueChanged, this._valueChanged_wrapped);
            this._valueChanged_wrapped = null;
            this._valueChanged = null;
        }
        this._valueChanged = ev;
        this._valueChanged_wrapped = (o, e) => {
            let outerArgs = new IgrDoubleValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeValueChanged) {
                this.beforeValueChanged(this, outerArgs);
            }
            if (this._valueChanged) {
                this._valueChanged(this, outerArgs);
            }
        };
        this.i.valueChanged = delegateCombine(this.i.valueChanged, this._valueChanged_wrapped);
    }
    get actualMinimumValueChange() {
        return this._actualMinimumValueChange;
    }
    set actualMinimumValueChange(ev) {
        if (this._actualMinimumValueChange_wrapped !== null) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
            this._actualMinimumValueChange_wrapped = null;
            this._actualMinimumValueChange = null;
        }
        this._actualMinimumValueChange = ev;
        this._actualMinimumValueChange_wrapped = (o, e) => {
            let ext = this.actualMinimumValue;
            if (this.beforeActualMinimumValueChange) {
                this.beforeActualMinimumValueChange(this, ext);
            }
            if (this._actualMinimumValueChange) {
                this._actualMinimumValueChange(this, ext);
            }
        };
        this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
    }
    get actualMaximumValueChange() {
        return this._actualMaximumValueChange;
    }
    set actualMaximumValueChange(ev) {
        if (this._actualMaximumValueChange_wrapped !== null) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
            this._actualMaximumValueChange_wrapped = null;
            this._actualMaximumValueChange = null;
        }
        this._actualMaximumValueChange = ev;
        this._actualMaximumValueChange_wrapped = (o, e) => {
            let ext = this.actualMaximumValue;
            if (this.beforeActualMaximumValueChange) {
                this.beforeActualMaximumValueChange(this, ext);
            }
            if (this._actualMaximumValueChange) {
                this._actualMaximumValueChange(this, ext);
            }
        };
        this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrLinearGaugeCoreModule {
    static register() {
        TypeRegistrar.registerCons('IgrLinearGauge', IgrLinearGauge);
        IgrLinearGraphRangeModule.register();
        IgrNumberFormatSpecifierModule.register();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrLinearGaugeModule {
    static register() {
        IgrLinearGaugeCoreModule.register();
        IgrDVInteractivityModule.register();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearNeedleVisualDataList = /*@__PURE__*/ (() => {
    class LinearNeedleVisualDataList extends List$1 {
        constructor() {
            super(LinearNeedleVisualData.$, 0);
        }
    }
    LinearNeedleVisualDataList.$t = /*@__PURE__*/ markType(LinearNeedleVisualDataList, 'LinearNeedleVisualDataList', /*@__PURE__*/ List$1.$.specialize(LinearNeedleVisualData.$));
    return LinearNeedleVisualDataList;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying various preset needle shapes.
 */
var RadialGaugeNeedleShape = /*@__PURE__*/ (function (RadialGaugeNeedleShape) {
    /**
     * No shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["None"] = 0] = "None";
    /**
     * A rectangle shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["Rectangle"] = 1] = "Rectangle";
    /**
     * A triangle shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["Triangle"] = 2] = "Triangle";
    /**
     * A needle shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["Needle"] = 3] = "Needle";
    /**
     * A trapezoid shape.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["Trapezoid"] = 4] = "Trapezoid";
    /**
     * A rectangle shape with a bulb at the end.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["RectangleWithBulb"] = 5] = "RectangleWithBulb";
    /**
     * A triangle shape with a bulb at the end.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["TriangleWithBulb"] = 6] = "TriangleWithBulb";
    /**
     * A needle shape with a bulb at the end.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["NeedleWithBulb"] = 7] = "NeedleWithBulb";
    /**
     * A trapezoid shape with a bulb at the end.
     */
    RadialGaugeNeedleShape[RadialGaugeNeedleShape["TrapezoidWithBulb"] = 8] = "TrapezoidWithBulb";
    return RadialGaugeNeedleShape;
})({});
/**
 * @hidden
 */
let RadialGaugeNeedleShape_$type = /*@__PURE__*/ markEnum('RadialGaugeNeedleShape', 'None,0|Rectangle,1|Triangle,2|Needle,3|Trapezoid,4|RectangleWithBulb,5|TriangleWithBulb,6|NeedleWithBulb,7|TrapezoidWithBulb,8');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying shapes for the needle pivot.
 */
var RadialGaugePivotShape = /*@__PURE__*/ (function (RadialGaugePivotShape) {
    /**
     * No pivot shape.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["None"] = 0] = "None";
    /**
     * A circle shaped pivot.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["Circle"] = 1] = "Circle";
    /**
     * A circle pivot with a hole in it.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleWithHole"] = 2] = "CircleWithHole";
    /**
     * A circle pivot overlayed on top of the needle.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleOverlay"] = 3] = "CircleOverlay";
    /**
     * A circle pivot with a hole in it overlayed on top of the needle.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleOverlayWithHole"] = 4] = "CircleOverlayWithHole";
    /**
     * A circle pivot rendered underneath the needle.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleUnderlay"] = 5] = "CircleUnderlay";
    /**
     * A circle pivot with a hold in it rendered underneath the needle.
     */
    RadialGaugePivotShape[RadialGaugePivotShape["CircleUnderlayWithHole"] = 6] = "CircleUnderlayWithHole";
    return RadialGaugePivotShape;
})({});
/**
 * @hidden
 */
let RadialGaugePivotShape_$type = /*@__PURE__*/ markEnum('RadialGaugePivotShape', 'None,0|Circle,1|CircleWithHole,2|CircleOverlay,3|CircleOverlayWithHole,4|CircleUnderlay,5|CircleUnderlayWithHole,6');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying oversweep shapes.
 */
var RadialGaugeScaleOversweepShape = /*@__PURE__*/ (function (RadialGaugeScaleOversweepShape) {
    /**
     * A default oversweep shape.
     */
    RadialGaugeScaleOversweepShape[RadialGaugeScaleOversweepShape["Auto"] = 0] = "Auto";
    /**
     * A circular oversweep shape.
     */
    RadialGaugeScaleOversweepShape[RadialGaugeScaleOversweepShape["Circular"] = 1] = "Circular";
    /**
     * A fitted oversweep shape.
     */
    RadialGaugeScaleOversweepShape[RadialGaugeScaleOversweepShape["Fitted"] = 2] = "Fitted";
    return RadialGaugeScaleOversweepShape;
})({});
/**
 * @hidden
 */
let RadialGaugeScaleOversweepShape_$type = /*@__PURE__*/ markEnum('RadialGaugeScaleOversweepShape', 'Auto,0|Circular,1|Fitted,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying shapes that can be used by the backing area of the radial gauge.
 */
var RadialGaugeBackingShape = /*@__PURE__*/ (function (RadialGaugeBackingShape) {
    /**
     * A circular backing shape.
     */
    RadialGaugeBackingShape[RadialGaugeBackingShape["Circular"] = 0] = "Circular";
    /**
     * A fitted backing shape.
     */
    RadialGaugeBackingShape[RadialGaugeBackingShape["Fitted"] = 1] = "Fitted";
    return RadialGaugeBackingShape;
})({});
/**
 * @hidden
 */
let RadialGaugeBackingShape_$type = /*@__PURE__*/ markEnum('RadialGaugeBackingShape', 'Circular,0|Fitted,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let XamRadialGaugeRange = /*@__PURE__*/ (() => {
    class XamRadialGaugeRange extends DependencyObject {
        constructor() {
            super();
            this.propertyChanged = null;
        }
        ad(a, b, c) {
        }
        ac(a, b, c) {
            this.ad(a, b, c);
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
        }
    }
    XamRadialGaugeRange.$t = /*@__PURE__*/ markType(XamRadialGaugeRange, 'XamRadialGaugeRange', DependencyObject.$, [INotifyPropertyChanged_$type]);
    XamRadialGaugeRange.q = /*@__PURE__*/ DeviceUtils.g(1);
    XamRadialGaugeRange.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, XamRadialGaugeRange, 'ac', ['Brush:ao:ae', [Brush.$, null], 'EndValue:j:af', [1, NaN], 'InnerEndExtent:k:ag', [1, NaN], 'InnerStartExtent:l:ah', [1, NaN], 'Name:v:ai', [2, null], 'OuterEndExtent:m:aj', [1, NaN], 'OuterStartExtent:n:ak', [1, NaN], 'Outline:ap:al', [Brush.$, null], 'StartValue:o:am', [1, NaN], 'StrokeThickness:p:an', [1, XamRadialGaugeRange.q]]);
    return XamRadialGaugeRange;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadialGaugeRangeCollection = /*@__PURE__*/ (() => {
    class RadialGaugeRangeCollection extends ObservableCollection$1 {
        constructor() {
            super(XamRadialGaugeRange.$, 0);
        }
    }
    RadialGaugeRangeCollection.$t = /*@__PURE__*/ markType(RadialGaugeRangeCollection, 'RadialGaugeRangeCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(XamRadialGaugeRange.$));
    return RadialGaugeRangeCollection;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Enum specifying multiple strategies for omitting labels.
 */
var RadialGaugeDuplicateLabelOmissionStrategy = /*@__PURE__*/ (function (RadialGaugeDuplicateLabelOmissionStrategy) {
    /**
     * Omit the last label.
     */
    RadialGaugeDuplicateLabelOmissionStrategy[RadialGaugeDuplicateLabelOmissionStrategy["OmitLast"] = 0] = "OmitLast";
    /**
     * Omit the first label.
     */
    RadialGaugeDuplicateLabelOmissionStrategy[RadialGaugeDuplicateLabelOmissionStrategy["OmitFirst"] = 1] = "OmitFirst";
    /**
     * Omit no labels.
     */
    RadialGaugeDuplicateLabelOmissionStrategy[RadialGaugeDuplicateLabelOmissionStrategy["OmitNeither"] = 2] = "OmitNeither";
    /**
     * Omit both labels.
     */
    RadialGaugeDuplicateLabelOmissionStrategy[RadialGaugeDuplicateLabelOmissionStrategy["OmitBoth"] = 3] = "OmitBoth";
    return RadialGaugeDuplicateLabelOmissionStrategy;
})({});
/**
 * @hidden
 */
let RadialGaugeDuplicateLabelOmissionStrategy_$type = /*@__PURE__*/ markEnum('RadialGaugeDuplicateLabelOmissionStrategy', 'OmitLast,0|OmitFirst,1|OmitNeither,2|OmitBoth,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadialGaugeScaler = /*@__PURE__*/ (() => {
    class RadialGaugeScaler extends Base {
        constructor(a, b, c, d, e) {
            super();
            this.e = 0;
            this.d = 0;
            this.c = 0;
            this.b = 0;
            this.l = 0;
            this.f = 0;
            this.a = 0;
            this.e = c;
            this.d = d;
            if (isNaN_(this.e) || isInfinity(this.e)) {
                this.e = 135;
            }
            if (isNaN_(this.d) || isInfinity(this.d)) {
                this.d = 45;
            }
            this.l = e;
            this.c = a;
            this.b = b;
            let f = MathUtil.k(this.e);
            let g = MathUtil.k(this.d);
            let h = RadialGaugeScaler.k(f, g, this.l);
            this.f = h.c;
            this.a = h.d;
        }
        get i() {
            return this.f;
        }
        get g() {
            return this.a;
        }
        static k(a, b, c) {
            if (c == 1 && b < a) {
                b += Math.PI * 2;
            }
            if (c == 0 && a < b) {
                a += Math.PI * 2;
            }
            if (c == 0) {
                let d = a;
                a = b;
                b = d;
            }
            return new Tuple$2(Number_$type, Number_$type, a, b);
        }
        h(a) {
            let b = NaN;
            if (this.c == this.b) {
                b = 0;
            }
            else {
                b = (a - this.c) / (this.b - this.c);
            }
            if (this.l == 0) {
                b = 1 - b;
            }
            let c = this.f + (this.a - this.f) * b;
            return c;
        }
        j(a) {
            let b = (a - this.f) / (this.a - this.f);
            if (this.l == 0) {
                b = 1 - b;
            }
            let c = this.c + (this.b - this.c) * b;
            return c;
        }
    }
    RadialGaugeScaler.$t = /*@__PURE__*/ markType(RadialGaugeScaler, 'RadialGaugeScaler');
    return RadialGaugeScaler;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadialGaugeNeedleFrame = /*@__PURE__*/ (() => {
    class RadialGaugeNeedleFrame extends Base {
        constructor() {
            super();
            this.ad = 0;
            this.ac = 0;
            this.af = 0;
            this.ab = 0;
            this.aj = null;
            this.ak = null;
            this.aa = 0;
            this.ae = 0;
            this.ai = null;
            this.ah = null;
            this.d = null;
            this.b = null;
            this.t = null;
            this.e = null;
            this.f = null;
            this.x = null;
            this.v = null;
            this.w = null;
            this.z = null;
            this.y = null;
            this.u = null;
            this.h = null;
            this.g = null;
            this.c = null;
            this.s = null;
            this.a = null;
            this.q = null;
            this.r = null;
            this.i = null;
            this.l = null;
            this.m = null;
            this.p = null;
            this.j = null;
            this.k = null;
            this.n = null;
            this.o = null;
            this.d = new MorphSegment();
            this.b = new MorphSegment();
            this.t = new MorphSegment();
            this.e = new MorphSegment();
            this.f = new MorphSegment();
            this.x = new MorphSegment();
            this.v = new MorphSegment();
            this.w = new MorphSegment();
            this.z = new MorphSegment();
            this.y = new MorphSegment();
            this.u = new MorphSegment();
            this.h = new MorphSegment();
            this.g = new MorphSegment();
            this.c = new MorphSegment();
            this.s = new MorphSegment();
            this.a = new MorphSegment();
            this.q = new MorphSegment();
            this.r = new MorphSegment();
            this.i = new MorphSegment();
            this.l = new MorphSegment();
            this.m = new MorphSegment();
            this.p = new MorphSegment();
            this.j = new MorphSegment();
            this.k = new MorphSegment();
            this.n = new MorphSegment();
            this.o = new MorphSegment();
        }
        ag(a, b, c) {
            this.ad = b.ad + (c.ad - b.ad) * a;
            this.ac = b.ac + (c.ac - b.ac) * a;
            this.af = b.af + (c.af - b.af) * a;
            this.ab = b.ab + (c.ab - b.ab) * a;
            this.aj = BrushUtil.k(b.aj, a, c.aj, 0);
            this.ak = BrushUtil.k(b.ak, a, c.ak, 0);
            this.ae = b.ae + (c.ae - b.ae) * a;
            this.aa = b.aa + (c.aa - b.aa) * a;
            this.ah = BrushUtil.k(b.ah, a, c.ah, 0);
            this.ai = BrushUtil.k(b.ai, a, c.ai, 0);
            this.d.j(a, b.d, c.d);
            this.b.j(a, b.b, c.b);
            this.t.j(a, b.t, c.t);
            this.e.j(a, b.e, c.e);
            this.f.j(a, b.f, c.f);
            this.x.j(a, b.x, c.x);
            this.v.j(a, b.v, c.v);
            this.w.j(a, b.w, c.w);
            this.z.j(a, b.z, c.z);
            this.y.j(a, b.y, c.y);
            this.u.j(a, b.u, c.u);
            this.h.j(a, b.h, c.h);
            this.g.j(a, b.g, c.g);
            this.c.j(a, b.c, c.c);
            this.s.j(a, b.s, c.s);
            this.a.j(a, b.a, c.a);
            this.q.j(a, b.q, c.q);
            this.r.j(a, b.r, c.r);
            this.i.j(a, b.i, c.i);
            this.l.j(a, b.l, c.l);
            this.m.j(a, b.m, c.m);
            this.p.j(a, b.p, c.p);
            this.j.j(a, b.j, c.j);
            this.k.j(a, b.k, c.k);
            this.n.j(a, b.n, c.n);
            this.o.j(a, b.o, c.o);
        }
        am(a, b, c) {
            let d = new PathGeometry();
            let e = new PathFigure();
            let f = { $type: Point_$type, x: NaN, y: NaN };
            f = this.d.l(f, e, a, b, c);
            f = this.b.l(f, e, a, b, c);
            f = this.t.l(f, e, a, b, c);
            f = this.e.l(f, e, a, b, c);
            f = this.f.l(f, e, a, b, c);
            f = this.x.l(f, e, a, b, c);
            f = this.v.l(f, e, a, b, c);
            f = this.w.l(f, e, a, b, c);
            f = this.z.l(f, e, a, b, c);
            f = this.y.l(f, e, a, b, c);
            f = this.u.l(f, e, a, b, c);
            f = this.h.l(f, e, a, b, c);
            f = this.g.l(f, e, a, b, c);
            f = this.c.l(f, e, a, b, c);
            f = this.s.l(f, e, a, b, c);
            f = this.a.l(f, e, a, b, c);
            e._isClosed = true;
            d.c.add(e);
            let g = new PathFigure();
            if (this.q.f.count > 0 || this.r.f.count > 0) {
                f = this.q.l(f, g, a, b, c);
                f = this.r.l(f, g, a, b, c);
                g._isClosed = true;
                d.c.add(g);
            }
            return d;
        }
        an(a, b, c) {
            let d = new PathGeometry();
            let e = { $type: Point_$type, x: NaN, y: NaN };
            let f = new PathFigure();
            if (this.m.f.count > 0 || this.p.f.count > 0) {
                e = this.m.l(e, f, a, b, c);
                e = this.p.l(e, f, a, b, c);
                f._isClosed = true;
                d.c.add(f);
            }
            let g = new PathFigure();
            if (this.n.f.count > 0 || this.o.f.count > 0) {
                e = this.n.l(e, g, a, b, c);
                e = this.o.l(e, g, a, b, c);
                g._isClosed = true;
                d.c.add(g);
            }
            return d;
        }
        al(a, b, c) {
            let d = new PathGeometry();
            let e = { $type: Point_$type, x: NaN, y: NaN };
            let f = new PathFigure();
            if (this.i.f.count > 0 || this.l.f.count > 0) {
                e = this.i.l(e, f, a, b, c);
                e = this.l.l(e, f, a, b, c);
                f._isClosed = true;
                d.c.add(f);
            }
            let g = new PathFigure();
            if (this.j.f.count > 0 || this.k.f.count > 0) {
                e = this.j.l(e, g, a, b, c);
                e = this.k.l(e, g, a, b, c);
                g._isClosed = true;
                d.c.add(g);
            }
            return d;
        }
    }
    RadialGaugeNeedleFrame.$t = /*@__PURE__*/ markType(RadialGaugeNeedleFrame, 'RadialGaugeNeedleFrame');
    return RadialGaugeNeedleFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadialGaugeRangeFrame = /*@__PURE__*/ (() => {
    class RadialGaugeRangeFrame extends Base {
        constructor() {
            super(...arguments);
            this.f = 0;
            this.g = 0;
            this.e = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.k = null;
            this.l = null;
            this.h = 0;
        }
        static a(a, b, c, d) {
            let e = new RadialGaugeRangeFrame();
            e.k = BrushUtil.k(c.k, a, d.k, 0);
            e.l = BrushUtil.k(c.l, a, d.l, 0);
            e.h = b * c.h + a * d.h;
            e.f = b * c.f + a * d.f;
            e.g = b * c.g + a * d.g;
            e.e = b * c.e + a * d.e;
            e.b = b * c.b + a * d.b;
            e.c = b * c.c + a * d.c;
            e.d = b * c.d + a * d.d;
            return e;
        }
        m(a, b, c) {
            let d = new PathGeometry();
            let e = new PathFigure();
            let f = 4;
            let g = 1 / a;
            let h = false;
            if (Math.abs(this.g - this.d) < g) {
                h = true;
            }
            let i = false;
            if (Math.abs(this.f - this.c) < g) {
                i = true;
            }
            let j = false;
            if ((this.b - this.e) >= 2 * Math.PI) {
                j = true;
            }
            if (i && h && j) {
                let k = this.i(0, Math.PI, this.g, a, b, c, true);
                e._startPoint = k.c;
                let l = this.i(Math.PI, 0, this.g, a, b, c, true);
                let m = new PathFigure();
                let n = this.i(0, Math.PI, this.f, a, b, c, false);
                m._startPoint = n.c;
                let o = this.i(Math.PI, 0, this.f, a, b, c, false);
                e._segments.add(k.d);
                e._segments.add(l.d);
                m._segments.add(n.d);
                m._segments.add(o.d);
                d.c.add(e);
                d.c.add(m);
                return d;
            }
            let p = null;
            if (h) {
                let q = this.i(this.e, this.b, Math.max(0, this.g), a, b, c, true);
                e._startPoint = q.c;
                p = q.d;
            }
            else {
                let r = this.j(this.e, this.b, this.g, this.d, a, b, c, true, f);
                e._startPoint = r.c;
                p = r.d;
            }
            let s = null;
            let t = new LineSegment(1);
            if (i) {
                let u = this.i(this.e, this.b, Math.max(0, this.f), a, b, c, false);
                s = u.d;
                t.c = u.c;
            }
            else {
                let v = this.j(this.e, this.b, this.f, this.c, a, b, c, false, f);
                s = v.d;
                t.c = v.c;
            }
            e._segments.add(p);
            e._segments.add(t);
            e._segments.add(s);
            e._isFilled = true;
            e._isClosed = true;
            d.c.add(e);
            return d;
        }
        j(a, b, c, d, e, f, g, h, i) {
            let j = new PolyLineSegment();
            let k = e * c;
            let l = e * d;
            let m = Math.max(k, l);
            let n = m + m;
            let o = Math.asin(i / n) * 2;
            let p;
            let q;
            let r;
            let s = l - k;
            let t = Math.abs(b - a);
            let u = j._points;
            if (h) {
                let v;
                for (v = a; v < b; v += o) {
                    r = (v - a) / t;
                    q = k + r * s;
                    p = { $type: Point_$type, x: f + Math.cos(v) * q, y: g + Math.sin(v) * q };
                    u.add(p);
                }
                v = b;
                r = (v - a) / t;
                q = k + r * s;
                p = { $type: Point_$type, x: f + Math.cos(v) * q, y: g + Math.sin(v) * q };
                u.add(p);
            }
            else {
                let w;
                for (w = b; w > a; w -= o) {
                    r = (w - b) / t;
                    q = l + r * s;
                    p = { $type: Point_$type, x: f + Math.cos(w) * q, y: g + Math.sin(w) * q };
                    u.add(p);
                }
                w = a;
                r = (w - b) / t;
                q = l + r * s;
                p = { $type: Point_$type, x: f + Math.cos(w) * q, y: g + Math.sin(w) * q };
                u.add(p);
            }
            return new Tuple$2(Point_$type, PathSegment.$, u._inner[0], j);
        }
        i(a, b, c, d, e, f, g) {
            let h = c * d;
            let i = new ArcSegment();
            i.d = g ? 1 : 0;
            i.b = b - a > Math.PI;
            i.f = new Size(1, h, h);
            let j = g ? b : a;
            let k = g ? a : b;
            i.e = { $type: Point_$type, x: e + Math.cos(j) * h, y: f + Math.sin(j) * h };
            let l = { $type: Point_$type, x: e + Math.cos(k) * h, y: f + Math.sin(k) * h };
            return new Tuple$2(Point_$type, PathSegment.$, l, i);
        }
    }
    RadialGaugeRangeFrame.$t = /*@__PURE__*/ markType(RadialGaugeRangeFrame, 'RadialGaugeRangeFrame');
    return RadialGaugeRangeFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadialGaugeScaleFrame = /*@__PURE__*/ (() => {
    class RadialGaugeScaleFrame extends Base {
        constructor() {
            super();
            this.j = null;
            this.i = null;
            this.c = null;
            this.e = null;
            this.f = null;
            this.d = null;
            this.g = null;
            this.h = null;
            this.t = 0;
            this.q = 0;
            this.l = 0;
            this.v = 0;
            this.u = 0;
            this.n = 0;
            this.m = 0;
            this.s = 0;
            this.p = 0;
            this.ac = null;
            this.w = 0;
            this.o = 0;
            this.aa = null;
            this.ab = null;
            this.z = null;
            this.r = 0;
            this.k = null;
            this.k = new List$1(RadialGaugeRangeFrame.$, 0);
            this.j = new Array(0);
            this.i = new Array(0);
            this.c = new Array(0);
            this.e = new Array(0);
            this.f = new Array(0);
            this.d = new Array(0);
            this.g = new Array(0);
            this.h = new Array(0);
        }
        a(a, b, c, d) {
            let e = Math.max(c.length, d.length);
            let f = Math.min(c.length, d.length);
            if (b.length != e) {
                b = new Array(e);
            }
            let g = 0;
            if (c.length > 0) {
                g = c[c.length - 1];
            }
            let h = 0;
            if (d.length > 0) {
                h = d[d.length - 1];
            }
            let i = c.length > d.length;
            let j = 0;
            for (j = 0; j < f; j++) {
                b[j] = c[j] + (d[j] - c[j]) * a;
            }
            let k;
            let l;
            for (j = f; j < e; j++) {
                if (i) {
                    k = c[j];
                    l = h;
                }
                else {
                    k = g;
                    l = d[j];
                }
                b[j] = k + (l - k) * a;
            }
            return b;
        }
        b(a, b, c, d) {
            let e = Math.max(c.length, d.length);
            let f = Math.min(c.length, d.length);
            if (b.length != e) {
                b = new Array(e);
            }
            let g = null;
            if (c.length > 0) {
                g = c[c.length - 1];
            }
            let h = null;
            if (d.length > 0) {
                h = d[d.length - 1];
            }
            let i = c.length > d.length;
            let j = 0;
            for (j = 0; j < f; j++) {
                b[j] = d[j];
            }
            let k;
            let l;
            for (j = f; j < e; j++) {
                if (i) {
                    k = c[j];
                    l = h;
                }
                else {
                    k = g;
                    l = d[j];
                }
                if (l != null) {
                    b[j] = l;
                }
                else {
                    b[j] = k;
                }
            }
            return b;
        }
        x(a, b, c) {
            this.ab = BrushUtil.k(b.ab, a, c.ab, 0);
            this.ac = BrushUtil.k(b.ac, a, c.ac, 0);
            this.aa = BrushUtil.k(b.aa, a, c.aa, 0);
            if (b.z == null && c.z == null) {
                this.z = null;
            }
            else {
                this.z = BrushUtil.k(b.z, a, c.z, 0);
            }
            this.t = b.t + (c.t - b.t) * a;
            this.q = b.q + (c.q - b.q) * a;
            this.s = b.s + (c.s - b.s) * a;
            this.p = b.p + (c.p - b.p) * a;
            this.r = b.r + (c.r - b.r) * a;
            this.l = b.l + (c.l - b.l) * a;
            this.v = b.v + (c.v - b.v) * a;
            this.u = b.u + (c.u - b.u) * a;
            this.n = b.n + (c.n - b.n) * a;
            this.m = b.m + (c.m - b.m) * a;
            this.w = b.w + (c.w - b.w) * a;
            this.o = b.o + (c.o - b.o) * a;
            this.j = this.a(a, this.j, b.j, c.j);
            this.i = this.a(a, this.i, b.i, c.i);
            this.c = this.a(a, this.c, b.c, c.c);
            this.f = this.a(a, this.f, b.f, c.f);
            this.d = this.a(a, this.d, b.d, c.d);
            this.g = this.a(a, this.g, b.g, c.g);
            this.h = this.a(a, this.h, b.h, c.h);
            this.e = this.b(a, this.e, b.e, c.e);
            this.y(a, this.k, b.k, c.k);
        }
        y(a, b, c, d) {
            InterpolationUtil.c(RadialGaugeRangeFrame.$, b, a, c, d, () => new RadialGaugeRangeFrame(), RadialGaugeRangeFrame.a);
        }
    }
    RadialGaugeScaleFrame.$t = /*@__PURE__*/ markType(RadialGaugeScaleFrame, 'RadialGaugeScaleFrame');
    return RadialGaugeScaleFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BackingFrame = /*@__PURE__*/ (() => {
    class BackingFrame extends Base {
        constructor() {
            super();
            this.l = null;
            this.m = null;
            this.h = 0;
            this.g = 0;
            this.c = 0;
            this.f = 0;
            this.e = 0;
            this.d = 0;
            this.b = 0;
        }
        k(a, b, c) {
            this.h = b.h + (c.h - b.h) * a;
            this.l = BrushUtil.k(b.l, a, c.l, 0);
            this.m = BrushUtil.k(b.m, a, c.m, 0);
            this.g = b.g + (c.g - b.g) * a;
            this.c = b.c + (c.c - b.c) * a;
            this.e = b.e + (c.e - b.e) * a;
            this.d = b.d + (c.d - b.d) * a;
            this.b = b.b + (c.b - b.b) * a;
            this.f = b.f + (c.f - b.f) * a;
        }
        i(a, b, c, d) {
            a._startPoint = { $type: Point_$type, x: b * this.e + c, y: 0 + d };
            let e = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: -1 * b * this.e + c, y: 0 + d };
                $ret.b = false;
                $ret.d = 1;
                $ret.f = new Size(1, b * this.e, b * this.e);
                return $ret;
            })());
            let f = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: b * this.e + c, y: 0 + d };
                $ret.b = false;
                $ret.d = 1;
                $ret.f = new Size(1, b * this.e, b * this.e);
                return $ret;
            })());
            a._segments.add(e);
            a._segments.add(f);
            a._isClosed = true;
        }
        n(a, b, c) {
            let d = new PathGeometry();
            let e = new PathFigure();
            if (this.g == this.c) {
                this.i(e, a, b, c);
            }
            else {
                let f = this.e;
                let g = this.d;
                let h = this.g;
                let i = this.c;
                let j = this.f;
                let k = h;
                let l = i;
                h -= j;
                i += j;
                if ((i - h) > 2 * Math.PI) {
                    this.i(e, a, b, c);
                }
                else {
                    this.j(e, a, b, c);
                }
            }
            e._isClosed = true;
            d.c.add(e);
            return d;
        }
        a(a, b) {
            return Math.abs(a - b) < 1E-05;
        }
        j(a, b, c, d) {
            let e = this.e;
            let f = this.d;
            let g = this.g;
            let h = this.c;
            let i = this.f;
            let j = g;
            let k = h;
            g -= i;
            h += i;
            let l = Math.sin(g);
            let m = Math.cos(g);
            let n = Math.sin(h);
            let o = Math.cos(h);
            let p = this.b;
            let q = b * e;
            let r = b * f;
            if (p * 2 > (q - r)) {
                p = (q - r) / 2;
            }
            let s = p / (b - p);
            let t = Math.atan(s);
            let u = q - p;
            let v = r + p;
            let w = Math.sin(g - t);
            let x = Math.sin(g + t);
            let y = Math.cos(g - t);
            let z = Math.cos(g + t);
            let aa = Math.sin(h - t);
            let ab = Math.sin(h + t);
            let ac = Math.cos(h - t);
            let ad = Math.cos(h + t);
            let ae = Math.sin(j);
            let af = Math.sin(k);
            let ag = Math.cos(j);
            let ah = Math.cos(k);
            a._startPoint = { $type: Point_$type, x: m * u + c, y: l * u + d };
            let ai = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: z * q + c, y: x * q + d };
                $ret.b = (t * 2) > Math.PI;
                $ret.d = 1;
                $ret.f = new Size(1, p, p);
                return $ret;
            })());
            let aj = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: ac * q + c, y: aa * q + d };
                $ret.b = ((h - t) - (g + t)) > Math.PI;
                $ret.d = 1;
                $ret.f = new Size(1, q, q);
                return $ret;
            })());
            let ak = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: o * u + c, y: n * u + d };
                $ret.b = (t * 2) > Math.PI;
                $ret.d = 1;
                $ret.f = new Size(1, p, p);
                return $ret;
            })());
            let al = { $type: Point_$type, x: ah * q + c, y: af * q + d };
            let am = { $type: Point_$type, x: ah * r + c, y: af * r + d };
            let an = { $type: Point_$type, x: o * q + c, y: n * q + d };
            let ao = { $type: Point_$type, x: o * r + c, y: n * r + d };
            let ap = an.y;
            let aq = an.x;
            if (al.x - am.x != 0) {
                aq = c;
                let ar = (al.y - am.y) / (al.x - am.x);
                ap = ar * (c - an.x) + an.y;
            }
            ao = { $type: Point_$type, x: c, y: ap };
            if (this.a(ao.x, an.x) && this.a(ao.y, an.y)) {
                ao = am;
            }
            let as = GeometryUtil.i(ao, an, { $type: Point_$type, x: c, y: d }, r);
            let at = { $type: Point_$type, x: ag * q + c, y: ae * q + d };
            let au = { $type: Point_$type, x: ag * r + c, y: ae * r + d };
            let av = { $type: Point_$type, x: m * q + c, y: l * q + d };
            let aw = { $type: Point_$type, x: m * r + c, y: l * r + d };
            let ax = av.y;
            let ay = av.x;
            if (at.x - au.x != 0) {
                ay = c;
                let az = (at.y - au.y) / (at.x - au.x);
                ax = az * (c - av.x) + av.y;
            }
            aw = { $type: Point_$type, x: ay, y: ax };
            if (this.a(aw.x, av.x) && this.a(aw.y, av.y)) {
                aw = au;
            }
            let a0 = GeometryUtil.i(aw, av, { $type: Point_$type, x: c, y: d }, r);
            if (isNaN_(as.c.x) || isNaN_(as.c.y) || isNaN_(as.d.x) || isNaN_(as.d.y) || isNaN_(a0.c.x) || isNaN_(a0.c.y) || isNaN_(a0.d.x) || isNaN_(a0.d.y)) {
                a._startPoint = { $type: Point_$type, x: m * q + c, y: l * q + d };
                a._segments.add(aj);
                let a1 = ((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: m * q + c, y: l * q + d };
                    return $ret;
                })());
                a._segments.add(a1);
            }
            else {
                let a2;
                let a3;
                if ((Math.pow(as.c.x - an.x, 2) + Math.pow(as.c.y - an.y, 2)) < (Math.pow(as.d.x - an.x, 2) + Math.pow(as.d.y - an.y, 2))) {
                    a2 = as.c;
                }
                else {
                    a2 = as.d;
                }
                if ((Math.pow(a0.c.x - av.x, 2) + Math.pow(a0.c.y - av.y, 2)) < (Math.pow(a0.d.x - av.x, 2) + Math.pow(a0.d.y - av.y, 2))) {
                    a3 = a0.c;
                }
                else {
                    a3 = a0.d;
                }
                if ((Math.pow(a3.x - an.x, 2) + Math.pow(a3.y - an.y, 2)) <= (Math.pow(a2.x - an.x, 2) + Math.pow(a2.y - an.y, 2))) {
                    a._startPoint = { $type: Point_$type, x: m * q + c, y: l * q + d };
                    a._segments.add(aj);
                    let a4 = ((() => {
                        let $ret = new LineSegment(1);
                        $ret.c = { $type: Point_$type, x: m * q + c, y: l * q + d };
                        return $ret;
                    })());
                    a._segments.add(a4);
                }
                else {
                    a._segments.add(ai);
                    a._segments.add(aj);
                    a._segments.add(ak);
                    let a5 = ((() => {
                        let $ret = new LineSegment(1);
                        $ret.c = a2;
                        return $ret;
                    })());
                    a._segments.add(a5);
                    let a6 = GeometryUtil.e({ $type: Point_$type, x: c, y: d }, a2);
                    let a7 = GeometryUtil.e({ $type: Point_$type, x: c, y: d }, a3);
                    while (a7 < a6) {
                        a7 += 2 * Math.PI;
                    }
                    let a8 = ((() => {
                        let $ret = new ArcSegment();
                        $ret.e = a3;
                        $ret.b = a7 - a6 > Math.PI;
                        $ret.d = 1;
                        $ret.f = new Size(1, r, r);
                        return $ret;
                    })());
                    a._segments.add(a8);
                    let a9 = ((() => {
                        let $ret = new LineSegment(1);
                        $ret.c = { $type: Point_$type, x: m * u + c, y: l * u + d };
                        return $ret;
                    })());
                    a._segments.add(a9);
                }
            }
        }
    }
    BackingFrame.$t = /*@__PURE__*/ markType(BackingFrame, 'BackingFrame');
    return BackingFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadialGaugeFrame = /*@__PURE__*/ (() => {
    class RadialGaugeFrame extends Base {
        constructor() {
            super();
            this.b = null;
            this.c = null;
            this.a = null;
            this.d = 0;
            this.b = new RadialGaugeNeedleFrame();
            this.c = new RadialGaugeScaleFrame();
            this.a = new BackingFrame();
        }
        e(a, b, c) {
            this.d = b.d + (c.d - b.d) * a;
            this.b.ag(a, b.b, c.b);
            this.c.x(a, b.c, c.c);
            this.a.k(a, b.a, c.a);
        }
    }
    RadialGaugeFrame.$t = /*@__PURE__*/ markType(RadialGaugeFrame, 'RadialGaugeFrame');
    return RadialGaugeFrame;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FormatRadialGaugeLabelEventArgs = /*@__PURE__*/ (() => {
    class FormatRadialGaugeLabelEventArgs extends EventArgs {
        constructor() {
            super(...arguments);
            this.actualMinimumValue = 0;
            this.actualMaximumValue = 0;
            this.startAngle = 0;
            this.endAngle = 0;
            this.angle = 0;
            this.value = 0;
            this.label = null;
        }
    }
    FormatRadialGaugeLabelEventArgs.$t = /*@__PURE__*/ markType(FormatRadialGaugeLabelEventArgs, 'FormatRadialGaugeLabelEventArgs', EventArgs.$);
    return FormatRadialGaugeLabelEventArgs;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let AlignRadialGaugeLabelEventArgs = /*@__PURE__*/ (() => {
    class AlignRadialGaugeLabelEventArgs extends FormatRadialGaugeLabelEventArgs {
        constructor() {
            super(...arguments);
            this.width = 0;
            this.height = 0;
            this.offsetX = 0;
            this.offsetY = 0;
        }
    }
    AlignRadialGaugeLabelEventArgs.$t = /*@__PURE__*/ markType(AlignRadialGaugeLabelEventArgs, 'AlignRadialGaugeLabelEventArgs', FormatRadialGaugeLabelEventArgs.$);
    return AlignRadialGaugeLabelEventArgs;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadialGaugeNeedleParameters = /*@__PURE__*/ (() => {
    class RadialGaugeNeedleParameters extends Base {
        constructor() {
            super(...arguments);
            this.m = 0;
            this.k = 0;
            this.n = 0;
            this.l = 0;
            this.e = 0;
            this.d = 0;
            this.q = 0;
            this.p = 0;
            this.j = 0;
            this.b = 0;
            this.c = 0;
            this.i = 0;
            this.r = null;
            this.s = null;
            this.h = 0;
            this.t = null;
            this.u = null;
            this.o = 0;
            this.g = 0;
            this.f = 0;
        }
        a() {
            let a = new RadialGaugeNeedleParameters();
            a.m = this.m;
            a.k = this.k;
            a.n = this.n;
            a.l = this.l;
            a.e = this.e;
            a.d = this.d;
            a.q = this.q;
            a.p = this.p;
            a.b = this.b;
            a.c = this.c;
            a.i = this.i;
            a.r = this.r;
            a.s = this.s;
            a.h = this.h;
            a.t = this.t;
            a.u = this.u;
            a.o = this.o;
            a.g = this.g;
            a.f = this.f;
            return a;
        }
    }
    RadialGaugeNeedleParameters.$t = /*@__PURE__*/ markType(RadialGaugeNeedleParameters, 'RadialGaugeNeedleParameters');
    return RadialGaugeNeedleParameters;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadialGaugeNeedlePreparer = /*@__PURE__*/ (() => {
    class RadialGaugeNeedlePreparer extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        e(a) {
            let b = this.b;
            a.aj = b.t;
            a.ak = b.u;
            a.ah = b.r;
            a.ai = b.s;
            a.ae = b.o;
            a.aa = b.h;
            switch (b.b) {
                case 0:
                    this.i(a);
                    break;
                case 1:
                    this.j(a);
                    break;
                case 2:
                    this.n(a);
                    break;
                case 4:
                    this.l(a);
                    break;
                case 5:
                    this.k(a);
                    break;
                case 3:
                    this.g(a);
                    break;
                case 7:
                    this.h(a);
                    break;
                case 8:
                    this.m(a);
                    break;
                case 6:
                    this.o(a);
                    break;
            }
            switch (b.c) {
                case 3:
                    this.d(a, true, false);
                    break;
                case 5:
                    this.d(a, false, false);
                    break;
                case 4:
                    this.d(a, true, true);
                    break;
                case 6:
                    this.d(a, false, true);
                    break;
            }
        }
        d(a, b, c) {
            let d = this.a();
            let e = d.i;
            let f = d.g;
            let g = d.f;
            let h = a.m;
            if (b) {
                h = a.i;
            }
            let i = h.f;
            h.b = true;
            h.c = true;
            h.d = false;
            h.h = e;
            i.add({ $type: Point_$type, x: 0 + e, y: 0 });
            i.add({ $type: Point_$type, x: 0 - e, y: 0 });
            h = a.p;
            if (b) {
                h = a.l;
            }
            i = h.f;
            h.b = true;
            h.c = true;
            h.d = true;
            h.h = e;
            i.add({ $type: Point_$type, x: 0 - e, y: 0 });
            i.add({ $type: Point_$type, x: 0 + e, y: 0 });
            if (c) {
                h = a.n;
                if (b) {
                    h = a.j;
                }
                i = h.f;
                h.b = true;
                h.c = false;
                h.d = false;
                h.h = g;
                i.add({ $type: Point_$type, x: 0 + g, y: 0 });
                i.add({ $type: Point_$type, x: 0 - g, y: 0 });
                h = a.o;
                if (b) {
                    h = a.k;
                }
                i = h.f;
                h.b = true;
                h.c = false;
                h.d = true;
                h.h = g;
                i.add({ $type: Point_$type, x: 0 - g, y: 0 });
                i.add({ $type: Point_$type, x: 0 + g, y: 0 });
            }
        }
        o(a) {
            this.f(a, false, true, false, true);
        }
        m(a) {
            this.f(a, false, false, true, true);
        }
        l(a) {
            this.f(a, false, false, true, false);
        }
        n(a) {
            this.f(a, false, true, false, false);
        }
        h(a) {
            this.f(a, false, false, false, true);
        }
        c(a, b, c, d, e) {
            let f = 0;
            if (c == a) {
                f = 0;
            }
            else {
                f = (e - a) / (c - a);
            }
            let g = b + (d - b) * f;
            return g;
        }
        f(a, b, c, d, e) {
            this.p(a);
            let f = this.a();
            a.ad = f.m;
            a.ac = f.k;
            a.af = 0;
            if (!isNaN_(f.l)) {
                a.af = Math.max(a.af, f.l);
            }
            if (!isNaN_(f.i)) {
                a.af = Math.max(a.af, f.i);
            }
            if (!isNaN_(f.q)) {
                a.af = Math.max(a.af, f.q);
            }
            if (!isNaN_(f.e)) {
                a.af = Math.max(a.af, f.e);
            }
            if (c) {
                f.p = f.k;
                f.q = 0;
            }
            if (d) {
                f.p = f.k;
                f.q = f.l;
            }
            if (b) {
                let g = Math.max(f.n, f.l);
                f.n = g;
                f.l = g;
                f.p = f.k;
                f.q = f.l;
            }
            if (isNaN_(f.p)) {
                f.p = f.k;
            }
            let h = f.c == 1 || f.c == 2;
            let i = f.n;
            let j = f.l;
            if (!d && !b) {
                j = 0;
            }
            let k = f.q;
            let l = f.i;
            let m = f.m;
            let n = f.k;
            let o = f.d;
            let p = f.p;
            let q = f.e;
            let r = true;
            let s = true;
            if (isNaN_(p)) {
                r = false;
                p = n;
            }
            if (isNaN_(o)) {
                s = false;
                o = m;
            }
            let t = f.f;
            let u = f.g;
            let v = 0;
            let w = u;
            let x = u;
            let y = this.c(m, i, p, k, u);
            let z = y;
            let aa = f.c == 2;
            if (h) {
                let ab = GeometryUtil.i({ $type: Point_$type, x: m, y: i }, { $type: Point_$type, x: p, y: k }, { $type: Point_$type, x: 0, y: 0 }, l);
                if (isNaN_(ab.c.x) || isNaN_(ab.c.y) || isNaN_(ab.d.x) || isNaN_(ab.d.y)) {
                    h = false;
                }
                else {
                    let ac = ab.c;
                    let ad = ab.d;
                    w = ac.x;
                    x = ad.x;
                    y = ac.y;
                    z = ad.y;
                    if (w > x) {
                        let ae = w;
                        w = x;
                        x = ae;
                        ae = y;
                        y = z;
                        z = ae;
                    }
                }
            }
            if (aa) {
                let af = GeometryUtil.i({ $type: Point_$type, x: m, y: i }, { $type: Point_$type, x: p, y: k }, { $type: Point_$type, x: 0, y: 0 }, t);
                if ((isNaN_(af.c.x) || isNaN_(af.c.y) || isNaN_(af.d.x) || isNaN_(af.d.y)) || h) {
                    aa = true;
                }
                else {
                    aa = false;
                }
            }
            if (m > x || n < w) {
                h = false;
                w = m;
                x = m;
            }
            let ag = false;
            let ah = false;
            if (h && m >= w) {
                ag = true;
            }
            if (h && n <= x) {
                ah = true;
            }
            if (isNaN_(o) || o > w) {
                o = w;
            }
            if (p < x) {
                p = x;
            }
            let ai = e;
            let aj = l;
            let ak = l;
            if (o + q > w) {
                ai = false;
            }
            let al = o;
            let am = i;
            let an = o;
            let ao = i;
            let ap = w;
            let aq = x;
            let ar = y;
            let as = z;
            let at = w;
            let au = x;
            let av = y;
            let aw = z;
            if (ai) {
                let ax = GeometryUtil.i({ $type: Point_$type, x: m, y: i }, { $type: Point_$type, x: p, y: k }, { $type: Point_$type, x: o, y: 0 }, q);
                if ((!isNaN_(ax.c.x) && !isNaN_(ax.c.y) && !isNaN_(ax.d.x) && !isNaN_(ax.d.y))) {
                    ai = true;
                    al = ax.c.x;
                    am = ax.c.y;
                    an = ax.d.x;
                    ao = ax.d.y;
                    if (al > an) {
                        let ay = al;
                        al = an;
                        an = ay;
                        ay = am;
                        am = ao;
                        ao = ay;
                    }
                }
                else {
                    ai = false;
                }
            }
            if (ag) {
                ai = false;
            }
            if (ai && m >= al) {
                ag = true;
                aj = q;
                ap = al;
                ar = am;
                aq = an;
                as = ao;
            }
            if (ai && n <= an) {
                ah = true;
                ak = q;
                ak = q;
                at = al;
                av = am;
                au = an;
                aw = ao;
            }
            let az = m;
            let a0 = a.a;
            let a1 = a0.f;
            let a2 = i;
            if (ag) {
                az = ap;
                a0.b = true;
                a0.d = false;
                a0.c = false;
                a0.h = aj;
                o = ap;
                m = ap;
                a2 = ar;
                i = ar;
                h = false;
            }
            if (ah) {
                p = au;
                n = au;
                h = false;
            }
            let a3 = ag || ah || h;
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a0 = a.d;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: a2 });
            az = al;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a0 = a.b;
            a1 = a0.f;
            if (ai) {
                a0.b = true;
                a0.d = false;
                a0.c = false;
                a0.h = q;
            }
            a1.add({ $type: Point_$type, x: az, y: a2 });
            az = an;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a0 = a.t;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: a2 });
            az = w;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a0 = a.e;
            a1 = a0.f;
            if (a3) {
                a0.b = true;
                a0.d = false;
                a0.c = false;
                a0.h = l;
            }
            a1.add({ $type: Point_$type, x: az, y: a2 });
            az = x;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a0 = a.f;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: a2 });
            az = p;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a0 = a.x;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a0 = a.v;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: a2 });
            az = n;
            a2 = this.c(p, k, n, j, az);
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a0 = a.w;
            a1 = a0.f;
            if (ah) {
                az = au;
                a0.b = true;
                a0.d = false;
                a0.c = false;
                a0.h = ak;
            }
            a1.add({ $type: Point_$type, x: az, y: a2 });
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a0 = a.z;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            az = p;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a0 = a.y;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a0 = a.u;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            az = x;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a0 = a.h;
            a1 = a0.f;
            if (a3) {
                a0.b = true;
                a0.d = false;
                a0.c = false;
                a0.h = l;
            }
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            az = w;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a0 = a.g;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            az = an;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a0 = a.c;
            a1 = a0.f;
            if (ai) {
                a0.b = true;
                a0.d = false;
                a0.c = false;
                a0.h = q;
            }
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            az = al;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a0 = a.s;
            a1 = a0.f;
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            az = m;
            a2 = this.c(m, i, p, k, az);
            a1.add({ $type: Point_$type, x: az, y: -1 * a2 });
            a0 = a.q;
            a1 = a0.f;
            if (aa && a3) {
                a0.b = true;
                a0.c = true;
                a0.d = false;
                a0.h = t;
                a1.add({ $type: Point_$type, x: 0 + t, y: 0 });
                a1.add({ $type: Point_$type, x: 0 - t, y: 0 });
            }
            a0 = a.r;
            a1 = a0.f;
            if (aa && a3) {
                a0.b = true;
                a0.c = true;
                a0.d = true;
                a0.h = t;
                a1.add({ $type: Point_$type, x: 0 - t, y: 0 });
                a1.add({ $type: Point_$type, x: 0 + t, y: 0 });
            }
        }
        g(a) {
            this.f(a, false, false, false, false);
        }
        k(a) {
            this.f(a, true, false, false, true);
        }
        a() {
            let a = this.b;
            let b = this.b.a();
            let c = 0;
            let d = 0.48;
            let e = NaN;
            let f = NaN;
            let g = 0.15;
            let h = 0.1;
            let i = 0.1;
            let j = 0.1;
            let k = 0.14;
            let l = 0.06;
            switch (a.b) {
                case 3:
                    f = 0.4;
                    break;
                case 4:
                    h = 0.06;
                    i = 0.02;
                    break;
                case 7:
                    f = 0.4;
                    c = -0.3;
                    e = -0.2;
                    k = 0.14;
                    break;
                case 5:
                    c = -0.3;
                    e = -0.2;
                    k = 0.14;
                    break;
                case 8:
                    i = 0.06;
                    c = -0.3;
                    e = -0.2;
                    k = 0.14;
                    break;
                case 6:
                    c = -0.3;
                    e = -0.2;
                    k = 0.14;
                    break;
            }
            let m = a.m;
            let n = a.k;
            let o = a.c == 1 || a.c == 2;
            if (isNaN_(m)) {
                m = c;
            }
            if (isNaN_(n)) {
                n = d;
            }
            let p = Math.min(m, n);
            let q = Math.max(m, n);
            m = p;
            n = q;
            let r = a.n;
            if (isNaN_(r)) {
                r = h;
            }
            let s = a.l;
            if (isNaN_(s)) {
                s = i;
            }
            let t = a.i;
            let u = a.f;
            if (isNaN_(t)) {
                t = g;
            }
            if (isNaN_(u)) {
                u = j;
            }
            let v = Math.max(t, u);
            let w = Math.min(t, u);
            t = v;
            u = w;
            let x = a.d;
            if (isNaN_(x)) {
                x = e;
            }
            if (!isNaN_(x)) {
                if (x < m) {
                    x = NaN;
                }
                if (x > 0 && m <= 0) {
                    x = NaN;
                }
                if (x > n) {
                    x = n;
                }
            }
            let y = a.p;
            if (isNaN_(y)) {
                y = f;
            }
            if (!isNaN_(y)) {
                if (y > n) {
                    y = NaN;
                }
                if (y < 0 && n >= 0) {
                    y = NaN;
                }
                if (y < m) {
                    y = m;
                }
            }
            let z = 0;
            if (m > 0) {
                z = m;
            }
            if (n < 0) {
                z = m;
            }
            if (t <= 0) {
                t = 0;
            }
            let aa = a.e;
            let ab = a.q;
            if (isNaN_(aa)) {
                aa = k;
            }
            if (isNaN_(ab)) {
                ab = l;
            }
            b.i = t / 2;
            b.f = u / 2;
            b.d = x;
            b.p = y;
            b.m = m;
            b.k = n;
            b.g = z;
            b.n = r / 2;
            b.l = s / 2;
            b.q = ab / 2;
            b.e = aa / 2;
            return b;
        }
        j(a) {
            this.f(a, true, false, false, false);
        }
        p(a) {
            a.a.k();
            a.d.k();
            a.b.k();
            a.t.k();
            a.e.k();
            a.f.k();
            a.x.k();
            a.v.k();
            a.w.k();
            a.z.k();
            a.y.k();
            a.u.k();
            a.h.k();
            a.g.k();
            a.c.k();
            a.s.k();
            a.q.k();
            a.r.k();
            a.i.k();
            a.l.k();
            a.m.k();
            a.p.k();
            a.j.k();
            a.k.k();
            a.n.k();
            a.o.k();
        }
        i(a) {
            this.p(a);
            let b = 0;
            let c = 0;
            let d = 0;
            let e = 0;
            let f = 0;
            let g = 0;
            let h = 0;
            let i = a.a;
            let j = i.f;
            j.add({ $type: Point_$type, x: b, y: h });
            j.add({ $type: Point_$type, x: b, y: g });
            i = a.d;
            j = i.f;
            j.add({ $type: Point_$type, x: b, y: g });
            j.add({ $type: Point_$type, x: d, y: g });
            i = a.b;
            j = i.f;
            j.add({ $type: Point_$type, x: d, y: g });
            j.add({ $type: Point_$type, x: d, y: g });
            let k = f;
            let l = f;
            i = a.t;
            j = i.f;
            j.add({ $type: Point_$type, x: d, y: g });
            j.add({ $type: Point_$type, x: k, y: g });
            i = a.e;
            j = i.f;
            j.add({ $type: Point_$type, x: k, y: g });
            j.add({ $type: Point_$type, x: l, y: g });
            i = a.f;
            j = i.f;
            j.add({ $type: Point_$type, x: l, y: g });
            j.add({ $type: Point_$type, x: e, y: g });
            i = a.x;
            j = i.f;
            j.add({ $type: Point_$type, x: e, y: g });
            j.add({ $type: Point_$type, x: e, y: g });
            i = a.v;
            j = i.f;
            j.add({ $type: Point_$type, x: e, y: g });
            j.add({ $type: Point_$type, x: c, y: g });
            i = a.w;
            j = i.f;
            j.add({ $type: Point_$type, x: c, y: g });
            j.add({ $type: Point_$type, x: c, y: h });
            i = a.z;
            j = i.f;
            j.add({ $type: Point_$type, x: c, y: h });
            j.add({ $type: Point_$type, x: e, y: h });
            i = a.y;
            j = i.f;
            j.add({ $type: Point_$type, x: e, y: h });
            j.add({ $type: Point_$type, x: e, y: h });
            i = a.u;
            j = i.f;
            j.add({ $type: Point_$type, x: e, y: h });
            j.add({ $type: Point_$type, x: l, y: h });
            i = a.h;
            j = i.f;
            j.add({ $type: Point_$type, x: l, y: h });
            j.add({ $type: Point_$type, x: k, y: h });
            i = a.g;
            j = i.f;
            j.add({ $type: Point_$type, x: k, y: h });
            j.add({ $type: Point_$type, x: d, y: h });
            i = a.c;
            j = i.f;
            j.add({ $type: Point_$type, x: d, y: h });
            j.add({ $type: Point_$type, x: d, y: h });
            i = a.s;
            j = i.f;
            j.add({ $type: Point_$type, x: d, y: h });
            j.add({ $type: Point_$type, x: b, y: h });
        }
    }
    RadialGaugeNeedlePreparer.$t = /*@__PURE__*/ markType(RadialGaugeNeedlePreparer, 'RadialGaugeNeedlePreparer');
    return RadialGaugeNeedlePreparer;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GaugeVisualData = /*@__PURE__*/ (() => {
    class GaugeVisualData extends Base {
        constructor() {
            super(...arguments);
            this._scalePath = null;
            this._needlePath = null;
            this._backingPath = null;
            this._underlayPath = null;
            this._overlayPath = null;
            this._scale = null;
            this._scaleLabels = null;
            this._scaleTickmarks = null;
            this._needle = null;
            this._ranges = null;
            this._name = null;
            this._viewport = null;
        }
        get scalePath() {
            return this._scalePath;
        }
        set scalePath(a) {
            this._scalePath = a;
        }
        get needlePath() {
            return this._needlePath;
        }
        set needlePath(a) {
            this._needlePath = a;
        }
        get backingPath() {
            return this._backingPath;
        }
        set backingPath(a) {
            this._backingPath = a;
        }
        get underlayPath() {
            return this._underlayPath;
        }
        set underlayPath(a) {
            this._underlayPath = a;
        }
        get overlayPath() {
            return this._overlayPath;
        }
        set overlayPath(a) {
            this._overlayPath = a;
        }
        get scale() {
            return this._scale;
        }
        set scale(a) {
            this._scale = a;
        }
        get scaleLabels() {
            return this._scaleLabels;
        }
        set scaleLabels(a) {
            this._scaleLabels = a;
        }
        get scaleTickmarks() {
            return this._scaleTickmarks;
        }
        set scaleTickmarks(a) {
            this._scaleTickmarks = a;
        }
        get needle() {
            return this._needle;
        }
        set needle(a) {
            this._needle = a;
        }
        get ranges() {
            return this._ranges;
        }
        set ranges(a) {
            this._ranges = a;
        }
        get name() {
            return this._name;
        }
        set name(a) {
            this._name = a;
        }
        scaleByViewport() {
            if (this.scalePath != null) {
                this.scalePath.scaleByViewport(this.viewport);
            }
            if (this.needlePath != null) {
                this.needlePath.scaleByViewport(this.viewport);
            }
            if (this.backingPath != null) {
                this.backingPath.scaleByViewport(this.viewport);
            }
            if (this.underlayPath != null) {
                this.underlayPath.scaleByViewport(this.viewport);
            }
            if (this.overlayPath != null) {
                this.overlayPath.scaleByViewport(this.viewport);
            }
            if (this.scaleLabels != null) {
                for (let a of fromEnum(this.scaleLabels)) {
                    a.scaleByViewport(this.viewport);
                }
            }
            if (this.scaleTickmarks != null) {
                for (let b of fromEnum(this.scaleTickmarks)) {
                    if (b.tickPath != null) {
                        b.tickPath.scaleByViewport(this.viewport);
                    }
                }
            }
            if (this.ranges != null) {
                for (let c of fromEnum(this.ranges)) {
                    if (c.rangePath != null) {
                        c.rangePath.scaleByViewport(this.viewport);
                    }
                }
            }
        }
        serialize() {
            let a = new StringBuilder(0);
            let b = true;
            a.u("{");
            if (this.scalePath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("scalePath: ");
                a.u(this.scalePath.serialize());
            }
            if (this.needlePath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("needlePath: ");
                a.u(this.needlePath.serialize());
            }
            if (this.backingPath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("backingPath: ");
                a.u(this.backingPath.serialize());
            }
            if (this.underlayPath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("underlayPath: ");
                a.u(this.underlayPath.serialize());
            }
            if (this.overlayPath != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("overlayPath: ");
                a.u(this.overlayPath.serialize());
            }
            if (this.scaleLabels != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                let c = true;
                a.l("scaleLabels: [");
                for (let d of fromEnum(this.scaleLabels)) {
                    if (c) {
                        c = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(d.serialize());
                }
                a.u("]");
            }
            if (this.scaleTickmarks != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                let e = true;
                a.l("scaleTickmarks: [");
                for (let f of fromEnum(this.scaleTickmarks)) {
                    if (e) {
                        e = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(f.serialize());
                }
                a.u("]");
            }
            if (this.needle != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("needle: ");
                a.u(this.needle.serialize());
            }
            if (this.ranges != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                let g = true;
                a.l("ranges: [");
                for (let h of fromEnum(this.ranges)) {
                    if (g) {
                        g = false;
                    }
                    else {
                        a.l(", ");
                    }
                    a.u(h.serialize());
                }
                a.u("]");
            }
            if (this.name != null) {
                if (b) {
                    b = false;
                }
                else {
                    a.l(", ");
                }
                a.l("name: '");
                a.l(this.name);
                a.u("'");
            }
            if (b) {
                b = false;
            }
            else {
                a.l(", ");
            }
            a.l("viewport: {");
            a.l("left: " + this.viewport.left + ", top: " + this.viewport.top + ", width: " + this.viewport.width + ", height: " + this.viewport.height);
            a.u("}");
            a.u("}");
            return a.toString();
        }
        get viewport() {
            return this._viewport;
        }
        set viewport(a) {
            this._viewport = a;
        }
    }
    GaugeVisualData.$t = /*@__PURE__*/ markType(GaugeVisualData, 'GaugeVisualData');
    return GaugeVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ScaleLabelVisualData = /*@__PURE__*/ (() => {
    class ScaleLabelVisualData extends Base {
        constructor() {
            super(...arguments);
            this._labelValue = null;
            this._labelSize = null;
            this._labelPosition = null;
            this._appearance = null;
        }
        get labelValue() {
            return this._labelValue;
        }
        set labelValue(a) {
            this._labelValue = a;
        }
        get labelSize() {
            return this._labelSize;
        }
        set labelSize(a) {
            this._labelSize = a;
        }
        get labelPosition() {
            return this._labelPosition;
        }
        set labelPosition(a) {
            this._labelPosition = a;
        }
        get appearance() {
            return this._appearance;
        }
        set appearance(a) {
            this._appearance = a;
        }
        scaleByViewport(a) {
            this.labelPosition = new PointData((this.labelPosition.x - a.left) / a.width, (this.labelPosition.y - a.top) / a.height);
            this.labelSize = new SizeData((this.labelSize.width) / a.width, (this.labelSize.height) / a.height);
        }
        serialize() {
            return "{ labelValue: '" + this.labelValue + "', labelSize: { width: " + this.labelSize.width + ", height: " + this.labelSize.height + "}, labelPosition: { x: " + this.labelPosition.x + ", y: " + this.labelPosition.y + "}, appearance: " + this.appearance.serialize() + "}";
        }
    }
    ScaleLabelVisualData.$t = /*@__PURE__*/ markType(ScaleLabelVisualData, 'ScaleLabelVisualData');
    return ScaleLabelVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ScaleLabelVisualDataList = /*@__PURE__*/ (() => {
    class ScaleLabelVisualDataList extends List$1 {
        constructor() {
            super(ScaleLabelVisualData.$, 0);
        }
    }
    ScaleLabelVisualDataList.$t = /*@__PURE__*/ markType(ScaleLabelVisualDataList, 'ScaleLabelVisualDataList', /*@__PURE__*/ List$1.$.specialize(ScaleLabelVisualData.$));
    return ScaleLabelVisualDataList;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ScaleTickmarkVisualData = /*@__PURE__*/ (() => {
    class ScaleTickmarkVisualData extends Base {
        constructor() {
            super(...arguments);
            this._tickPath = null;
        }
        get tickPath() {
            return this._tickPath;
        }
        set tickPath(a) {
            this._tickPath = a;
        }
        serialize() {
            return "{ tickPath: " + this.tickPath.serialize() + "}";
        }
    }
    ScaleTickmarkVisualData.$t = /*@__PURE__*/ markType(ScaleTickmarkVisualData, 'ScaleTickmarkVisualData');
    return ScaleTickmarkVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ScaleTickmarkVisualDataList = /*@__PURE__*/ (() => {
    class ScaleTickmarkVisualDataList extends List$1 {
        constructor() {
            super(ScaleTickmarkVisualData.$, 0);
        }
    }
    ScaleTickmarkVisualDataList.$t = /*@__PURE__*/ markType(ScaleTickmarkVisualDataList, 'ScaleTickmarkVisualDataList', /*@__PURE__*/ List$1.$.specialize(ScaleTickmarkVisualData.$));
    return ScaleTickmarkVisualDataList;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RangeVisualData = /*@__PURE__*/ (() => {
    class RangeVisualData extends Base {
        constructor() {
            super(...arguments);
            this._rangePath = null;
        }
        get rangePath() {
            return this._rangePath;
        }
        set rangePath(a) {
            this._rangePath = a;
        }
        serialize() {
            return "{ rangePath: " + this.rangePath.serialize() + "}";
        }
    }
    RangeVisualData.$t = /*@__PURE__*/ markType(RangeVisualData, 'RangeVisualData');
    return RangeVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RangeVisualDataList = /*@__PURE__*/ (() => {
    class RangeVisualDataList extends List$1 {
        constructor() {
            super(RangeVisualData.$, 0);
        }
    }
    RangeVisualDataList.$t = /*@__PURE__*/ markType(RangeVisualDataList, 'RangeVisualDataList', /*@__PURE__*/ List$1.$.specialize(RangeVisualData.$));
    return RangeVisualDataList;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let NeedleVisualData = /*@__PURE__*/ (() => {
    class NeedleVisualData extends Base {
        constructor() {
            super(...arguments);
            this._angle = 0;
        }
        get angle() {
            return this._angle;
        }
        set angle(a) {
            this._angle = a;
        }
        serialize() {
            return "{ angle: " + this.angle.toString() + "}";
        }
    }
    NeedleVisualData.$t = /*@__PURE__*/ markType(NeedleVisualData, 'NeedleVisualData');
    return NeedleVisualData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let XamRadialGauge = /*@__PURE__*/ (() => {
    class XamRadialGauge extends Control {
        constructor() {
            super();
            this.propertyChanged = null;
            this._view = null;
            this.ay = null;
            this.bn = 0;
            this.bm = 100;
            this.a8 = false;
            this.formatLabel = null;
            this.aj = null;
            this.alignLabel = null;
            this.valueChanged = null;
            this.a7 = false;
            this.av = null;
            this.io = new Size(1, NaN, NaN);
            this.il = null;
            this.bj = null;
            this.bk = null;
            this.aq = null;
            this.ap = null;
            this.ao = null;
            this.bl = new Stack$1(TextBlock.$);
            this.bi = new List$1(Path.$, 0);
            this.bh = new List$1(Path.$, 0);
            this.bg = new List$1(Path.$, 0);
            this.bq = 0;
            this.a5 = null;
            this.a3 = null;
            this.a2 = null;
            this.a4 = null;
            this.bp = NaN;
            this.bo = 1;
            this.view = new XamRadialGaugeView(this);
            this.view.av();
            this.il = Rect.empty;
            this.aq = new RadialGaugeFrame();
            this.ap = new RadialGaugeFrame();
            this.ao = new RadialGaugeFrame();
            this.ranges = new RadialGaugeRangeCollection();
            this.a7 = true;
            this.ay = new DoubleAnimator(0, 1, this.dn);
            let a = this.ay;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.fn));
            this.ab = XamRadialGauge.$;
            this.a2 = ((() => {
                let $ret = new StackPool$1(TextBlock.$);
                $ret.b = runOn(this.view, this.view.an);
                $ret.c = runOn(this.view, this.view.ao);
                $ret.d = runOn(this.view, this.view.ap);
                $ret.j = runOn(this.view, this.view.be);
                return $ret;
            })());
            this.a5 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.ay);
                $ret.c = runOn(this.view, this.view.az);
                $ret.d = runOn(this.view, this.view.a0);
                $ret.j = runOn(this.view, this.view.b0);
                return $ret;
            })());
            this.a3 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.ay);
                $ret.c = runOn(this.view, this.view.az);
                $ret.d = runOn(this.view, this.view.a0);
                $ret.j = runOn(this.view, this.view.b0);
                return $ret;
            })());
            this.a4 = ((() => {
                let $ret = new StackPool$1(Path.$);
                $ret.b = runOn(this.view, this.view.a3);
                $ret.c = runOn(this.view, this.view.a4);
                $ret.d = runOn(this.view, this.view.a5);
                $ret.j = runOn(this.view, this.view.b1);
                return $ret;
            })());
            this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
        }
        fz(a) {
            this.f4(a);
        }
        f4(a) {
            let b = this.propertyChanged;
            if (b != null) {
                b(this, new PropertyChangedEventArgs(a));
            }
        }
        onDetachedFromUI() {
            this.view.au();
        }
        onAttachedToUI() {
            this.view.aq();
        }
        dd(a) {
            return this.av.h(a);
        }
        dl(a) {
            return this.av.j(a);
        }
        b5(a) {
            let b = this.im;
            let c = Math.min(b.width / 2, b.height / 2) * this.c0;
            let d = this.ij();
            let e = d.x;
            let f = d.y;
            let g = GeometryUtil.e({ $type: Point_$type, x: e, y: f }, a);
            if (this.av != null && g < this.av.i) {
                g += Math.PI * 2;
            }
            if (this.av != null && g > this.av.g) {
                g -= Math.PI * 2;
            }
            let h = this.dl(g);
            return h;
        }
        ik(a, b) {
            let c = this.dd(a);
            let d = Math.min(this.im.width / 2, this.im.height / 2) * this.c0 * b;
            let e = this.ij();
            let f = e.x + Math.cos(c) * d;
            let g = e.y + Math.sin(c) * d;
            return { $type: Point_$type, x: f, y: g };
        }
        h9(a, b) {
            if (b != null && b.count > 0) {
                return b.item(a % b.count);
            }
            else {
                return null;
            }
        }
        get view() {
            return this._view;
        }
        set view(a) {
            this._view = a;
        }
        fn(a, b) {
            this.dk = this.ay.o;
        }
        get bs() {
            return this.bn;
        }
        set bs(a) {
            this.bn = a;
        }
        get br() {
            return this.bm;
        }
        set br(a) {
            this.bm = a;
        }
        get cw() {
            return this.c(XamRadialGauge.hl);
        }
        set cw(a) {
            this.h(XamRadialGauge.hl, a);
        }
        refresh() {
            this.a7 = true;
            this.view.a7();
        }
        fy(a, b, c) {
            switch (a) {
                case XamRadialGauge.$$p[29]:
                case XamRadialGauge.$$p[32]:
                case XamRadialGauge.$$p[33]:
                case XamRadialGauge.$$p[35]:
                case XamRadialGauge.$$p[0]:
                case XamRadialGauge.$$p[4]:
                case XamRadialGauge.$$p[48]:
                case XamRadialGauge.$$p[56]:
                case XamRadialGauge.$$p[22]:
                    this.view.ar(a, b, c);
                    break;
                case XamRadialGauge.$$p[45]:
                    this.view.aw(b, c);
                    break;
                case XamRadialGauge.$$p[46]:
                    this.view.ax(b, c);
                    break;
                case "PixelScalingRatio":
                    if (isNaN_(DeviceUtils.a(this.cz))) {
                        this.bt = 1;
                    }
                    else {
                        this.bt = DeviceUtils.a(this.cz);
                    }
                    break;
                case "ActualPixelScalingRatio":
                    this.view.a1();
                    break;
            }
            switch (a) {
                case XamRadialGauge.$$p[17]:
                case XamRadialGauge.$$p[18]:
                    if (this.d9 != null) {
                        this.aj = new BindingFormatter();
                        this.aj.j = this.d9;
                        this.aj.d = this.ag;
                    }
                    else {
                        this.aj = null;
                    }
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[62]:
                    if (this.valueChanged != null) {
                        this.valueChanged(this, new DoubleValueChangedEventArgs(b, c));
                    }
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[0]:
                case XamRadialGauge.$$p[4]:
                case XamRadialGauge.$$p[7]:
                case XamRadialGauge.$$p[6]:
                case XamRadialGauge.$$p[2]:
                case XamRadialGauge.$$p[3]:
                case XamRadialGauge.$$p[5]:
                case XamRadialGauge.$$p[1]:
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[55]:
                case XamRadialGauge.$$p[53]:
                case XamRadialGauge.$$p[49]:
                case XamRadialGauge.$$p[51]:
                case XamRadialGauge.$$p[52]:
                    this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[21]:
                case XamRadialGauge.$$p[20]:
                    let d = this.cc;
                    let e = this.ca;
                    if (isInfinity(d) || isNaN_(d)) {
                        d = 0;
                    }
                    if (isInfinity(e) || isNaN_(e)) {
                        e = 100;
                    }
                    this.bs = Math.min(d, e);
                    this.br = Math.max(d, e);
                    this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[13]:
                case XamRadialGauge.$$p[54]:
                case XamRadialGauge.$$p[50]:
                case XamRadialGauge.$$p[16]:
                case XamRadialGauge.$$p[58]:
                case XamRadialGauge.$$p[57]:
                case XamRadialGauge.$$p[56]:
                case XamRadialGauge.$$p[48]:
                case XamRadialGauge.$$p[19]:
                case XamRadialGauge.$$p[23]:
                case XamRadialGauge.$$p[59]:
                case XamRadialGauge.$$p[26]:
                case XamRadialGauge.$$p[22]:
                case XamRadialGauge.$$p[25]:
                case XamRadialGauge.$$p[24]:
                case XamRadialGauge.$$p[8]:
                case XamRadialGauge.$$p[9]:
                case XamRadialGauge.$$p[44]:
                case XamRadialGauge.$$p[10]:
                    this.av = new RadialGaugeScaler(this.bs, this.br, this.da, this.c5, this.ii);
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[42]:
                case XamRadialGauge.$$p[30]:
                case XamRadialGauge.$$p[29]:
                case XamRadialGauge.$$p[32]:
                case "NeedleStartWidth":
                case XamRadialGauge.$$p[31]:
                case XamRadialGauge.$$p[33]:
                case XamRadialGauge.$$p[35]:
                case XamRadialGauge.$$p[43]:
                case XamRadialGauge.$$p[37]:
                case XamRadialGauge.$$p[27]:
                case XamRadialGauge.$$p[28]:
                case XamRadialGauge.$$p[39]:
                case XamRadialGauge.$$p[40]:
                case XamRadialGauge.$$p[38]:
                case XamRadialGauge.$$p[34]:
                case XamRadialGauge.$$p[36]:
                case XamRadialGauge.$$p[41]:
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[60]:
                    this.ay.r = this.dn;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[61]:
                    this.ay.b = this.a0;
                    break;
                case "TransitionProgress":
                    if (this.dk >= 1) {
                        this.ay.w();
                        let f = this.ap;
                        this.ap = this.aq;
                        this.aq = f;
                        this.f1();
                        this.f2();
                        this.f3();
                        this.f9(this.ap);
                        this.ga(this.ap);
                        this.gb(this.ap);
                        this.view.ae();
                        return;
                    }
                    this.ao.e(this.dk, this.aq, this.ap);
                    this.f9(this.ao);
                    this.ga(this.ao);
                    this.gb(this.ao);
                    this.view.ae();
                    break;
                case XamRadialGauge.$$p[47]:
                    let g = b;
                    let h = c;
                    if (g != null) {
                        let i = g;
                        i.collectionChanged = delegateRemove(i.collectionChanged, runOn(this, this.f7));
                    }
                    if (h != null) {
                        let j = h;
                        j.collectionChanged = delegateCombine(j.collectionChanged, runOn(this, this.f7));
                    }
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[46]:
                case XamRadialGauge.$$p[45]:
                    this.a7 = true;
                    this.view.a7();
                    break;
                case XamRadialGauge.$$p[11]:
                case XamRadialGauge.$$p[12]:
                    this.a7 = true;
                    this.view.bd();
                    this.view.a7();
                    break;
            }
            this.fz(a);
        }
        gd() {
            this.view.ba();
        }
        f7(a, b) {
            if (b.oldItems != null) {
                for (let c of fromEn(b.oldItems)) {
                    c.propertyChanged = delegateRemove(c.propertyChanged, runOn(this, this.f6));
                }
            }
            if (b.newItems != null) {
                for (let d of fromEn(b.newItems)) {
                    d.propertyChanged = delegateCombine(d.propertyChanged, runOn(this, this.f6));
                }
            }
            this.a7 = true;
            this.view.a7();
        }
        f6(a, b) {
            this.a7 = true;
            this.view.a7();
        }
        get im() {
            return this.il;
        }
        set im(a) {
            let b = this.il;
            this.il = a;
            if (!b.equals1(this.il)) {
                this.f0(b, this.il);
            }
        }
        f0(a, b) {
            this.a7 = true;
            this.view.a7();
        }
        bb() {
            return !isNaN_(this.bs) && !isNaN_(this.br) && !isNaN_(this.dm) && !this.im.isEmpty && this.view.n();
        }
        fo() {
            if (!this.bb()) {
                return;
            }
            if (this.a7) {
                if (this.a6) {
                    if (this.ay.g) {
                        this.ay.t();
                    }
                    let a = this.aq;
                    this.aq = this.ao;
                    this.ao = a;
                }
                else {
                    let b = this.aq;
                    this.aq = this.ap;
                    this.ap = b;
                }
            }
            else if (this.a6) {
                this.ao.e(this.dk, this.aq, this.ap);
                this.f9(this.ao);
                this.ga(this.ao);
                this.gb(this.ao);
            }
            if (this.a7) {
                this.f2();
                this.f3();
                this.f1();
            }
            if (this.a7 && this.be) {
                this.gc();
                this.ao.e(this.dk, this.aq, this.ap);
                this.f9(this.ao);
                this.ga(this.ao);
                this.gb(this.ao);
            }
            else {
                if (this.a7) {
                    this.f9(this.ap);
                    this.ga(this.ap);
                    this.gb(this.ap);
                }
            }
            this.a7 = false;
            this.view.ae();
        }
        gc() {
            this.bq = 0;
            this.ay.w();
            this.ay.v();
        }
        get be() {
            return this.dn > 0;
        }
        f9(a) {
            let b = this.im;
            let c = this.view.bv();
            let d = a.a;
            let e = Math.min(b.width / 2, b.height / 2) * a.d;
            let f = this.ij();
            let g = f.x;
            let h = f.y;
            let i = d.n(e, g, h);
            c.ak = i;
            c._fill = d.l;
            c._stroke = d.m;
            c.ac = d.h;
        }
        bc(a) {
            if (this.bj == null) {
                return false;
            }
            return PolygonUtil.a(this.bj, a);
        }
        needleContainsPoint(a, b) {
            if (this.bj == null) {
                return false;
            }
            return b ? PolygonUtil.a(this.bk, a) : PolygonUtil.a(this.bj, a);
        }
        ga(a) {
            let b = this.im;
            let c = a.b.ab;
            let d = a.b.aj;
            let e = a.b.ak;
            let f = a.b.ae;
            let g = a.b.ah;
            let h = a.b.ai;
            let i = a.b.aa;
            let j = this.view.bw();
            let k = this.view.bz();
            let l = this.view.bx();
            let m = a.b;
            let n = Math.min(b.width / 2, b.height / 2) * a.d;
            let o = this.ij();
            let p = o.x;
            let q = o.y;
            let r = m.am(n, p, q);
            let s = c * 180 / Math.PI;
            j.ak = r;
            let t = new TransformGroup();
            t.j.add(((() => {
                let $ret = new RotateTransform();
                $ret.k = p;
                $ret.l = q;
                $ret.j = s;
                return $ret;
            })()));
            j.j = t;
            j._fill = d;
            j._stroke = e;
            j.ac = f;
            k.ak = m.an(n, p, q);
            l.ak = m.al(n, p, q);
            k._fill = g;
            k._stroke = h;
            k.ac = i;
            l._fill = g;
            l._stroke = h;
            l.ac = i;
            let u = new List$1(Point_$type, 0);
            let v = Math.cos(c);
            let w = Math.sin(c);
            let x = m.af / 2;
            let y = { $type: Point_$type, x: m.ad * n, y: x * n };
            let z = { $type: Point_$type, x: m.ac * n, y: x * n };
            let aa = { $type: Point_$type, x: m.ac * n, y: -x * n };
            let ab = { $type: Point_$type, x: m.ad * n, y: -x * n };
            y = { $type: Point_$type, x: y.x * v - y.y * w + p, y: y.y * v + y.x * w + q };
            z = { $type: Point_$type, x: z.x * v - z.y * w + p, y: z.y * v + z.x * w + q };
            aa = { $type: Point_$type, x: aa.x * v - aa.y * w + p, y: aa.y * v + aa.x * w + q };
            ab = { $type: Point_$type, x: ab.x * v - ab.y * w + p, y: ab.y * v + ab.x * w + q };
            u.add(y);
            u.add(z);
            u.add(aa);
            u.add(ab);
            this.bj = u;
            x = (m.af / 2) * n;
            let ac = { $type: Point_$type, x: m.ad * n, y: x };
            let ad = { $type: Point_$type, x: m.ac * n, y: x };
            let ae = { $type: Point_$type, x: m.ac * n, y: -x };
            let af = { $type: Point_$type, x: m.ad * n, y: -x };
            ac = { $type: Point_$type, x: ac.x * v - ac.y * w + p, y: ac.y * v + ac.x * w + q };
            ad = { $type: Point_$type, x: ad.x * v - ad.y * w + p, y: ad.y * v + ad.x * w + q };
            ae = { $type: Point_$type, x: ae.x * v - ae.y * w + p, y: ae.y * v + ae.x * w + q };
            af = { $type: Point_$type, x: af.x * v - af.y * w + p, y: af.y * v + af.x * w + q };
            this.bk = new List$1(Point_$type, 0);
            this.bk.add(ac);
            this.bk.add(ad);
            this.bk.add(ae);
            this.bk.add(af);
        }
        ij() {
            let a = this.im;
            let b = isNaN_(this.b3) ? 0.5 : this.b3;
            let c = isNaN_(this.b4) ? 0.5 : this.b4;
            let d = a.left + b * a.width;
            let e = a.top + c * a.height;
            return { $type: Point_$type, x: d, y: e };
        }
        c2(a) {
            if (isInfinity(a)) {
                return NaN;
            }
            return a;
        }
        f2() {
            let a = this.ap;
            a.d = this.c0;
            let b = this.im;
            let c = this.av;
            let d = this.c4(this.dm, 0);
            let e = this.av.h(d);
            let f = new RadialGaugeNeedlePreparer();
            let g = new RadialGaugeNeedleParameters();
            g.b = this.ar;
            g.o = this.c2(this.cx);
            g.t = this.ib;
            g.u = this.ic;
            g.m = this.c2(this.cv);
            g.k = this.c2(this.cn);
            g.d = this.c2(this.cl);
            g.e = this.c2(this.cm);
            g.p = this.c2(this.ct);
            g.q = this.c2(this.cu);
            g.i = this.c2(this.cs);
            g.f = this.c2(this.cp);
            g.r = this.id;
            g.s = this.ie;
            g.c = this.as;
            g.h = this.c2(this.cq);
            g.n = this.c2(this.cw);
            g.l = this.c2(this.co);
            if (isNaN_(g.o)) {
                g.o = XamRadialGauge.cy;
            }
            if (isNaN_(g.h)) {
                g.h = XamRadialGauge.cr;
            }
            f.b = g;
            f.e(a.b);
            a.b.ab = e;
        }
        gb(a) {
            let b = this.im;
            let c = a.c;
            let d = c.c;
            let e = c.e;
            let f = c.g;
            let g = c.h;
            let h = c.f;
            let i = c.d;
            let j = c.l;
            let k = c.t;
            let l = c.q;
            let m = c.j;
            let n = c.i;
            let o = c.v;
            let p = c.u;
            let q = c.s;
            let r = c.p;
            let s = c.ab;
            let t = c.ac;
            let u = c.w;
            let v = c.aa;
            let w = c.n;
            let x = c.m;
            let y = c.o;
            let z = this.view.by();
            let aa = c.r;
            k = Math.max(0, k);
            l = Math.max(0, l);
            let ab = true;
            if (this.au == 1 || (this.au == 0 && this.am == 0)) {
                ab = false;
            }
            let ac = Math.min(b.width / 2, b.height / 2) * a.d;
            let ad = this.ij();
            let ae = ad.x;
            let af = ad.y;
            let ag = q;
            let ah = r;
            q -= aa;
            r += aa;
            let ai = false;
            if ((r - q) >= 2 * Math.PI) {
                ai = true;
                q = 0;
                r = Math.PI;
            }
            let aj = new PathGeometry();
            let ak = new PathFigure();
            let al = Math.cos(q);
            let am = Math.sin(q);
            let an = Math.cos(r);
            let ao = Math.sin(r);
            let ap = ae + (ac * k) * al;
            let aq = af + (ac * k) * am;
            let ar = ae + (ac * l) * al;
            let as = af + (ac * l) * am;
            let at = ae + (ac * k) * an;
            let au = af + (ac * k) * ao;
            let av = ae + (ac * l) * an;
            let aw = af + (ac * l) * ao;
            let ax = ai;
            if (aa != 0 && !ai && ab) {
                let ay = Math.cos(ag);
                let az = Math.sin(ag);
                let a0 = Math.cos(ah);
                let a1 = Math.sin(ah);
                let a2 = ae + (ac * k) * ay;
                let a3 = af + (ac * k) * az;
                let a4 = ae + (ac * l) * ay;
                let a5 = af + (ac * l) * az;
                let a6 = ae + (ac * k) * a0;
                let a7 = af + (ac * k) * a1;
                let a8 = ae + (ac * l) * a0;
                let a9 = af + (ac * l) * a1;
                let ba = aq;
                let bb = ar;
                if (a4 - a2 != 0) {
                    bb = ae;
                    let bc = (a5 - a3) / (a4 - a2);
                    ba = bc * (ae - ar) + as;
                }
                let bd = { $type: Point_$type, x: bb, y: ba };
                let be = GeometryUtil.i(bd, { $type: Point_$type, x: ar, y: as }, { $type: Point_$type, x: ae, y: af }, ac * k);
                let bf = au;
                let bg = av;
                if (a8 - a6 != 0) {
                    bg = ae;
                    let bh = (a9 - a7) / (a8 - a6);
                    bf = bh * (ae - av) + aw;
                }
                let bi = { $type: Point_$type, x: bg, y: bf };
                let bj = GeometryUtil.i(bi, { $type: Point_$type, x: av, y: aw }, { $type: Point_$type, x: ae, y: af }, ac * k);
                if (isNaN_(be.c.x) || isNaN_(be.c.y) || isNaN_(be.d.x) || isNaN_(be.d.y) || isNaN_(bj.c.x) || isNaN_(bj.c.y) || isNaN_(bj.d.x) || isNaN_(bj.d.y)) {
                    ai = true;
                    q = 0;
                    r = Math.PI;
                }
                else {
                    let bk;
                    let bl;
                    if ((Math.pow(be.c.x - ar, 2) + Math.pow(be.c.y - as, 2)) < (Math.pow(be.d.x - ar, 2) + Math.pow(be.d.y - as, 2))) {
                        bk = be.c;
                    }
                    else {
                        bk = be.d;
                    }
                    if ((Math.pow(bj.c.x - av, 2) + Math.pow(bj.c.y - aw, 2)) < (Math.pow(bj.d.x - av, 2) + Math.pow(bj.d.y - aw, 2))) {
                        bl = bj.c;
                    }
                    else {
                        bl = bj.d;
                    }
                    if ((Math.pow(bl.x - ar, 2) + Math.pow(bl.y - as, 2)) <= (Math.pow(bk.x - ar, 2) + Math.pow(bk.y - as, 2))) {
                        ai = true;
                        q = 0;
                        r = Math.PI;
                    }
                    else {
                        let bm = GeometryUtil.e({ $type: Point_$type, x: ae, y: af }, bk);
                        let bn = GeometryUtil.e({ $type: Point_$type, x: ae, y: af }, bl);
                        let bo = q;
                        let bp = r;
                        while (bo > Math.PI * 2) {
                            bo -= Math.PI * 2;
                        }
                        while (bp > Math.PI * 2) {
                            bp -= Math.PI * 2;
                        }
                        let bq = Math.min(Math.abs(bm - bo), Math.abs((Math.PI * 2 - bm) - bo));
                        let br = Math.min(Math.abs(bn - bp), Math.abs((Math.PI * 2 - bn) - bp));
                        if ((r - q) + bq + br >= 2 * Math.PI) {
                            ai = true;
                            q = 0;
                            r = Math.PI;
                        }
                        else {
                            ap = bk.x;
                            aq = bk.y;
                            at = bl.x;
                            au = bl.y;
                        }
                    }
                }
            }
            if (ai && !ax) {
                al = Math.cos(q);
                am = Math.sin(q);
                an = Math.cos(r);
                ao = Math.sin(r);
                ap = ae + (ac * k) * al;
                aq = af + (ac * k) * am;
                ar = ae + (ac * l) * al;
                as = af + (ac * l) * am;
                at = ae + (ac * k) * an;
                au = af + (ac * k) * ao;
                av = ae + (ac * l) * an;
                aw = af + (ac * l) * ao;
            }
            if (ai) {
                ak._startPoint = { $type: Point_$type, x: ar, y: as };
                ak._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: av, y: aw };
                    $ret.b = false;
                    $ret.d = 1;
                    $ret.f = new Size(1, ac * l, ac * l);
                    return $ret;
                })()));
                ak._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: ar, y: as };
                    $ret.b = false;
                    $ret.d = 1;
                    $ret.f = new Size(1, ac * l, ac * l);
                    return $ret;
                })()));
                let bs = new PathFigure();
                bs._startPoint = { $type: Point_$type, x: ap, y: aq };
                bs._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: at, y: au };
                    $ret.b = false;
                    $ret.d = 0;
                    $ret.f = new Size(1, ac * k, ac * k);
                    return $ret;
                })()));
                bs._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: ap, y: aq };
                    $ret.b = false;
                    $ret.d = 0;
                    $ret.f = new Size(1, ac * k, ac * k);
                    return $ret;
                })()));
                aj.c.add(ak);
                aj.c.add(bs);
            }
            else {
                ak._startPoint = { $type: Point_$type, x: ap, y: aq };
                ak._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: ar, y: as };
                    return $ret;
                })()));
                ak._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: av, y: aw };
                    $ret.b = (r - q) > Math.PI;
                    $ret.d = 1;
                    $ret.f = new Size(1, ac * l, ac * l);
                    return $ret;
                })()));
                ak._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: at, y: au };
                    return $ret;
                })()));
                ak._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.e = { $type: Point_$type, x: ap, y: aq };
                    $ret.b = (r - q) > Math.PI;
                    $ret.d = 0;
                    $ret.f = new Size(1, ac * k, ac * k);
                    return $ret;
                })()));
                aj.c.add(ak);
            }
            z.ak = aj;
            z._fill = s;
            let bt = this.a2;
            bt.f = true;
            for (let bu of fromEnum(this.bl)) {
                bt.n(bu);
            }
            this.bl.g();
            let bv = c.z;
            for (let bw = 0; bw < d.length; bw++) {
                let bx = ae + (ac * j) * Math.cos(d[bw]);
                let by = af + (ac * j) * Math.sin(d[bw]);
                let bz = bt.a();
                if (bz.ak != e[bw]) {
                    bz.ak = e[bw];
                }
                this.view.a9(bz, bv);
                let b0 = h[bw];
                let b1 = i[bw];
                let b2 = f[bw];
                let b3 = g[bw];
                this.view.a2(bz, bx + b2, by + b3);
                this.bl.h(bz);
            }
            bt.f = false;
            let b4 = this.a5;
            b4.f = true;
            for (let b5 = 0; b5 < this.bi.count; b5++) {
                b4.n(this.bi._inner[b5]);
            }
            this.bi.clear();
            for (let b6 = 0; b6 < m.length; b6++) {
                let b7 = ae + (ac * o) * Math.cos(m[b6]);
                let b8 = af + (ac * o) * Math.sin(m[b6]);
                let b9 = ae + (ac * p) * Math.cos(m[b6]);
                let ca = af + (ac * p) * Math.sin(m[b6]);
                let cb = b4.a();
                let cc = new PathGeometry();
                let cd = new PathFigure();
                cd._startPoint = { $type: Point_$type, x: b7, y: b8 };
                cd._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: b9, y: ca };
                    return $ret;
                })()));
                cc.c.add(cd);
                cb.ak = cc;
                cb._stroke = t;
                cb.ac = u;
                this.bi.add(cb);
            }
            b4.f = false;
            let ce = this.a3;
            ce.f = true;
            for (let cf = 0; cf < this.bg.count; cf++) {
                ce.n(this.bg._inner[cf]);
            }
            this.bg.clear();
            for (let cg = 0; cg < n.length; cg++) {
                let ch = ae + (ac * w) * Math.cos(n[cg]);
                let ci = af + (ac * w) * Math.sin(n[cg]);
                let cj = ae + (ac * x) * Math.cos(n[cg]);
                let ck = af + (ac * x) * Math.sin(n[cg]);
                let cl = ce.a();
                let cm = new PathGeometry();
                let cn = new PathFigure();
                cn._startPoint = { $type: Point_$type, x: ch, y: ci };
                cn._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = { $type: Point_$type, x: cj, y: ck };
                    return $ret;
                })()));
                cm.c.add(cn);
                cl.ak = cm;
                cl._stroke = v;
                cl.ac = y;
                this.bg.add(cl);
            }
            ce.f = false;
            let co = this.a4;
            co.f = true;
            for (let cp = this.bh.count - 1; cp >= 0; cp--) {
                co.n(this.bh._inner[cp]);
            }
            this.bh.clear();
            for (let cq = 0; cq < c.k.count; cq++) {
                let cr = c.k._inner[cq];
                let cs = co.a();
                cs.ak = cr.m(ac, ae, af);
                cs._fill = cr.k;
                cs._stroke = cr.l;
                cs.ac = cr.h;
                this.bh.add(cs);
            }
            this.view.a8(this.bh);
            co.f = false;
        }
        bf(a, b, c) {
            let d = c / 10000;
            if (isNaN_(d)) {
                d = 1E-05;
            }
            let e = Math.abs(a - b);
            if (e < d) {
                return true;
            }
            return false;
        }
        c3(a) {
            if (isInfinity(a)) {
                return NaN;
            }
            return a;
        }
        c1(a, b) {
            if (isInfinity(a)) {
                return b;
            }
            return a;
        }
        c4(a, b) {
            if (isInfinity(a) || isNaN_(a)) {
                return b;
            }
            return a;
        }
        f3() {
            let a = this.ap;
            a.d = this.c3(this.c0);
            if (isNaN_(a.d)) {
                a.d = 1;
            }
            let b = this.im;
            let c = this.av;
            let d = this.c3(this.b6);
            let e = this.c3(this.b9);
            let f = this.c3(this.ce);
            if (isNaN_(d)) {
                d = (this.br - this.bs) / 10;
            }
            if (isNaN_(e)) {
                e = d;
            }
            if (isNaN_(f)) {
                f = 3;
            }
            let g = new List$1(Tuple$2.$.specialize(Number_$type, Number_$type), 0);
            let h = c.i;
            let i = c.g;
            while (h >= Math.PI * 2) {
                h -= Math.PI * 2;
            }
            while (i >= Math.PI * 2) {
                i -= Math.PI * 2;
            }
            let j = Math.abs(i - h) < 0.0001;
            let k = this.an == 1 || this.an == 3;
            let l = this.an == 0 || this.an == 3;
            for (let m = this.bs; m <= this.br || this.bf(m, this.br, e); m += e) {
                if (j && this.bf(m, this.bs, e) && k) {
                    continue;
                }
                if (j && this.bf(m, this.br, e) && l) {
                    continue;
                }
                g.add(new Tuple$2(Number_$type, Number_$type, m, c.h(m)));
                if (e == 0) {
                    break;
                }
            }
            let n = new List$1(Number_$type, 0);
            let o = new List$1(Number_$type, 0);
            for (let p = this.bs; p <= this.br || this.bf(p, this.br, d); p += d) {
                n.add(c.h(p));
                for (let q = 0; q < f; q++) {
                    let r = (d / (f + 1)) * (q + 1);
                    if (r + p > this.br) {
                        continue;
                    }
                    o.add(c.h(r + p));
                }
                if (d == 0) {
                    break;
                }
            }
            if (a.c.c.length != g.count) {
                a.c.c = new Array(g.count);
                a.c.e = new Array(g.count);
                a.c.f = new Array(g.count);
                a.c.d = new Array(g.count);
                a.c.g = new Array(g.count);
                a.c.h = new Array(g.count);
            }
            if (a.c.j.length != n.count || a.c.i.length != o.count) {
                a.c.j = new Array(n.count);
                a.c.i = new Array(o.count);
            }
            let s = new FormatRadialGaugeLabelEventArgs();
            s.startAngle = this.av.i;
            s.endAngle = this.av.g;
            s.actualMinimumValue = this.bs;
            s.actualMaximumValue = this.br;
            let t = new AlignRadialGaugeLabelEventArgs();
            t.startAngle = s.startAngle;
            t.endAngle = s.endAngle;
            t.actualMinimumValue = s.actualMinimumValue;
            t.actualMaximumValue = s.actualMaximumValue;
            for (let u = 0; u < g.count; u++) {
                s.angle = g._inner[u].d;
                t.angle = s.angle;
                a.c.c[u] = g._inner[u].d;
                let v = g._inner[u].c;
                s.value = v;
                let w = v;
                if (this.aj == null) {
                    w = Math.round(v * 100) / 100;
                }
                s.label = (w).toString();
                if (this.aj != null) {
                    s.label = this.aj.i(w);
                }
                if (this.formatLabel != null) {
                    this.formatLabel(this, s);
                }
                t.value = s.value;
                t.label = s.label;
                let x = s.label;
                let y = this.view.b2(((() => {
                    let $ret = new TextBlock();
                    $ret.ak = x;
                    return $ret;
                })()));
                t.width = y.width;
                t.height = y.height;
                t.offsetX = -1 * (y.width / 2);
                t.offsetY = -1 * (y.height / 2);
                if (this.alignLabel != null) {
                    this.alignLabel(this, t);
                }
                a.c.f[u] = t.width;
                a.c.d[u] = t.height;
                a.c.g[u] = t.offsetX;
                a.c.h[u] = t.offsetY;
                a.c.e[u] = t.label;
            }
            for (let z = 0; z < n.count; z++) {
                a.c.j[z] = n._inner[z];
            }
            for (let aa = 0; aa < o.count; aa++) {
                a.c.i[aa] = o._inner[aa];
            }
            a.c.t = this.c4(this.db, 0.5);
            a.c.q = this.c4(this.c6, 0.57);
            a.c.l = this.c4(this.b7, 0.65);
            a.c.v = this.c4(this.dg, 0.5);
            a.c.u = this.c4(this.de, 0.57);
            a.c.n = this.c4(this.ch, 0.54);
            a.c.m = this.c4(this.cf, 0.57);
            a.c.s = c.i;
            a.c.p = c.g;
            let ab = this.c8;
            if (isNaN_((ab))) {
                ab = 2.8;
            }
            let ac = ab * Math.PI / 180;
            if (ac < 0) {
                ac = 0;
            }
            a.c.r = ac;
            a.c.ac = this.ih;
            a.c.z = this.h8;
            a.c.aa = this.ia;
            a.c.ab = this.ig;
            a.c.w = this.c3(this.di);
            a.c.o = this.c3(this.cj);
            if (isNaN_(a.c.w)) {
                a.c.w = XamRadialGauge.dj;
            }
            if (isNaN_(a.c.o)) {
                a.c.o = XamRadialGauge.ck;
            }
            a.c.k.clear();
            for (let ad = 0; ad < this.ranges.count; ad++) {
                let ae = this.ranges._inner[ad];
                let af = this.c3(Math.min(ae.o, ae.j));
                let ag = this.c3(Math.max(ae.o, ae.j));
                if (isNaN_(af) || isNaN_(ag)) {
                    continue;
                }
                let ah = c.h(af);
                let ai = c.h(ag);
                let aj = RadialGaugeScaler.k(ah, ai, this.ii);
                ah = aj.c;
                ai = aj.d;
                let ak = new RadialGaugeRangeFrame();
                ak.e = ah;
                ak.b = ai;
                ak.k = ae.ao != null ? ae.ao : this.h9(ad, this.ah);
                ak.l = ae.ap != null ? ae.ap : this.h9(ad, this.ai);
                ak.h = this.c4(ae.p, XamRadialGaugeRange.q);
                ak.f = this.c3(ae.l);
                if (isNaN_(ak.f)) {
                    ak.f = Math.max(0, this.db);
                }
                ak.c = this.c3(ae.k);
                if (isNaN_(ak.c)) {
                    ak.c = Math.max(0, this.db);
                }
                ak.g = this.c3(ae.n);
                if (isNaN_(ak.g)) {
                    ak.g = Math.max(0, this.c6);
                }
                ak.d = this.c3(ae.m);
                if (isNaN_(ak.d)) {
                    ak.d = Math.max(0, this.c6);
                }
                if (this.ii == 0) {
                    let al = ak.f;
                    ak.f = ak.c;
                    ak.c = al;
                    al = ak.g;
                    ak.g = ak.d;
                    ak.d = al;
                }
                a.c.k.add(ak);
            }
        }
        f1() {
            let a = this.ap;
            a.d = this.c0;
            let b = a.a;
            let c = this.h6;
            let d = this.h7;
            let e = this.c1(this.b1, XamRadialGauge.b2);
            let f = this.am;
            let g = this.by;
            let h = this.bw;
            if (isInfinity(h) || isNaN_(h)) {
                h = 0.12;
            }
            if (isInfinity(g) || isNaN_(g)) {
                g = 0.82;
            }
            let i = this.bu;
            if (isInfinity(i) || isNaN_(i)) {
                i = 4;
            }
            if (h > g) {
                let j = g;
                g = h;
                h = j;
            }
            let k = this.av;
            let l = k.i;
            let m = k.g;
            b.l = c;
            b.m = d;
            b.h = e;
            if (f == 0) {
                b.b = 0;
                b.g = 0;
                b.c = 0;
                b.d = 0;
                b.e = this.by;
            }
            else {
                b.b = i;
                let n = this.b0 * Math.PI / 180;
                if (n < 0) {
                    n = 0;
                }
                if ((Math.PI * 2) - (m - l) < n) {
                    b.f = 0;
                    b.b = 0;
                    b.g = 0;
                    b.c = 0;
                    b.d = 0;
                    b.e = g;
                }
                else {
                    b.f = n;
                    b.g = l;
                    b.c = m;
                    b.b = i;
                    b.d = h;
                    b.e = g;
                }
            }
        }
        get a6() {
            return this.ay.f();
        }
        get dk() {
            return this.bq;
        }
        set dk(a) {
            let b = this.bq;
            this.bq = a;
            this.fy("TransitionProgress", b, this.bq);
        }
        fr(a, b) {
            let c = this.b5(a);
            if (this.a9) {
                let d = this.dl(this.av.g - Math.PI * 2);
                switch (this.ii) {
                    case 1:
                        if (c < this.bs) {
                            c = c < d * 0.5 ? this.br : this.bs;
                        }
                        break;
                    case 0:
                        if (c > this.br) {
                            c = c < (d + this.br) * 0.5 ? this.br : this.bs;
                        }
                        break;
                }
            }
            if (c != this.dm) {
                this.dm = c;
            }
        }
        destroy() {
            this.provideContainer(null);
        }
        provideContainer(a) {
            this.view.as(a);
        }
        onMouseMove(a, b) {
            if (this.a8) {
                this.fr(a, b);
            }
        }
        onMouseDown(a, b = false) {
            if (this.ba && this.needleContainsPoint(a, b) && !this.a8) {
                this.a8 = true;
            }
        }
        onMouseUp(a) {
            if (this.a8) {
                this.a8 = false;
            }
        }
        containerResized() {
            this.view.at();
        }
        fs() {
            this.view.flush();
        }
        aw() {
            let a = new GaugeVisualData();
            a.viewport = new RectData(this.im.left, this.im.top, this.im.width, this.im.height);
            a.scaleLabels = new ScaleLabelVisualDataList();
            a.scaleTickmarks = new ScaleTickmarkVisualDataList();
            a.ranges = new RangeVisualDataList();
            a.needle = new NeedleVisualData();
            this.view.aj(a);
            return a;
        }
        d1() {
            let a = this.aw();
            a.scaleByViewport();
            return a.serialize();
        }
        a1() {
            return FontUtil.toFontInfo(this.view.z, this.d2);
        }
        get cz() {
            return this.bp;
        }
        set cz(a) {
            let b = this.bp;
            this.bp = a;
            this.fy("PixelScalingRatio", b, this.bp);
        }
        get bt() {
            return this.bo;
        }
        set bt(a) {
            let b = this.bo;
            this.bo = a;
            this.fy("ActualPixelScalingRatio", b, this.bo);
        }
    }
    XamRadialGauge.$t = /*@__PURE__*/ markType(XamRadialGauge, 'XamRadialGauge', Control.$, [INotifyPropertyChanged_$type]);
    XamRadialGauge.hl = /*@__PURE__*/ DependencyProperty.i("NeedleStartWidth", Number_$type, XamRadialGauge.$, /*@__PURE__*/ new PropertyMetadata(2, NaN, (a, b) => a.fy("NeedleStartWidth", b.oldValue, b.newValue)));
    XamRadialGauge.cy = /*@__PURE__*/ DeviceUtils.g(1);
    XamRadialGauge.cr = /*@__PURE__*/ DeviceUtils.g(1);
    XamRadialGauge.dj = /*@__PURE__*/ DeviceUtils.g(3);
    XamRadialGauge.ck = /*@__PURE__*/ DeviceUtils.g(2);
    XamRadialGauge.b2 = /*@__PURE__*/ DeviceUtils.g(12);
    XamRadialGauge.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, XamRadialGauge, 'fy', ['BackingBrush:h6:ge', [Brush.$, null], 'BackingCornerRadius:bu:gf', [1, 4], 'BackingInnerExtent:bw:gg', [1, 0.12], 'BackingOuterExtent:by:gh', [1, 0.82], 'BackingOutline:h7:gi', [Brush.$, null], 'BackingOversweep:b0:gj', [1, 3], 'BackingShape:am:gk', [RadialGaugeBackingShape_$type, /*@__PURE__*/ enumGetBox(RadialGaugeBackingShape_$type, 0)], 'BackingStrokeThickness:b1:gl', [1, XamRadialGauge.b2], 'CenterX:b3:gm', [1, 0.5], 'CenterY:b4:gn', [1, 0.5], 'DuplicateLabelOmissionStrategy:an:go', [RadialGaugeDuplicateLabelOmissionStrategy_$type, /*@__PURE__*/ enumGetBox(RadialGaugeDuplicateLabelOmissionStrategy_$type, 0)], 'FontBrush:h8:gp', [Brush.$, null], 'Font:d2:gq', [2, null], 'Interval:b6:gr', [1, NaN], 'IsNeedleDraggingConstrained:a9:gs', [0, true], 'IsNeedleDraggingEnabled:ba:gt', [0, false], 'LabelExtent:b7:gu', [1, 0.65], 'LabelFormat:d9:gv', [2, null], 'LabelFormatSpecifiers:ag:gw', [Array_$type, null], 'LabelInterval:b9:gx', [1, NaN], 'MaximumValue:ca:gy', [1, 100], 'MinimumValue:cc:gz', [1, 0], 'MinorTickBrush:ia:g0', [Brush.$, null], 'MinorTickCount:ce:g1', [1, 3], 'MinorTickEndExtent:cf:g2', [1, 0.57], 'MinorTickStartExtent:ch:g3', [1, 0.54], 'MinorTickStrokeThickness:cj:g4', [1, XamRadialGauge.ck], 'NeedleBaseFeatureExtent:cl:g5', [1, NaN], 'NeedleBaseFeatureWidthRatio:cm:g6', [1, NaN], 'NeedleBrush:ib:g7', [Brush.$, null], 'NeedleEndExtent:cn:g8', [1, NaN], 'NeedleEndWidthRatio:co:g9', [1, NaN], 'NeedleOutline:ic:ha', [Brush.$, null], 'NeedlePivotBrush:id:hb', [Brush.$, null], 'NeedlePivotInnerWidthRatio:cp:hc', [1, NaN], 'NeedlePivotOutline:ie:hd', [Brush.$, null], 'NeedlePivotShape:as:he', [RadialGaugePivotShape_$type, /*@__PURE__*/ enumGetBox(RadialGaugePivotShape_$type, 3)], 'NeedlePivotStrokeThickness:cq:hf', [1, XamRadialGauge.cr], 'NeedlePivotWidthRatio:cs:hg', [1, NaN], 'NeedlePointFeatureExtent:ct:hh', [1, NaN], 'NeedlePointFeatureWidthRatio:cu:hi', [1, NaN], 'NeedleShape:ar:hj', [RadialGaugeNeedleShape_$type, /*@__PURE__*/ enumGetBox(RadialGaugeNeedleShape_$type, 4)], 'NeedleStartExtent:cv:hk', [1, NaN], 'NeedleStrokeThickness:cx:hm', [1, XamRadialGauge.cy], 'RadiusMultiplier:c0:hn', [1, 1], 'RangeBrushes:ah:ho', [BrushCollection.$, null], 'RangeOutlines:ai:hp', [BrushCollection.$, null], 'Ranges::hq', [RadialGaugeRangeCollection.$, null], 'ScaleBrush:ig:hr', [Brush.$, null], 'ScaleEndAngle:c5:hs', [1, 45], 'ScaleEndExtent:c6:ht', [1, 0.57], 'ScaleOversweep:c8:hu', [1, 2.8], 'ScaleOversweepShape:au:hv', [RadialGaugeScaleOversweepShape_$type, /*@__PURE__*/ enumGetBox(RadialGaugeScaleOversweepShape_$type, 0)], 'ScaleStartAngle:da:hw', [1, 135], 'ScaleStartExtent:db:hx', [1, 0.5], 'ScaleSweepDirection:ii:hy', [SweepDirection_$type, /*@__PURE__*/ enumGetBox(SweepDirection_$type, 1)], 'TickBrush:ih:hz', [Brush.$, null], 'TickEndExtent:de:h0', [1, 0.57], 'TickStartExtent:dg:h1', [1, 0.5], 'TickStrokeThickness:di:h2', [1, XamRadialGauge.dj], 'TransitionDuration:dn:h3', [1, 0], 'TransitionEasingFunction:a0:h4', [Delegate_$type, null], 'Value:dm:h5', [1, 0]]);
    return XamRadialGauge;
})();
/**
 * @hidden
 */
let XamRadialGaugeView = /*@__PURE__*/ (() => {
    class XamRadialGaugeView extends Base {
        constructor(a) {
            super();
            this.h = null;
            this.s = null;
            this.r = null;
            this.q = null;
            this.br = new Path();
            this.bt = new Path();
            this.bq = new Path();
            this.bs = new Path();
            this.bu = new Path();
            this.o = null;
            this.a = ["needle", "needlePivot", "backing", "scale", "tick", "minorTick", "label"];
            this.c = null;
            this.d = null;
            this.l = false;
            this.m = false;
            this.g = null;
            this.aa = null;
            this.k = null;
            this.z = null;
            this.i = null;
            this.bf = new Brush();
            this.bg = ((() => {
                let $ret = new Brush();
                $ret.fill = "black";
                return $ret;
            })());
            this.t = NaN;
            this.p = null;
            this.ac = -1;
            this.ab = -1;
            this.bk = null;
            this.bl = null;
            this.bm = null;
            this.bn = null;
            this.bh = null;
            this.bi = null;
            this.bo = null;
            this.bp = null;
            this.bj = null;
            this.e = null;
            this.f = null;
            this.u = 0;
            this.h = a;
            this.o = new Dictionary$2(String_$type, Dictionary$2.$.specialize(String_$type, String_$type), 0);
            this.q = new List$1(TextBlock.$, 0);
            this.r = new List$1(Path.$, 0);
            this.s = new List$1(Path.$, 0);
        }
        an(a) {
            a._visibility = 0;
        }
        ao(a) {
            a._visibility = 1;
        }
        ap(a) {
            this.q.remove(a);
        }
        be() {
            let a = new TextBlock();
            this.q.add(a);
            return a;
        }
        ay(a) {
            a._visibility = 0;
        }
        az(a) {
            a._visibility = 1;
        }
        a0(a) {
            this.r.remove(a);
        }
        b0() {
            let a = new Path();
            this.r.add(a);
            return a;
        }
        a3(a) {
            a._visibility = 0;
        }
        a4(a) {
            a._visibility = 1;
        }
        a5(a) {
            this.s.remove(a);
        }
        b1() {
            let a = new Path();
            this.s.add(a);
            return a;
        }
        n() {
            return true;
        }
        bw() {
            return this.br;
        }
        by() {
            return this.bt;
        }
        w(a) {
            let b = typeCast(TextBlock.$, a);
            if (b != null && b.ak != null) {
                return this.k.e(b) + 0;
            }
            return 0;
        }
        b2(a) {
            if (isNaN_(this.t)) {
                this.t = this.v(null);
            }
            let b = this.w(a);
            let c = this.t;
            return new Size(1, b, c);
        }
        al() {
            this.l = true;
            let a = ["#CED3D8", "#CED3D8", "#EBEDEF", "#FFC73C", "#617583", "rgba(100,107,114,.74)", "rgba(100,107,114,.74)"];
            let b = ["#B2B9C0", "#B2B9C0", "#B2B9C0", null, null, null, null];
            let c = ["background-color", "border-top-color"];
            let d = ((() => {
                let $ret = new List$1(Array_$type, 0);
                $ret.add(a);
                $ret.add(b);
                return $ret;
            })());
            this.o.clear();
            let e = this.a.length;
            for (let f = 0; f < e; f++) {
                let g = new Dictionary$2(String_$type, String_$type, 0);
                let h = this.a[f];
                let i = new Array(c.length);
                arrayCopy1(c, 0, i, 0, c.length);
                this.b("ui-radialgauge-" + h, i);
                for (let j = 0; j < i.length; j++) {
                    g.item(c[j], (i[j] == null) ? d._inner[j][f] : i[j]);
                }
                this.o.item(h, g);
            }
            this.bc();
            let k;
            let l;
            let m = BrushUtil.e("radialgauge-range", this.z, k, l);
            k = m.p2;
            l = m.p3;
            this.c = k;
            this.d = l;
            if (this.e == null) {
                this.h.ah = this.c;
            }
            if (this.f == null) {
                this.h.ai = this.d;
            }
            this.l = false;
        }
        aq() {
            this.am();
            if (this.g != null) {
                this.g.ap(this.z.rootWrapper, "");
            }
        }
        au() {
            if (this.g != null) {
                this.g.bb(this.z.rootWrapper, "");
            }
        }
        bc() {
            this.l = true;
            let a = this.a.length;
            for (let b = 0; b < a; b++) {
                let c = this.a[b];
                this.bb(c, this.o.item(c));
            }
            this.l = false;
        }
        bb(a, b) {
            let c = null;
            let d = null;
            let e = b.count;
            for (let f of fromEnum(b.keys)) {
                switch (f) {
                    case "background-color":
                        c = new Brush();
                        if (b.item(f) != null) {
                            c._fill = b.item(f);
                        }
                        break;
                    case "border-top-color":
                        d = new Brush();
                        if (b.item(f) != null) {
                            d._fill = b.item(f);
                        }
                        break;
                }
            }
            switch (a) {
                case "needle":
                    if (this.bk == null) {
                        this.h.ib = c;
                    }
                    if (this.bl == null) {
                        this.h.ic = d;
                    }
                    break;
                case "needlePivot":
                    if (this.bm == null) {
                        this.h.id = c;
                    }
                    if (this.bn == null) {
                        this.h.ie = d;
                    }
                    break;
                case "backing":
                    if (this.bh == null) {
                        this.h.h6 = c;
                    }
                    if (this.bi == null) {
                        this.h.h7 = d;
                    }
                    break;
                case "scale":
                    if (this.bo == null) {
                        this.h.ig = c;
                    }
                    break;
                case "tick":
                    if (this.bp == null) {
                        this.h.ih = c;
                    }
                    break;
                case "minorTick":
                    if (this.bj == null) {
                        this.h.ia = c;
                    }
                    break;
                case "label":
                    this.bg = c;
                    break;
            }
        }
        b(a, b) {
            this.z.startCSSQuery();
            for (let c = 0; c < b.length; c++) {
                b[c] = this.z.getCssDefaultPropertyValue(a, b[c]);
            }
            this.z.endCSSQuery();
            return b;
        }
        static y(a, b) {
            let c = a == null ? 0 : a.length;
            if (c < 1) {
                return b;
            }
            let d = a.split('.');
            let e = (d[0].length > 0) ? parseInt(d[0]) : 0;
            if (d.length != 2) {
                return e;
            }
            c = d[1].length;
            let f = parseInt(d[1]);
            while (c-- > 0) {
                f /= 10;
            }
            return f + e;
        }
        av() {
            this.l = true;
            this.h.ib = ((() => {
                let $ret = new Brush();
                $ret.fill = "#CED3D8";
                return $ret;
            })());
            this.h.ic = ((() => {
                let $ret = new Brush();
                $ret.fill = "#B2B9C0";
                return $ret;
            })());
            this.h.ih = ((() => {
                let $ret = new Brush();
                $ret.fill = "#617583";
                return $ret;
            })());
            this.h.ig = ((() => {
                let $ret = new Brush();
                $ret.fill = "#FFC73C";
                return $ret;
            })());
            this.h.h6 = ((() => {
                let $ret = new Brush();
                $ret.fill = "#EBEDEF";
                return $ret;
            })());
            this.h.h7 = ((() => {
                let $ret = new Brush();
                $ret.fill = "#B2B9C0";
                return $ret;
            })());
            this.h.id = ((() => {
                let $ret = new Brush();
                $ret.fill = "#CED3D8";
                return $ret;
            })());
            this.h.ie = ((() => {
                let $ret = new Brush();
                $ret.fill = "#B2B9C0";
                return $ret;
            })());
            this.h.ia = ((() => {
                let $ret = new Brush();
                $ret.fill = "rgba(100,107,114,.74)";
                return $ret;
            })());
            this.l = false;
            this.am();
        }
        am() {
            let a = this.h.cz;
            let b = this.h.bt;
            if (!isNaN_(a) && a != 0) {
                return;
            }
            if (window.devicePixelRatio != undefined && window.devicePixelRatio != b) {
                this.h.bt = window.devicePixelRatio;
            }
        }
        a7() {
            if (!this.m) {
                this.m = true;
                if (this.z != null) {
                    this.z.setTimeout(runOn(this, this.ad), 0);
                }
                else {
                    window.setTimeout(runOn(this, this.ad), 0);
                }
            }
        }
        ad() {
            if (this.m) {
                this.m = false;
                this.h.fo();
            }
        }
        flush() {
            if (this.m) {
                this.ad();
            }
        }
        a2(a, b, c) {
            a.n = b;
            a.o = c;
        }
        as(a) {
            if (a == null) {
                this.aa = null;
                this.z = null;
                this.k = null;
                this.af();
                return;
            }
            this.u = (isNaN_(this.h.cz) ? this.h.bt : this.h.cz);
            let b = a;
            this.z = b;
            this.h.ay.u(this.z);
            this.z.rootWrapper.addClass("ui-radialgauge-container");
            let c = this.u;
            let d = Math.round(b.rootWrapper.width());
            let e = Math.round(b.rootWrapper.height());
            let f = d * c;
            let g = e * c;
            this.z.rootWrapper.setStyleProperty("position", "relative");
            let h = this.z.createElement("canvas");
            h.setStyleProperty("position", "absolute");
            this.z.append(h);
            this.ac = truncate(Math.round(f));
            this.ab = truncate(Math.round(g));
            h.setAttribute("width", f.toString());
            h.setAttribute("height", g.toString());
            h.setStyleProperty("width", d.toString() + "px");
            h.setStyleProperty("height", e.toString() + "px");
            this.h.im = new Rect(0, 0, 0, d, e);
            this.aa = h;
            let i = this.z.get2DCanvasContext(this.aa);
            this.k = new RenderingContext(new CanvasViewRenderer(), i);
            this.al();
            this.bd();
            this.k.ac(this.i);
            this.af();
            if (TypeRegistrar.isRegistered("CanvasGestureDOMEventProxy")) {
                this.g = typeCast(EventProxy.$, TypeRegistrar.create("CanvasGestureDOMEventProxy", this.z.rootWrapper, this.z, false));
            }
            if (this.g != null) {
                let j = this.g;
                j.onContactStarted = delegateCombine(j.onContactStarted, runOn(this, this.ai));
                let k = this.g;
                k.onContactMoved = delegateCombine(k.onContactMoved, runOn(this, this.ah));
                let l = this.g;
                l.onContactCompleted = delegateCombine(l.onContactCompleted, runOn(this, this.ag));
                this.g.ak = (m) => this.h.ba && (this.h.a8 || this.h.bc(m));
            }
            this.a6();
        }
        ag(a, b) {
            if (this.h != null) {
                this.h.onMouseUp(a);
            }
        }
        ah(a, b) {
            if (this.h != null) {
                this.h.onMouseMove(a, b);
            }
        }
        ai(a, b) {
            if (this.h != null) {
                this.h.onMouseDown(a);
            }
        }
        af() {
            if (this.g != null) {
                let a = this.g;
                a.onContactStarted = delegateRemove(a.onContactStarted, runOn(this, this.ai));
                let b = this.g;
                b.onContactMoved = delegateRemove(b.onContactMoved, runOn(this, this.ah));
                let c = this.g;
                c.onContactCompleted = delegateRemove(c.onContactCompleted, runOn(this, this.ag));
                this.g.ak = null;
                this.g.aq();
            }
        }
        a9(a, b) {
            if (b != null) {
                a.am = b;
            }
            else {
                a.am = this.bg;
            }
        }
        ba() {
            this.al();
            this.bd();
            this.a7();
        }
        bd() {
            this.i = FontUtil.getFont(this.z);
            if (this.h.d2 != null) {
                this.i = this.h.a1();
            }
            this.t = this.v(this.i);
            this.bf = new Brush();
            this.bf._fill = this.z.rootWrapper.getStyleProperty("color");
            if (this.k != null) {
                this.k.ac(this.i);
            }
        }
        ae() {
            this.a6();
        }
        a6() {
            let a = this.h.im.width;
            let b = this.h.im.height;
            let c = Math.round(a * this.u);
            let d = Math.round(b * this.u);
            if (this.ac != c || this.ab != d) {
                this.aa.setAttribute("width", c.toString());
                this.aa.setAttribute("height", d.toString());
                this.aa.setStyleProperty("width", a.toString() + "px");
                this.aa.setStyleProperty("height", b.toString() + "px");
                this.ac = truncate(Math.round(c));
                this.ab = truncate(Math.round(d));
            }
            if (this.k.d && this.u != 1) {
                this.k.z();
                this.k.aa(this.u, this.u);
            }
            this.k.k(this.h.im.left, this.h.im.top, this.h.im.width, this.h.im.height);
            this.k.s(this.bq);
            this.k.s(this.bt);
            if (this.p != null) {
                for (let e = 0; e < this.p.count; e++) {
                    this.k.s(this.p._inner[e]);
                }
            }
            for (let f = 0; f < this.q.count; f++) {
                this.k.ac(this.i);
                this.k.w(this.q._inner[f]);
            }
            for (let g = 0; g < this.r.count; g++) {
                this.k.s(this.r._inner[g]);
            }
            this.k.z();
            this.k.j(this.br.j);
            this.k.s(this.bu);
            this.k.s(this.br);
            this.k.s(this.bs);
            this.k.y();
            if (this.k.d && this.u != 1) {
                this.k.y();
            }
        }
        v(a) {
            return FontUtil.getCurrentFontHeight(this.z, a);
        }
        a8(a) {
            this.p = a;
        }
        bv() {
            return this.bq;
        }
        bz() {
            return this.bu;
        }
        bx() {
            return this.bs;
        }
        at() {
            this.am();
            let a = Math.round(this.z.rootWrapper.width());
            let b = Math.round(this.z.rootWrapper.height());
            this.h.im = new Rect(0, 0, 0, a, b);
            if (this.g != null) {
                this.g.bf = this.h.im;
            }
        }
        j(a, b) {
            return FontUtil.getFontInfo(this.z, a, b);
        }
        aj(a) {
            a.scalePath = new PathVisualData(1, "Scale", this.bt);
            a.needlePath = new PathVisualData(1, "Needle", this.br);
            let b = this.br.j.j._inner[0].j;
            a.needle.angle = b;
            a.backingPath = new PathVisualData(1, "Backing", this.bq);
            a.overlayPath = new PathVisualData(1, "Overlay", this.bs);
            a.underlayPath = new PathVisualData(1, "Underlay", this.bu);
            let c = this.i;
            for (let d of fromEnum(this.q)) {
                if (d._visibility == 0) {
                    let e = this.j(d, c);
                    let f = new ScaleLabelVisualData();
                    f.labelValue = d.ak;
                    f.labelPosition = PointData.b({ $type: Point_$type, x: d.n, y: d.o });
                    f.labelSize = SizeData.b(this.b2(d));
                    f.appearance = AppearanceHelper.c(d, e);
                    a.scaleLabels.add(f);
                }
            }
            for (let g of fromEnum(this.r)) {
                if (g._visibility == 0) {
                    let h = new ScaleTickmarkVisualData();
                    h.tickPath = new PathVisualData(1, "tickmarks", g);
                    a.scaleTickmarks.add(h);
                }
            }
            for (let i of fromEnum(this.s)) {
                if (i._visibility == 0) {
                    let j = new RangeVisualData();
                    let k = new PathVisualData(1, "range", i);
                    j.rangePath = k;
                    a.ranges.add(j);
                }
            }
        }
        ar(a, b, c) {
            let d = b;
            let e = c;
            if (!this.l) {
                switch (a) {
                    case XamRadialGauge.$$p[29]:
                        this.bk = e;
                        break;
                    case XamRadialGauge.$$p[32]:
                        this.bl = e;
                        break;
                    case XamRadialGauge.$$p[33]:
                        this.bm = e;
                        break;
                    case XamRadialGauge.$$p[35]:
                        this.bn = e;
                        break;
                    case XamRadialGauge.$$p[0]:
                        this.bh = e;
                        break;
                    case XamRadialGauge.$$p[4]:
                        this.bi = e;
                        break;
                    case XamRadialGauge.$$p[48]:
                        this.bo = e;
                        break;
                    case XamRadialGauge.$$p[56]:
                        this.bp = e;
                        break;
                    case XamRadialGauge.$$p[22]:
                        this.bj = e;
                        break;
                }
                if (e == null) {
                    this.bc();
                }
            }
        }
        aw(a, b) {
            if (!this.l) {
                this.e = b;
                if (this.e == null) {
                    this.h.ah = this.c;
                }
            }
        }
        ax(a, b) {
            if (!this.l) {
                this.f = b;
                if (this.f == null) {
                    this.h.ai = this.d;
                }
            }
        }
        a1() {
            this.u = this.h.bt;
        }
    }
    XamRadialGaugeView.$t = /*@__PURE__*/ markType(XamRadialGaugeView, 'XamRadialGaugeView');
    return XamRadialGaugeView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents event argument for FormatRadialGaugeLabel.
*/
class IgrFormatRadialGaugeLabelEventArgs {
    createImplementation() {
        return new FormatRadialGaugeLabelEventArgs();
    }
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    get actualMinimumValue() {
        return this.i.actualMinimumValue;
    }
    get actualMaximumValue() {
        return this.i.actualMaximumValue;
    }
    get startAngle() {
        return this.i.startAngle;
    }
    get endAngle() {
        return this.i.endAngle;
    }
    get angle() {
        return this.i.angle;
    }
    get value() {
        return this.i.value;
    }
    get label() {
        return this.i.label;
    }
    set label(value) {
        this.i.label = value;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents event argument for AlignRadialGaugeLabel.
*/
class IgrAlignRadialGaugeLabelEventArgs extends IgrFormatRadialGaugeLabelEventArgs {
    createImplementation() {
        return new AlignRadialGaugeLabelEventArgs();
    }
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    get width() {
        return this.i.width;
    }
    set width(value) {
        this.i.width = value;
    }
    get height() {
        return this.i.height;
    }
    set height(value) {
        this.i.height = value;
    }
    get offsetX() {
        return this.i.offsetX;
    }
    set offsetX(value) {
        this.i.offsetX = value;
    }
    get offsetY() {
        return this.i.offsetY;
    }
    set offsetY(value) {
        this.i.offsetY = value;
    }
}

let defaultFont$2 = "Verdana, Arial, \"Segoe UI\", \"Myriad Pro\", sans-serif";
let RadialGaugeStylingDefaults = {
    //"ui-radialgauge-needle": {
    //    "background-color": "#333"
    //},
    //"ui-radialgauge-needleCap": {
    //    "background-color": "#494949",
    //    "border-color": "#494949"
    //},
    "ui-radialgauge-backing": {
        "background-color": "#FFFFFF",
        "border-top-color": "#CCCCCC"
    },
    //"ui-radialgauge-scale": {
    //    "background-color": "#44ACD6",
    //    "border": "none"
    //},
    "ui-radialgauge-tick": {
        "background-color": "rgba(0, 0, 0, 0.35)",
        "border-top-color": "none"
    },
    "ui-radialgauge-minorTick": {
        "background-color": "rgba(0, 0, 0, 0.2)",
        "border-top-color": "none"
    },
    "ui-radialgauge-label": {
        "background-color": "#666666",
        "borde-top-color": "none"
    },
    "ui-radialgauge-range-palette-1": {
        "background-color": "#005E9C",
        "border-top-color": "none"
    },
    "ui-radialgauge-range-palette-2": {
        "background-color": "#0078C8",
        "border-top-color": "none"
    },
    "ui-radialgauge-range-palette-3": {
        "background-color": "#0092F4",
        "border-top-color": "none"
    },
    "ui-radialgauge-range-palette-4": {
        "background-color": "#21A7FF",
        "border-top-color": "none"
    },
    "ui-radialgauge-range-palette-5": {
        "background-color": "#4FB9FF",
        "border-top-color": "none"
    },
    "ui-radialgauge": {
        "font-family": defaultFont$2,
        "font-size": "11px"
    },
    "font-family": defaultFont$2,
    "font-style": "normal",
    "font-weight": "normal",
    "font-size": "11px",
    "color": "#666666",
    "font-variant": "",
    "line-height": ""
};

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRadialGaugeRange extends Component {
    constructor(props) {
        super(props);
        this._renderer = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                {
                    this[p] = this.props[p];
                }
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    get rangeInternal() {
        return this.i;
    }
    createImplementation() {
        return new XamRadialGaugeRange();
    }
    _provideRenderer(renderer) {
        this._renderer = renderer;
    }
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets or sets the name of the range.
*/
    get name() {
        return this.i.v;
    }
    set name(v) {
        this.i.v = v;
    }
    /**
     * Gets or sets the brush to use to fill the range.
    */
    get brush() {
        return brushToString(this.i.ao);
    }
    set brush(v) {
        this.i.ao = stringToBrush(v);
    }
    /**
     * Gets or sets the outline to use when rendering the range.
    */
    get outline() {
        return brushToString(this.i.ap);
    }
    set outline(v) {
        this.i.ap = stringToBrush(v);
    }
    /**
     * Gets or sets the value at which the range starts along the scale.
    */
    get startValue() {
        return this.i.o;
    }
    set startValue(v) {
        this.i.o = +v;
    }
    /**
     * Gets or sets the value at which the range ends along the scale.
    */
    get endValue() {
        return this.i.j;
    }
    set endValue(v) {
        this.i.j = +v;
    }
    /**
     * Gets or sets the distance from the center of the gauge (from 0 to 1) at which to start rendering the inner sweep of the range.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get innerStartExtent() {
        return this.i.l;
    }
    set innerStartExtent(v) {
        this.i.l = +v;
    }
    /**
     * Gets or sets the distance from the center of the gauge (from 0 to 1) at which to end rendering the inner sweep of the range.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get innerEndExtent() {
        return this.i.k;
    }
    set innerEndExtent(v) {
        this.i.k = +v;
    }
    /**
     * Gets or sets the distance from the center of the gauge (from 0 to 1) at which to start rendering the outer sweep of the range.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get outerStartExtent() {
        return this.i.n;
    }
    set outerStartExtent(v) {
        this.i.n = +v;
    }
    /**
     * Gets or sets the distance from the center of the gauge (from 0 to 1) at which to end rendering the outer sweep of the range.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get outerEndExtent() {
        return this.i.m;
    }
    set outerEndExtent(v) {
        this.i.m = +v;
    }
    /**
     * Gets or sets the stroke thickness to use when rendering this range's outline.
    */
    get strokeThickness() {
        return this.i.p;
    }
    set strokeThickness(v) {
        this.i.p = +v;
    }
    findByName(name) {
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("RadialGaugeRange");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
}

class IgrRadialGaugeRangeCollection extends IgCollection {
    constructor(list) {
        super();
        if (!IgrRadialGaugeRange.$type) {
            IgrRadialGaugeRange.$type = markType(IgrRadialGaugeRange, "IgrRadialGaugeRange");
        }
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        if (!IgrRadialGaugeRange.$type) {
            IgrRadialGaugeRange.$type = markType(IgrRadialGaugeRange, "IgrRadialGaugeRange");
        }
        let coll = new SyncableObservableCollection$2(IgrRadialGaugeRange.$type, XamRadialGaugeRange.$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext._implementation;
        };
        coll.createFrom = (int) => {
            let ext = int.externalObject;
            if (!ext) {
                ext = IgrRadialGaugeRange._createFromInternal(int);
                if (ext) {
                    ext._implementation = int;
                }
            }
            return ext;
        };
        return coll;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRadialGauge extends Component {
    constructor(props) {
        super(props);
        this.contentRanges = [];
        /**
        * The ranges actually present in the chart. Do not directly modify this array.
        * This array's contents can be modified by causing Angular to reproject the child content.
        * Or adding and removing ranges from the manual ranges collection on the ranges property.
        */
        this.actualRanges = [];
        this._ranges = null;
        this._rangesAdapter = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._formatLabel = null;
        this._formatLabel_wrapped = null;
        this._alignLabel = null;
        this._alignLabel_wrapped = null;
        this._valueChanged = null;
        this._valueChanged_wrapped = null;
        this._actualMinimumValueChange = null;
        this._actualMinimumValueChange_wrapped = null;
        this._actualMaximumValueChange = null;
        this._actualMaximumValueChange_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        this._contentChildrenManager = new ContentChildrenManager((ch) => ch.key || ch.props.name, (ch) => ch.key || ch.props.name, () => this._updateContentChildren());
        let container = null;
        if (document) {
            container = document.createElement("div");
            container.style.display = "block";
            container.style.width = "100%";
            container.style.height = "100%";
        }
        var root;
        root = container;
        this._renderer = new ReactRenderer(root, document, true, RadialGaugeStylingDefaults);
        this._implementation = this.createImplementation();
        this._container = this._renderer.getWrapper(container);
        //this._renderer.rootWrapper.append(this._container);
        //this._container.setStyleProperty("display", "block");
        //this._container.setStyleProperty("width", "100%");
        //this._container.setStyleProperty("height", "100%");
        this._wrapper = this._renderer;
        //var root: any;
        //root = this._container;
        //if (this._container.nativeElement != null) {
        //    root = this._container.nativeElement;
        //}
        var gauge = this.i;
        this._gauge = gauge;
        this._rangesAdapter = new CollectionAdapter(this.contentRanges, this.i.ranges, this.actualRanges, (c) => c.i, (i) => {
            i._provideRenderer(this._wrapper);
            if (this._container && this._container.getNativeElement().parentElement) {
                i._styling(this._container.getNativeElement(), this, this);
            }
        }, (i) => { i._provideRenderer(null); });
        gauge.provideContainer(this._renderer);
        this._renderer.addSizeWatcher(() => {
            this._gauge.containerResized();
        });
    }
    set height(value) {
        this._height = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this.containerResized();
        }
    }
    get height() {
        return this._height;
    }
    set width(value) {
        this._width = value;
        if (this._elRef) {
            this._elRef.style.width = value;
            this.containerResized();
        }
    }
    get width() {
        return this._width;
    }
    _updateContentChildren() {
        this.contentRanges.length = 0;
        let contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (let i = 0; i < contentChildrenActual.length; i++) {
            if ((XamRadialGaugeRange.$type).isAssignableFrom(contentChildrenActual[i].i.$type)) {
                this.contentRanges.push(contentChildrenActual[i]);
            }
        }
        if (this._rangesAdapter !== null) {
            this._rangesAdapter.notifyContentChanged();
        }
    }
    /**
     * A collection or manually added axes for the chart.
    */
    get ranges() {
        if (this._ranges === null) {
            let coll = new IgrRadialGaugeRangeCollection();
            let inner = coll._innerColl;
            inner.addListener((sender, e) => {
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._rangesAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._rangesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._rangesAdapter.clearManualItems();
                        break;
                }
            });
            this._ranges = coll;
        }
        return this._ranges;
    }
    render() {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        let children = this._contentChildrenManager.getChildren(this.props.children);
        let div = createElement("div", {
            className: "ig-radial-gauge igr-radial-gauge",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                {
                    this[p] = this.props[p];
                }
            }
        }
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container.getNativeElement());
        this.containerResized();
        this.initializeContent();
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    _getMainRef(div) {
        this._elRef = div;
    }
    destroy() {
        this._gauge.destroy();
        this._wrapper.destroy();
    }
    createImplementation() {
        return new XamRadialGauge();
    }
    initializeContent() {
        this._styling(this._container.getNativeElement(), this);
        if (this.actualRanges && this.actualRanges.length > 0) {
            var currRange = this.actualRanges;
            for (var i = 0; i < currRange.length; i++) {
                currRange[i]._styling(this._container.getNativeElement(), this, this);
            }
        }
        this._updateContentChildren();
        this.i.containerResized();
    }
    componentWillUnmount() {
        //this._grid.destroy();
        this.destroy();
    }
    initializeProperties() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets or sets a collection of brushes to be used as the palette for gauge ranges.
*/
    get rangeBrushes() {
        return fromBrushCollection(this.i.ah);
    }
    set rangeBrushes(v) {
        this.i.ah = toBrushCollection(v);
    }
    /**
     * Gets or sets a collection of brushes to be used as the palette for gauge outlines.
    */
    get rangeOutlines() {
        return fromBrushCollection(this.i.ai);
    }
    set rangeOutlines(v) {
        this.i.ai = toBrushCollection(v);
    }
    /**
     * Gets or sets the minimum value of the scale.
    */
    get minimumValue() {
        return this.i.cc;
    }
    set minimumValue(v) {
        this.i.cc = +v;
    }
    /**
     * Gets the resolved minimum value of the scale.
    */
    get actualMinimumValue() {
        return this.i.bs;
    }
    set actualMinimumValue(v) {
        this.i.bs = +v;
    }
    /**
     * Gets or sets the maximum value of the scale.
    */
    get maximumValue() {
        return this.i.ca;
    }
    set maximumValue(v) {
        this.i.ca = +v;
    }
    /**
     * Gets the resolved maximum value of the scale.
    */
    get actualMaximumValue() {
        return this.i.br;
    }
    set actualMaximumValue(v) {
        this.i.br = +v;
    }
    /**
     * Gets or sets the interval to use for the scale.
    */
    get interval() {
        return this.i.b6;
    }
    set interval(v) {
        this.i.b6 = +v;
    }
    /**
     * Gets or sets the x position of the center of the gauge with the value ranging from 0 to 1.
    */
    get centerX() {
        return this.i.b3;
    }
    set centerX(v) {
        this.i.b3 = +v;
    }
    /**
     * Gets or sets the y position of the center of the gauge with the value ranging from 0 to 1.
    */
    get centerY() {
        return this.i.b4;
    }
    set centerY(v) {
        this.i.b4 = +v;
    }
    /**
     * Gets or sets the value at which to point the needle of the gauge.
    */
    get value() {
        return this.i.dm;
    }
    set value(v) {
        this.i.dm = +v;
    }
    /**
     * Gets or sets the start angle for the scale in degrees.
    */
    get scaleStartAngle() {
        return this.i.da;
    }
    set scaleStartAngle(v) {
        this.i.da = +v;
    }
    /**
     * Gets or sets the end angle for the scale in degrees.
    */
    get scaleEndAngle() {
        return this.i.c5;
    }
    set scaleEndAngle(v) {
        this.i.c5 = +v;
    }
    /**
     * Gets or sets the direction in which the scale sweeps around the center from the start angle to end angle.
    */
    get scaleSweepDirection() {
        return this.i.ii;
    }
    set scaleSweepDirection(v) {
        this.i.ii = ensureEnum(SweepDirection_$type, v);
    }
    /**
     * Gets or sets the number of milliseconds over which changes to the gauge should be animated.
    */
    get transitionDuration() {
        return this.i.dn;
    }
    set transitionDuration(v) {
        this.i.dn = +v;
    }
    /**
     * Gets or sets the easing function used to morph the current series.
    */
    get transitionEasingFunction() {
        return this.i.a0;
    }
    set transitionEasingFunction(v) {
        this.i.a0 = v;
    }
    /**
     * Gets or sets the brush to use when rendering the fill of the needle.
    */
    get needleBrush() {
        return brushToString(this.i.ib);
    }
    set needleBrush(v) {
        this.i.ib = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use when rendering the outline of the needle.
    */
    get needleOutline() {
        return brushToString(this.i.ic);
    }
    set needleOutline(v) {
        this.i.ic = stringToBrush(v);
    }
    /**
     * Gets or sets the extent (from -1 to 1) at which to start rendering the needle, measured from the center of the gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needleStartExtent() {
        return this.i.cv;
    }
    set needleStartExtent(v) {
        this.i.cv = +v;
    }
    /**
     * Gets or sets the extent (from -1 to 1) at which to end rendering the needle, measured from the center of the gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needleEndExtent() {
        return this.i.cn;
    }
    set needleEndExtent(v) {
        this.i.cn = +v;
    }
    /**
     * Gets or sets the shape to use when rendering the needle from a number of options.
    */
    get needleShape() {
        return this.i.ar;
    }
    set needleShape(v) {
        this.i.ar = ensureEnum(RadialGaugeNeedleShape_$type, v);
    }
    /**
     * Gets or sets the width of the needle at its point using a value from (0 to 1). Note: Only some needle shapes respect this property.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needleStartWidthRatio() {
        return this.i.cw;
    }
    set needleStartWidthRatio(v) {
        this.i.cw = +v;
    }
    /**
     * Gets or sets the width of the needle at its point using a value from (0 to 1). Note: Only some needle shapes respect this property.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needleEndWidthRatio() {
        return this.i.co;
    }
    set needleEndWidthRatio(v) {
        this.i.co = +v;
    }
    /**
     * Gets or sets the width of the needle at its feature which is closest to the base (e.g. a bulb) with a value from 0 to 1. Note: Only some needle shapes respect this property, namely: NeedleWithBulb, RectangleWithBulb, TrapezoidWithBulb, and TriangleWithBulb.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needleBaseFeatureWidthRatio() {
        return this.i.cm;
    }
    set needleBaseFeatureWidthRatio(v) {
        this.i.cm = +v;
    }
    /**
     * Gets or sets the extent of the feature which is closest to the base (e.g. a bulb) with a value from -1 to 1. Note: Only some needle shapes respect this property, namely: NeedleWithBulb, RectangleWithBulb, TrapezoidWithBulb, and TriangleWithBulb.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needleBaseFeatureExtent() {
        return this.i.cl;
    }
    set needleBaseFeatureExtent(v) {
        this.i.cl = +v;
    }
    /**
     * Gets or sets the width of the needle at its feature which is closest to the point (e.g. the tapering point of a needle) with a value from 0 to 1. Note: Only some needle shapes respect this property.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needlePointFeatureWidthRatio() {
        return this.i.cu;
    }
    set needlePointFeatureWidthRatio(v) {
        this.i.cu = +v;
    }
    /**
     * Gets or sets the extent of the feature which is closest to the point (e.g. the tapering point of a needle) with a value from -1 to 1. Note: Only some needle shapes respect this property.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needlePointFeatureExtent() {
        return this.i.ct;
    }
    set needlePointFeatureExtent(v) {
        this.i.ct = +v;
    }
    /**
     * Gets or sets the width of the cap of the needle with a value from 0 to 1. Note: Will only take effect if you have a cap set on the needle.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get needlePivotWidthRatio() {
        return this.i.cs;
    }
    set needlePivotWidthRatio(v) {
        this.i.cs = +v;
    }
    /**
     * Gets or sets the width of the inner cutout section of the needle cap with a value from 0 to 1. Note: Will only take effect if you have a cap set on the needle that has a cutout section.
    */
    get needlePivotInnerWidthRatio() {
        return this.i.cp;
    }
    set needlePivotInnerWidthRatio(v) {
        this.i.cp = +v;
    }
    /**
     * Gets or sets the shape to use for the needle cap.
    */
    get needlePivotShape() {
        return this.i.as;
    }
    set needlePivotShape(v) {
        this.i.as = ensureEnum(RadialGaugePivotShape_$type, v);
    }
    /**
     * Gets or sets the position at which to start rendering the scale, measured from the center of the gauge as a value from 0 to 1.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get scaleStartExtent() {
        return this.i.db;
    }
    set scaleStartExtent(v) {
        this.i.db = +v;
    }
    /**
     * Gets or sets the brush to use for filling the needle cap. Note: this only applies to certain cap shapes.
    */
    get needlePivotBrush() {
        return brushToString(this.i.id);
    }
    set needlePivotBrush(v) {
        this.i.id = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the outlines of the needle cap.
    */
    get needlePivotOutline() {
        return brushToString(this.i.ie);
    }
    set needlePivotOutline(v) {
        this.i.ie = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness of the needle outline.
    */
    get needleStrokeThickness() {
        return this.i.cx;
    }
    set needleStrokeThickness(v) {
        this.i.cx = +v;
    }
    /**
     * Gets or sets the stroke thickness to use for the outline of the needle cap.
    */
    get needlePivotStrokeThickness() {
        return this.i.cq;
    }
    set needlePivotStrokeThickness(v) {
        this.i.cq = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the scale as a value from 0 to 1 measured from the center of the gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get scaleEndExtent() {
        return this.i.c6;
    }
    set scaleEndExtent(v) {
        this.i.c6 = +v;
    }
    /**
     * Gets or sets the position at which to put the labels as a value from 0 to 1, measured form the center of the gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get labelExtent() {
        return this.i.b7;
    }
    set labelExtent(v) {
        this.i.b7 = +v;
    }
    /**
     * Gets or sets the interval to use for rendering labels. This defaults to be the same interval as the tickmarks on the scale.
    */
    get labelInterval() {
        return this.i.b9;
    }
    set labelInterval(v) {
        this.i.b9 = +v;
    }
    /**
     * Gets or sets the position at which to start rendering the major tickmarks as a value from 0 to 1, measured from the center of the gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get tickStartExtent() {
        return this.i.dg;
    }
    set tickStartExtent(v) {
        this.i.dg = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the major tickmarks as a value from 0 to 1, measured from the center of the gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get tickEndExtent() {
        return this.i.de;
    }
    set tickEndExtent(v) {
        this.i.de = +v;
    }
    /**
     * Gets or sets the stroke thickness to use when rendering ticks.
    */
    get tickStrokeThickness() {
        return this.i.di;
    }
    set tickStrokeThickness(v) {
        this.i.di = +v;
    }
    /**
     * Gets or sets the brush to use for the major tickmarks.
    */
    get tickBrush() {
        return brushToString(this.i.ih);
    }
    set tickBrush(v) {
        this.i.ih = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the label font.
    */
    get fontBrush() {
        return brushToString(this.i.h8);
    }
    set fontBrush(v) {
        this.i.h8 = stringToBrush(v);
    }
    /**
     * Gets or sets the position at which to start rendering the minor tickmarks as a value from 0 to 1, measured from the center of the gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get minorTickStartExtent() {
        return this.i.ch;
    }
    set minorTickStartExtent(v) {
        this.i.ch = +v;
    }
    /**
     * Gets or sets the position at which to stop rendering the minor tickmarks as a value from 0 to 1, measured from the center of the gauge.
     * Values further from zero than 1 can be used to make this extend further than the normal radius of the gauge.
    */
    get minorTickEndExtent() {
        return this.i.cf;
    }
    set minorTickEndExtent(v) {
        this.i.cf = +v;
    }
    /**
     * Gets or sets the stroke thickness to use when rendering minor ticks.
    */
    get minorTickStrokeThickness() {
        return this.i.cj;
    }
    set minorTickStrokeThickness(v) {
        this.i.cj = +v;
    }
    /**
     * Gets or sets the brush to use for the minor tickmarks.
    */
    get minorTickBrush() {
        return brushToString(this.i.ia);
    }
    set minorTickBrush(v) {
        this.i.ia = stringToBrush(v);
    }
    /**
     * Gets or sets the number of minor tickmarks to place between major tickmarks.
    */
    get minorTickCount() {
        return this.i.ce;
    }
    set minorTickCount(v) {
        this.i.ce = +v;
    }
    /**
     * Gets or sets the brush to use to fill the background of the scale.
    */
    get scaleBrush() {
        return brushToString(this.i.ig);
    }
    set scaleBrush(v) {
        this.i.ig = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use to fill the backing of the gauge.
    */
    get backingBrush() {
        return brushToString(this.i.h6);
    }
    set backingBrush(v) {
        this.i.h6 = stringToBrush(v);
    }
    /**
     * Gets or sets the brush to use for the outline of the backing.
    */
    get backingOutline() {
        return brushToString(this.i.h7);
    }
    set backingOutline(v) {
        this.i.h7 = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness of the backing outline.
    */
    get backingStrokeThickness() {
        return this.i.b1;
    }
    set backingStrokeThickness(v) {
        this.i.b1 = +v;
    }
    /**
     * Gets or sets the outer extent of the gauge backing.
    */
    get backingOuterExtent() {
        return this.i.by;
    }
    set backingOuterExtent(v) {
        this.i.by = +v;
    }
    /**
     * Gets or sets the over sweep angle to apply to the backing if it is displaying fitted (in degrees). Must be greater or equal to 0.
    */
    get backingOversweep() {
        return this.i.b0;
    }
    set backingOversweep(v) {
        this.i.b0 = +v;
    }
    /**
     * Gets or sets the extra degrees of sweep to apply to the scale background. Must be greater or equal to 0.
    */
    get scaleOversweep() {
        return this.i.c8;
    }
    set scaleOversweep(v) {
        this.i.c8 = +v;
    }
    /**
     * Gets or sets the oversweep shape to use for the excess fill area for the scale.
    */
    get scaleOversweepShape() {
        return this.i.au;
    }
    set scaleOversweepShape(v) {
        this.i.au = ensureEnum(RadialGaugeScaleOversweepShape_$type, v);
    }
    /**
     * Gets or sets the corner rounding radius to use for the fitted scale backings.
    */
    get backingCornerRadius() {
        return this.i.bu;
    }
    set backingCornerRadius(v) {
        this.i.bu = +v;
    }
    /**
     * Gets or sets the inner extent of the gauge backing.
    */
    get backingInnerExtent() {
        return this.i.bw;
    }
    set backingInnerExtent(v) {
        this.i.bw = +v;
    }
    /**
     * Gets or sets the type of shape to use for the backing of the gauge.
    */
    get backingShape() {
        return this.i.am;
    }
    set backingShape(v) {
        this.i.am = ensureEnum(RadialGaugeBackingShape_$type, v);
    }
    /**
     * Gets or sets the multiplying factor to apply to the normal radius of the gauge.
     * The radius of the gauge is defined by the minimum of the width and height of the control divided by 2.0.
     * This introduces a multiplicative factor to that value.
    */
    get radiusMultiplier() {
        return this.i.c0;
    }
    set radiusMultiplier(v) {
        this.i.c0 = +v;
    }
    /**
     * Gets or sets the strategy to use for omitting labels if the first and last label have the same value.
    */
    get duplicateLabelOmissionStrategy() {
        return this.i.an;
    }
    set duplicateLabelOmissionStrategy(v) {
        this.i.an = ensureEnum(RadialGaugeDuplicateLabelOmissionStrategy_$type, v);
    }
    /**
     * Gets or sets whether needle dragging is enabled or not.
    */
    get isNeedleDraggingEnabled() {
        return this.i.ba;
    }
    set isNeedleDraggingEnabled(v) {
        this.i.ba = ensureBool(v);
    }
    /**
     * Gets or sets whether the needle is constrained within the minimum and maximum value range during dragging.
    */
    get isNeedleDraggingConstrained() {
        return this.i.a9;
    }
    set isNeedleDraggingConstrained(v) {
        this.i.a9 = ensureBool(v);
    }
    /**
     * Gets or sets the font.
    */
    get font() {
        return this.i.d2;
    }
    set font(v) {
        this.i.d2 = v;
    }
    /**
     * Gets or sets the label composite format used when creating label values.
    */
    get labelFormat() {
        return this.i.d9;
    }
    set labelFormat(v) {
        this.i.d9 = v;
    }
    /**
     * Gets or sets the format specifiers to use with the LabelFormat string.
    */
    get labelFormatSpecifiers() {
        return this.i.ag;
    }
    set labelFormatSpecifiers(v) {
        this.i.ag = v;
    }
    /**
     * Gets a value indicating whether the radial gauge is currently animating.
    */
    get animating() {
        return this.i.a6;
    }
    /**
     * Gets the transition progress of the animation when the control is animating.
    */
    get transitionProgress() {
        return this.i.dk;
    }
    set transitionProgress(v) {
        this.i.dk = +v;
    }
    /**
     * Gets or sets the scaling value used to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get pixelScalingRatio() {
        return this.i.cz;
    }
    set pixelScalingRatio(v) {
        this.i.cz = +v;
    }
    /**
     * Gets the actual pixel scaling ratio used to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get actualPixelScalingRatio() {
        return this.i.bt;
    }
    set actualPixelScalingRatio(v) {
        this.i.bt = +v;
    }
    findByName(name) {
        if (this.ranges != null && this.ranges.findByName && this.ranges.findByName(name)) {
            return this.ranges.findByName(name);
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("RadialGauge");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Scales a value on the gauge's main scale to an angle around the center point of the gauge, in radians.

* @param value  * The value to scale.
*/
    scaleValue(value) {
        let iv = this.i.dd(value);
        return (iv);
    }
    /**
     * Unscales a value from an angle in radians to the represented value along the main scale of the gauge.
    
    * @param angle  * The angle in radians to unscale to a value.
    */
    unscaleValue(angle) {
        let iv = this.i.dl(angle);
        return (iv);
    }
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
    
    * @param point  * The point for which to retrieve the associated value.
    */
    getValueForPoint(point) {
        let iv = this.i.b5(toPoint(point));
        return (iv);
    }
    getPointForValue(value, extent) {
        let iv = this.i.ik(value, extent);
        return fromPoint(iv);
    }
    styleUpdated() {
        this.i.gd();
    }
    needleContainsPoint(point, isFinger) {
        let iv = this.i.needleContainsPoint(toPoint(point), isFinger);
        return (iv);
    }
    /**
     * Called by the UI framework to provide a UI container for rendering this control.
    
    * @param container  * The UI container element.
    */
    provideContainer(container) {
        this.i.provideContainer(container);
    }
    containerResized() {
        this.i.containerResized();
    }
    /**
     * Use to force the radial gauge to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the radial gauge needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the radial gauge.
    
    */
    flush() {
        this.i.fs();
    }
    /**
     * Returns visuals as a serialized string.
    
    */
    exportSerializedVisualData() {
        let iv = this.i.d1();
        return (iv);
    }
    /**
     * Event which is raised when a label of the gauge is formatted.
     * Function takes first argument null and second argument ui.
     * Use ui.owner to obtain reference to gauge widget.
     * Use ui.actualMinimumValue to obtain the minimum value of gauge scale.
     * Use ui.actualMaximumValue to obtain the maximum value of gauge scale.
     * Use ui.startAngle to obtain the starting angle of gauge scale.
     * Use ui.endAngle to obtain the ending angle of gauge scale.
     * Use ui.angle to obtain the angle on the gauge scale at which the label will be located.
     * Use ui.value to obtain the value on the gauge scale associated with the label.
     * Use ui.label to obtain the string value of the label.
    */
    get formatLabel() {
        return this._formatLabel;
    }
    set formatLabel(ev) {
        if (this._formatLabel_wrapped !== null) {
            this.i.formatLabel = delegateRemove(this.i.formatLabel, this._formatLabel_wrapped);
            this._formatLabel_wrapped = null;
            this._formatLabel = null;
        }
        this._formatLabel = ev;
        this._formatLabel_wrapped = (o, e) => {
            let outerArgs = new IgrFormatRadialGaugeLabelEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFormatLabel) {
                this.beforeFormatLabel(this, outerArgs);
            }
            if (this._formatLabel) {
                this._formatLabel(this, outerArgs);
            }
        };
        this.i.formatLabel = delegateCombine(this.i.formatLabel, this._formatLabel_wrapped);
    }
    /**
     * Event which is raised when a label of the gauge is aligned along the scale.
     * Function takes first argument null and second argument ui.
     * Use ui.owner to obtain reference to gauge widget.
     * Use ui.actualMinimumValue to obtain the minimum value of gauge scale.
     * Use ui.actualMaximumValue to obtain the maximum value of gauge scale.
     * Use ui.startAngle to obtain the starting angle of gauge scale.
     * Use ui.endAngle to obtain the ending angle of gauge scale.
     * Use ui.angle to obtain the angle on the gauge scale at which the label will be located.
     * Use ui.value to obtain the value on the gauge scale associated with the label.
     * Use ui.label to obtain the string value of the label.
     * Use ui.width to obtain the width of the label.
     * Use ui.height to obtain the height of the label.
     * Use ui.offsetX to obtain the X offset of the label on the gauge scale.
     * Use ui.offsetY to obtain the Y offset of the label on the gauge scale.
    */
    get alignLabel() {
        return this._alignLabel;
    }
    set alignLabel(ev) {
        if (this._alignLabel_wrapped !== null) {
            this.i.alignLabel = delegateRemove(this.i.alignLabel, this._alignLabel_wrapped);
            this._alignLabel_wrapped = null;
            this._alignLabel = null;
        }
        this._alignLabel = ev;
        this._alignLabel_wrapped = (o, e) => {
            let outerArgs = new IgrAlignRadialGaugeLabelEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeAlignLabel) {
                this.beforeAlignLabel(this, outerArgs);
            }
            if (this._alignLabel) {
                this._alignLabel(this, outerArgs);
            }
        };
        this.i.alignLabel = delegateCombine(this.i.alignLabel, this._alignLabel_wrapped);
    }
    /**
     * Occurs when the Value property changes.
    */
    get valueChanged() {
        return this._valueChanged;
    }
    set valueChanged(ev) {
        if (this._valueChanged_wrapped !== null) {
            this.i.valueChanged = delegateRemove(this.i.valueChanged, this._valueChanged_wrapped);
            this._valueChanged_wrapped = null;
            this._valueChanged = null;
        }
        this._valueChanged = ev;
        this._valueChanged_wrapped = (o, e) => {
            let outerArgs = new IgrDoubleValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeValueChanged) {
                this.beforeValueChanged(this, outerArgs);
            }
            if (this._valueChanged) {
                this._valueChanged(this, outerArgs);
            }
        };
        this.i.valueChanged = delegateCombine(this.i.valueChanged, this._valueChanged_wrapped);
    }
    get actualMinimumValueChange() {
        return this._actualMinimumValueChange;
    }
    set actualMinimumValueChange(ev) {
        if (this._actualMinimumValueChange_wrapped !== null) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
            this._actualMinimumValueChange_wrapped = null;
            this._actualMinimumValueChange = null;
        }
        this._actualMinimumValueChange = ev;
        this._actualMinimumValueChange_wrapped = (o, e) => {
            let ext = this.actualMinimumValue;
            if (this.beforeActualMinimumValueChange) {
                this.beforeActualMinimumValueChange(this, ext);
            }
            if (this._actualMinimumValueChange) {
                this._actualMinimumValueChange(this, ext);
            }
        };
        this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMinimumValueChange_wrapped);
    }
    get actualMaximumValueChange() {
        return this._actualMaximumValueChange;
    }
    set actualMaximumValueChange(ev) {
        if (this._actualMaximumValueChange_wrapped !== null) {
            this.i.propertyChanged = delegateRemove(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
            this._actualMaximumValueChange_wrapped = null;
            this._actualMaximumValueChange = null;
        }
        this._actualMaximumValueChange = ev;
        this._actualMaximumValueChange_wrapped = (o, e) => {
            let ext = this.actualMaximumValue;
            if (this.beforeActualMaximumValueChange) {
                this.beforeActualMaximumValueChange(this, ext);
            }
            if (this._actualMaximumValueChange) {
                this._actualMaximumValueChange(this, ext);
            }
        };
        this.i.propertyChanged = delegateCombine(this.i.propertyChanged, this._actualMaximumValueChange_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRadialGaugeRangeModule {
    static register() {
        TypeRegistrar.registerCons('IgrRadialGaugeRange', IgrRadialGaugeRange);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRadialGaugeCoreModule {
    static register() {
        TypeRegistrar.registerCons('IgrRadialGauge', IgrRadialGauge);
        IgrRadialGaugeRangeModule.register();
        IgrNumberFormatSpecifierModule.register();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRadialGaugeModule {
    static register() {
        IgrRadialGaugeCoreModule.register();
        IgrDVInteractivityModule.register();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CommonData = /*@__PURE__*/ (() => {
    class CommonData extends Base {
        constructor() {
            super(...arguments);
            this._borderBrush = null;
            this._borderThickness = null;
        }
        get borderBrush() {
            return this._borderBrush;
        }
        set borderBrush(a) {
            this._borderBrush = a;
        }
        get borderThickness() {
            return this._borderThickness;
        }
        set borderThickness(a) {
            this._borderThickness = a;
        }
    }
    CommonData.$t = /*@__PURE__*/ markType(CommonData, 'CommonData');
    return CommonData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ScaleVisualData = /*@__PURE__*/ (() => {
    class ScaleVisualData extends Base {
    }
    ScaleVisualData.$t = /*@__PURE__*/ markType(ScaleVisualData, 'ScaleVisualData');
    return ScaleVisualData;
})();

export { AlignLinearGraphLabelEventArgs, AlignRadialGaugeLabelEventArgs, BackingFrame, BulletGraphFrame, BulletGraphScaleFrame, BulletGraphStylingDefaults, BulletGraphTargetValueVisualData, BulletGraphVisualData, CommonData, FormatLinearGraphLabelEventArgs, FormatRadialGaugeLabelEventArgs, GaugeVisualData, IgrAlignLinearGraphLabelEventArgs, IgrAlignRadialGaugeLabelEventArgs, IgrBulletGraph, IgrBulletGraphCoreModule, IgrBulletGraphModule, IgrFormatLinearGraphLabelEventArgs, IgrFormatRadialGaugeLabelEventArgs, IgrLinearGauge, IgrLinearGaugeCoreModule, IgrLinearGaugeModule, IgrLinearGraphRange, IgrLinearGraphRangeCollection, IgrLinearGraphRangeModule, IgrRadialGauge, IgrRadialGaugeCoreModule, IgrRadialGaugeModule, IgrRadialGaugeRange, IgrRadialGaugeRangeCollection, IgrRadialGaugeRangeModule, LinearGaugeFrame, LinearGaugeScaleFrame, LinearGaugeStylingDefaults, LinearGaugeVisualData, LinearGraphBackingFrame, LinearGraphFrame, LinearGraphNeedleFrame, LinearGraphNeedleParameters, LinearGraphNeedlePreparer, LinearGraphNeedleShape, LinearGraphNeedleShape_$type, LinearGraphRangeCollection, LinearGraphRangeVisualData, LinearGraphRangeVisualDataList, LinearGraphRectFrame, LinearGraphScaleFrame, LinearGraphScaleLabelVisualData, LinearGraphScaleLabelVisualDataList, LinearGraphScaleTickmarkVisualData, LinearGraphScaleTickmarkVisualDataList, LinearGraphScaler, LinearGraphToolTipVisualData, LinearGraphTooltipDataContext, LinearGraphVisualData, LinearNeedleVisualData, LinearNeedleVisualDataList, LinearScaleOrientation, LinearScaleOrientation_$type, LinearScaleVisualData, MorphSegment, NeedleVisualData, RadialGaugeBackingShape, RadialGaugeBackingShape_$type, RadialGaugeDuplicateLabelOmissionStrategy, RadialGaugeDuplicateLabelOmissionStrategy_$type, RadialGaugeFrame, RadialGaugeNeedleFrame, RadialGaugeNeedleParameters, RadialGaugeNeedlePreparer, RadialGaugeNeedleShape, RadialGaugeNeedleShape_$type, RadialGaugePivotShape, RadialGaugePivotShape_$type, RadialGaugeRangeCollection, RadialGaugeRangeFrame, RadialGaugeScaleFrame, RadialGaugeScaleOversweepShape, RadialGaugeScaleOversweepShape_$type, RadialGaugeScaler, RadialGaugeStylingDefaults, RangeVisualData, RangeVisualDataList, ScaleLabelVisualData, ScaleLabelVisualDataList, ScaleTickmarkVisualData, ScaleTickmarkVisualDataList, ScaleVisualData, TitlesPosition, TitlesPosition_$type, ToolTipInfo, ToolTipItemVisualData, ValueVisualData, XamBulletGraph, XamBulletGraphView, XamLinearGauge, XamLinearGaugeView, XamLinearGraphRange, XamRadialGauge, XamRadialGaugeRange, XamRadialGaugeView };
//# sourceMappingURL=igniteui-react-gauges.js.map
